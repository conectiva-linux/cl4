diff -ruN linux-2.2.3/MAINTAINERS linux-2.2.3.smart2/MAINTAINERS
--- linux-2.2.3/MAINTAINERS	Sun Mar 21 23:53:01 1999
+++ linux-2.2.3.smart2/MAINTAINERS	Sun Mar 21 23:40:28 1999
@@ -264,6 +264,12 @@
 L:	linux-raid@vger.rutgers.edu
 S:	Maintained
 
+COMPAQ SMART2 RAID DRIVER
+P:	Chris Frantz
+M:	Chris Frantz <arrays@compaq.com>
+L:	linux-raid@vger.rutgers.edu
+S:	Maintained
+
 EATA ISA/EISA/PCI SCSI DRIVER
 P:	Dario Ballabio
 M:	dario@milano.europe.dg.com
diff -ruN linux-2.2.3/drivers/block/Config.in linux-2.2.3.smart2/drivers/block/Config.in
--- linux-2.2.3/drivers/block/Config.in	Sun Mar 21 23:53:00 1999
+++ linux-2.2.3.smart2/drivers/block/Config.in	Sun Mar 21 23:40:28 1999
@@ -115,6 +115,11 @@
 if [ "$CONFIG_PCI" = "y" ]; then
   tristate 'Mylex DAC960 PCI RAID Controller support' CONFIG_BLK_DEV_DAC960
 fi
+tristate 'Compaq SMART2 support' CONFIG_BLK_CPQ_DA
+if [ "$CONFIG_BLK_CPQ_DA" != "n" ]; then
+	bool '     Support for PCI SMART2 adapters' CONFIG_BLK_CPQ_DA_PCI $CONFIG_BLK_CPQ_DA
+	bool '     Support for EISA SMART2 adapters' CONFIG_BLK_CPQ_DA_EISA $CONFIG_BLK_CPQ_DA
+fi
 
 # PARIDE doesn't need PARPORT, but if PARPORT is configured as a module,
 # PARIDE must also be a module.  The bogus CONFIG_PARIDE_PARPORT option
diff -ruN linux-2.2.3/drivers/block/MKDEV.ida linux-2.2.3.smart2/drivers/block/MKDEV.ida
--- linux-2.2.3/drivers/block/MKDEV.ida	Wed Dec 31 19:00:00 1969
+++ linux-2.2.3.smart2/drivers/block/MKDEV.ida	Sun Mar 21 23:40:28 1999
@@ -0,0 +1,38 @@
+#!/usr/bin/perl
+#
+#    Script to make device nodes for the SMART2 Disk Array Driver
+#    Copyright 1998 Compaq Computer Corporation
+#
+#    This program is free software; you can redistribute it and/or modify
+#    it under the terms of the GNU General Public License as published by
+#    the Free Software Foundation; either version 2 of the License, or
+#    (at your option) any later version.
+#
+#    This program is distributed in the hope that it will be useful,
+#    but WITHOUT ANY WARRANTY; without even the implied warranty of
+#    MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, GOOD TITLE or
+#    NON INFRINGEMENT.  See the GNU General Public License for more details.
+#
+#    You should have received a copy of the GNU General Public License
+#    along with this program; if not, write to the Free Software
+#    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+#
+#    Questions/Comments/Bugfixes to arrays@compaq.com
+#
+
+$nr_ctlr = shift || 1;
+$nr_logdsk = shift || 16;
+$nr_part= shift || 16;
+$major = 72;
+
+system "mkdir -p /dev/ida";
+for($ctlr=0; $ctlr < $nr_ctlr; $ctlr++) {
+	for($logdsk=0; $logdsk < $nr_logdsk; $logdsk++) {
+		$cmd = sprintf("mknod /dev/ida/c%dd%d b %d %d", $ctlr, $logdsk, $ctlr+$major, $logdsk*16);
+		system $cmd;
+		for($part=1; $part < $nr_part; $part++) {
+			$cmd = sprintf("mknod /dev/ida/c%dd%dp%d b %d %d", $ctlr, $logdsk, $part, $ctlr+$major, $logdsk*16+$part);
+			system $cmd;
+		}
+	}
+}
diff -ruN linux-2.2.3/drivers/block/Makefile linux-2.2.3.smart2/drivers/block/Makefile
--- linux-2.2.3/drivers/block/Makefile	Sun Mar 21 23:53:00 1999
+++ linux-2.2.3.smart2/drivers/block/Makefile	Sun Mar 21 23:40:28 1999
@@ -238,6 +238,14 @@
   endif
 endif
 
+ifeq ($(CONFIG_BLK_CPQ_DA),y)
+L_OBJS += cpqarray.o
+else
+  ifeq ($(CONFIG_BLK_CPQ_DA),m)
+  M_OBJS += cpqarray.o
+  endif
+endif
+
 ifeq ($(CONFIG_BLK_DEV_MD),y)
 LX_OBJS += md.o
 
diff -ruN linux-2.2.3/drivers/block/README.smart2 linux-2.2.3.smart2/drivers/block/README.smart2
--- linux-2.2.3/drivers/block/README.smart2	Wed Dec 31 19:00:00 1969
+++ linux-2.2.3.smart2/drivers/block/README.smart2	Sun Mar 21 23:40:28 1999
@@ -0,0 +1,88 @@
+This driver is for Compaq's SMART2 Intellegent Disk Array Controllers.
+
+WARNING:
+--------
+
+This is still development code.  It seems to work fine for me, but I haven't
+done any real hardcore testing against this driver.  Also, things are likely
+to change, such as the major number used by the device driver as well as the
+names of the /dev entries.
+
+Installing:
+-----------
+
+You need to build a new kernel to use this device, even if you want to
+use a loadable module.  This driver requires Leonard N. Zubkoff's excellent
+patches to ll_rw_blk.c (to controll the number of scatter/gather elements
+sent to lower disk drivers).  Visit http://www.dandelion.com/Linux/DAC960.html
+to get his patches.
+
+Apply the patch to a 2.1.130 kernel after applying Leonard's patch:
+
+# cd linux
+# patch -p1 <DAC960.patch
+# patch -p1 <smart2.patch
+
+Then build a new kernel and turn on Compaq SMART2 Disk Array support.
+Create device nodes for the diskarray device:
+
+# mkdev.ida [ctlrs]
+
+Where ctlrs is the number of controllers you have (defaults to 1 if not
+specified).
+
+EISA Controllers:
+-----------------
+
+If you want to use an EISA controller you'll have to turn on EISA support
+and supply some insmod/lilo paramaters.  If the driver is compiled into the
+kernel, must give it port/irq data at boot time.  For example, if you had
+two SMART-2/E controllers, in EISA slots 1 and 2, on irqs 15 and 5 respectively
+you'd give it a boot argument like this:
+
+	smart2=0x1000,0xf,0x2000,0x5
+
+If you were loading the driver as a module, you'd give load it like this:
+
+	insmod cpqarray.o eisa=0x1000,0xf,0x2000,0x5
+
+You can use EISA and PCI adapters at the same time.
+
+Booting:
+--------
+
+You'll need to use a modified lilo if you want to boot from a disk array.
+Its simply a version of lilo with some code added to tell it how to
+understand Compaq diskarray devices.
+
+Device Naming:
+--------------
+
+You need some entries in /dev for the ida device.  The mkdev.ida script
+can make device nodes for you automatically.  Currently the device setup
+is as follows:
+
+Major numbers:
+	72	ida0
+	73	ida1
+	74	ida2
+	etc...
+
+Minor numbers:
+        b7 b6 b5 b4 b3 b2 b1 b0
+        |----+----| |----+----|
+             |           |
+             |           +-------- Partition ID (0=wholedev, 1-15 partition)
+             |
+             +-------------------- Logical Volume number
+
+The suggested device naming scheme is:
+/dev/ida/c0d0		Controller 0, disk 0, whole device
+/dev/ida/c0d0p1		Controller 0, disk 0, partition 1
+/dev/ida/c0d0p2		Controller 0, disk 0, partition 2
+/dev/ida/c0d0p3		Controller 0, disk 0, partition 3
+
+/dev/ida/c1d1		Controller 1, disk 1, whole device
+/dev/ida/c1d1p1		Controller 1, disk 1, partition 1
+/dev/ida/c1d1p2		Controller 1, disk 1, partition 2
+/dev/ida/c1d1p3		Controller 1, disk 1, partition 3
diff -ruN linux-2.2.3/drivers/block/TODO.smart2 linux-2.2.3.smart2/drivers/block/TODO.smart2
--- linux-2.2.3/drivers/block/TODO.smart2	Wed Dec 31 19:00:00 1969
+++ linux-2.2.3.smart2/drivers/block/TODO.smart2	Sun Mar 21 23:40:28 1999
@@ -0,0 +1,20 @@
+Passthrough ioctl (needs testing)
+
+Missing #defines for error codes and bit definitions in arraycmd.h
+Missing structures for health and wellness stuff in arraycmd.h
+	
+Online Array config utility for userspace. 
+
+Array health monitor for userspace.  Perhaps add functionality to use
+the Event Notifier to send health events to a userspace daemon.
+
+Portability:  This driver probably doesn't work on Compaq's Alpha hardware.
+
+Performance, Performance, Performance:  There just have to be some bottlenecks
+in this driver.  I'd like to get some more profiling numbers on things, like
+how often we totally fill the controller's queue, how much stuff sits out on
+the completetion queue and timings on some critical sections of code (the
+intr. handler, the request function, cmd_alloc, etc).  The end result being
+that I'm absolutely positive that when the kernel has IO for me,  I am not
+letting the controller idle at all.
+
diff -ruN linux-2.2.3/drivers/block/cpqarray.c linux-2.2.3.smart2/drivers/block/cpqarray.c
--- linux-2.2.3/drivers/block/cpqarray.c	Wed Dec 31 19:00:00 1969
+++ linux-2.2.3.smart2/drivers/block/cpqarray.c	Sun Mar 21 23:40:28 1999
@@ -0,0 +1,1592 @@
+/*
+ *    Disk Array driver for Compaq SMART2 Controllers
+ *    Copyright 1998 Compaq Computer Corporation
+ *
+ *    This program is free software; you can redistribute it and/or modify
+ *    it under the terms of the GNU General Public License as published by
+ *    the Free Software Foundation; either version 2 of the License, or
+ *    (at your option) any later version.
+ *
+ *    This program is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, GOOD TITLE or
+ *    NON INFRINGEMENT.  See the GNU General Public License for more details.
+ *
+ *    You should have received a copy of the GNU General Public License
+ *    along with this program; if not, write to the Free Software
+ *    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ *    Questions/Comments/Bugfixes to arrays@compaq.com
+ *
+ *    If you want to make changes, improve or add functionality to this
+ *    driver, you'll probably need the Compaq Array Controller Interface
+ *    Specificiation (Document number ECG086/1198)
+ */
+#include <linux/config.h>
+#include <linux/types.h>
+#include <linux/pci.h>
+#include <linux/kernel.h>
+#include <linux/malloc.h>
+#include <linux/delay.h>
+#include <linux/major.h>
+#include <linux/fs.h>
+#include <linux/timer.h>
+#include <linux/proc_fs.h>
+#include <linux/hdreg.h>
+#include <asm/uaccess.h>
+#include <asm/spinlock.h>
+#include <asm/io.h>
+
+#ifdef MODULE
+#include <linux/module.h>
+#include <linux/version.h>
+#else
+#define MOD_INC_USE_COUNT
+#define MOD_DEC_USE_COUNT
+#endif
+
+#define DRIVER_NAME "Compaq SMART2 Driver (v 0.9.9)"
+#define MAJOR_NR COMPAQ_SMART2_MAJOR
+#include <linux/blk.h>
+#include <linux/blkdev.h>
+#include <linux/genhd.h>
+
+#include "cpqarray.h"
+#include "ida_cmd.h"
+#include "ida_ioctl.h"
+
+#define READ_AHEAD	128
+#define NR_CMDS		128 /* This could probably go as high as ~400 */
+
+#define MAX_CTLR	8
+#define CTLR_SHIFT	8
+
+static int nr_ctlr = 0;
+static ctlr_info_t *hba[MAX_CTLR] = { 0, 0, 0, 0, 0, 0, 0, 0 };
+
+#ifdef CONFIG_BLK_CPQ_DA_EISA
+#ifndef MODULE
+static
+#endif
+int eisa[16] = { 0, 0 ,0 ,0, 0, 0 ,0 ,0, 0, 0 ,0 ,0, 0, 0 ,0 ,0 };
+#endif
+
+char *product_names[] = {
+	"Unknown",
+	"SMART-2/E",
+	"SMART-2/P",  /* or SMART-2/DH */
+	"SMART-2SL",
+	"SMART-3200",
+	"SMART-3100ES",
+	"SMART-221",
+};
+
+static struct hd_struct * ida;
+static int * ida_sizes;
+static int * ida_blocksizes;
+static int * ida_hardsizes;
+static int * ida_maxsectors;
+static int * ida_maxsegments;
+static struct gendisk ida_gendisk[MAX_CTLR];
+
+struct proc_dir_entry *proc_array = NULL;
+
+/* Debug... */
+#define DBG(s)	s
+/* Debug (general info)... */
+#define DBGINFO(s)
+/* Debug Paranoid... */
+#define DBGP(s) 
+/* Debug Extra Paranoid... */
+#define DBGPX(s)
+
+void cpqarray_init(void);
+#ifdef CONFIG_BLK_CPQ_DA_PCI
+static int cpqarray_pci_detect(void);
+static void cpqarray_pci_init(ctlr_info_t *c, unchar bus, unchar device_fn);
+static ulong remap_pci_mem(ulong base, ulong size);
+#endif
+#ifdef CONFIG_BLK_CPQ_DA_EISA
+static int cpqarray_eisa_detect(void);
+#endif
+static void flushcomplete(int ctlr);
+static int pollcomplete(int ctlr);
+static void getgeometry(int ctlr);
+
+static cmdlist_t * cmd_alloc(ctlr_info_t *h);
+static void cmd_free(ctlr_info_t *h, cmdlist_t *c);
+
+static int sendcmd(
+	__u8	cmd,
+	int	ctlr,
+	void	*buff,
+	size_t	size,
+	unsigned int blk,
+	unsigned int blkcnt,
+	unsigned int log_unit );
+
+static int ida_open(struct inode *inode, struct file *filep);
+static int ida_release(struct inode *inode, struct file *filep);
+static int ida_ioctl(struct inode *inode, struct file *filep, unsigned int cmd, unsigned long arg);
+int ida_ctlr_ioctl(int ctlr, int dsk, ida_ioctl_t *io);
+
+static void do_ida_request(int i);
+/*
+ * This is a hack.  This driver eats a major number for each controller, and
+ * sets blkdev[xxx].request_fn to each one of these so the real request
+ * function knows what controller its working with.
+ */
+#define DO_IDA_REQUEST(x) { do_ida_request(x); }
+
+static void do_ida_request0(void) DO_IDA_REQUEST(0);
+static void do_ida_request1(void) DO_IDA_REQUEST(1);
+static void do_ida_request2(void) DO_IDA_REQUEST(2);
+static void do_ida_request3(void) DO_IDA_REQUEST(3);
+static void do_ida_request4(void) DO_IDA_REQUEST(4);
+static void do_ida_request5(void) DO_IDA_REQUEST(5);
+static void do_ida_request6(void) DO_IDA_REQUEST(6);
+static void do_ida_request7(void) DO_IDA_REQUEST(7);
+
+static void start_io(ctlr_info_t *h);
+
+static inline void addQ(cmdlist_t **Qptr, cmdlist_t *c);
+static inline cmdlist_t *removeQ(cmdlist_t **Qptr, cmdlist_t *c);
+static inline void complete_buffers(struct buffer_head *bh, int ok);
+static inline void complete_command(cmdlist_t *cmd, int timeout);
+
+static void do_ida_intr(int irq, void *dev_id, struct pt_regs * regs);
+static void ida_timer(unsigned long tdata);
+static int frevalidate_logvol(kdev_t dev);
+static int revalidate_logvol(kdev_t dev, int maxusage);
+static int revalidate_allvol(kdev_t dev);
+
+static void ida_procinit(int i);
+static int ida_proc_get_info(char *buffer, char **start, off_t offset, int length, int *eof, void *data);
+
+/*
+ * These macros control what happens when the driver tries to write to or
+ * read from a card.  If the driver is configured for EISA only or PCI only,
+ * the macros expand to inl/outl or readl/writel.  If the drive is configured
+ * for both EISA and PCI, the macro expands to a conditional which uses
+ * memory mapped IO if the card has it (PCI) or io ports if it doesn't (EISA).
+ */
+#ifdef CONFIG_BLK_CPQ_DA_PCI
+#	ifdef CONFIG_BLK_CPQ_DA_EISA
+#		define smart2_read(h, offset)  ( ((h)->vaddr) ? readl((h)->vaddr+(offset)) : inl((h)->ioaddr+(offset)) )
+#		define smart2_write(p, h, offset) ( ((h)->vaddr) ? writel((p), (h)->vaddr+(offset)) : outl((p), (h)->ioaddr+(offset)) )
+#	else
+#		define smart2_read(h, offset)  readl((h)->vaddr+(offset))
+#		define smart2_write(p, h, offset) writel((p), (h)->vaddr+(offset))
+#	endif
+#else
+#	ifdef CONFIG_BLK_CPQ_DA_EISA
+#		define smart2_read(h, offset)  inl((h)->ioaddr+(offset))
+#		define smart2_write(p, h, offset) outl((p), (h)->ioaddr+(offset))
+#	else
+#		error "You must enable either SMART2 PCI support or SMART2 EISA support or both!"
+#	endif
+#endif
+
+void ida_geninit(struct gendisk *g)
+{
+	int ctlr = g-ida_gendisk;
+	int i,j;
+	drv_info_t *drv;
+
+	for(i=0; i<NWD; i++) {
+		drv = &hba[ctlr]->drv[i];
+		if (!drv->nr_blks)
+			continue;
+		ida[(ctlr<<CTLR_SHIFT) + (i<<NWD_SHIFT)].nr_sects =
+		ida_sizes[(ctlr<<CTLR_SHIFT) + (i<<NWD_SHIFT)] =
+				drv->nr_blks;
+
+		for(j=0; j<16; j++) {
+			ida_blocksizes[(ctlr<<CTLR_SHIFT) + (i<<NWD_SHIFT)+j] =
+				1024;
+			ida_hardsizes[(ctlr<<CTLR_SHIFT) + (i<<NWD_SHIFT)+j] =
+				drv->blk_size;
+		}
+		ida_gendisk[ctlr].nr_real++;
+	}
+
+}
+
+struct file_operations ida_fops  = {
+	NULL,                        /* lseek - default */
+	block_read,                  /* read - general block-dev read */
+	block_write,                 /* write - general block-dev write */
+	NULL,                        /* readdir - bad */
+	NULL,                        /* select */
+	ida_ioctl,                  /* ioctl */
+	NULL,                        /* mmap */
+	ida_open,                     /* open code */
+	NULL,
+	ida_release,                  /* release */
+	block_fsync,	              /* fsync */
+	NULL,                        /* fasync */
+	NULL,			/* Disk change */
+	frevalidate_logvol,	/* revalidate */
+};
+
+
+/*
+ * Get us a file in /proc/array that says something about each controller.
+ * Create /proc/array if it doesn't exist yet.
+ */
+static void ida_procinit(int i)
+{
+	struct proc_dir_entry *pd;
+
+	if (proc_array == NULL) {
+		proc_array = create_proc_entry("array", S_IFDIR|S_IRUGO|S_IXUGO,
+								&proc_root);
+		if (!proc_array) return;
+	}
+
+	pd = create_proc_entry(hba[i]->devname, S_IFREG|S_IRUGO, proc_array);
+	if (!pd) return;
+	pd->read_proc = ida_proc_get_info;
+	pd->data = hba[i];
+}
+
+/*
+ * Report information about this controller.
+ */
+static int ida_proc_get_info(char *buffer, char **start, off_t offset, int length, int *eof, void *data)
+{
+	off_t pos = 0;
+	off_t len = 0;
+	int size, i, ctlr;
+	ctlr_info_t *h = (ctlr_info_t*)data;
+	drv_info_t *drv;
+#ifdef CPQ_PROC_PRINT_QUEUES
+	cmdlist_t *c;
+#endif
+
+	ctlr = h->ctlr;
+	size = sprintf(buffer, "%s:  Compaq %s Disk Array Controller\n"
+		"       Board ID: %08lx\n"
+		"       Firmware Revision: %c%c%c%c\n"
+		"       Controller Sig: %08lx\n"
+		"       Memory Address: %08lx\n"
+		"       I/O Port: %04x\n"
+		"       IRQ: %x\n"
+		"       Logical drives: %d\n"
+		"       Physical drives: %d\n\n"
+		"       Current Q depth: %d\n"
+		"       Max Q depth since init: %d\n\n",
+		h->devname, 
+		product_names[h->product],
+		(unsigned long)h->board_id,
+		h->firm_rev[0], h->firm_rev[1], h->firm_rev[2], h->firm_rev[3],
+		(unsigned long)h->ctlr_sig, (unsigned long)h->vaddr,
+		(unsigned int) h->ioaddr, (unsigned int)h->intr,
+		h->log_drives, h->phys_drives,
+		h->Qdepth, h->maxQsinceinit);
+
+	pos += size; len += size;
+	
+	size = sprintf(buffer+len, "Logical Drive Info:\n");
+	pos += size; len += size;
+
+	for(i=0; i<h->log_drives; i++) {
+		drv = &h->drv[i];
+		size = sprintf(buffer+len, "ida/c%dd%d: blksz=%d nr_blks=%d\n",
+				ctlr, i, drv->blk_size, drv->nr_blks);
+		pos += size; len += size;
+	}
+
+#ifdef CPQ_PROC_PRINT_QUEUES
+	size = sprintf(buffer+len, "\nCurrent Queues:\n");
+	pos += size; len += size;
+
+	c = h->reqQ;
+	size = sprintf(buffer+len, "reqQ = %p", c); pos += size; len += size;
+	if (c) c=c->next;
+	while(c && c != h->reqQ) {
+		size = sprintf(buffer+len, "->%p", c);
+		pos += size; len += size;
+		c=c->next;
+	}
+
+	c = h->cmpQ;
+	size = sprintf(buffer+len, "\ncmpQ = %p", c); pos += size; len += size;
+	if (c) c=c->next;
+	while(c && c != h->cmpQ) {
+		size = sprintf(buffer+len, "->%p", c);
+		pos += size; len += size;
+		c=c->next;
+	}
+
+	size = sprintf(buffer+len, "\n"); pos += size; len += size;
+#endif
+	size = sprintf(buffer+len, "nr_allocs = %d\nnr_frees = %d\n",
+			h->nr_allocs, h->nr_frees);
+	pos += size; len += size;
+
+	*eof = 1;
+	*start = buffer+offset;
+	len -= offset;
+	if (len>length)
+		len = length;
+	return len;
+}
+
+#ifdef MODULE
+/* This is a bit of a hack... */
+int init_module(void)
+{
+	int i, j;
+	cpqarray_init();
+	if (nr_ctlr == 0)
+		return -EIO;
+
+	for(i=0; i<nr_ctlr; i++) {
+		ida_geninit(&ida_gendisk[i]); 
+		for(j=0; j<NWD; j++)	
+			if (ida_sizes[(i<<CTLR_SHIFT) + (j<<NWD_SHIFT)])
+				resetup_one_dev(&ida_gendisk[i], j);
+	}
+	return 0;
+}
+void cleanup_module(void)
+{
+	int i;
+	struct gendisk *g;
+
+	for(i=0; i<nr_ctlr; i++) {
+		smart2_write(0, hba[i], INTR_MASK);
+		free_irq(hba[i]->intr, hba[i]);
+		iounmap((void*)hba[i]->vaddr);
+		unregister_blkdev(MAJOR_NR+i, hba[i]->devname);
+		del_timer(&hba[i]->timer);
+		remove_proc_entry(hba[i]->devname, proc_array);
+		kfree(hba[i]->cmd_pool);
+		kfree(hba[i]->cmd_pool_bits);
+
+		if (gendisk_head == &ida_gendisk[i]) {
+			gendisk_head = ida_gendisk[i].next;
+		} else {
+			for(g=gendisk_head; g; g=g->next) {
+				if (g->next == &ida_gendisk[i]) {
+					g->next = ida_gendisk[i].next;
+					break;
+				}
+			}
+		}
+	}
+	remove_proc_entry("array", &proc_root);
+	kfree(ida);
+	kfree(ida_sizes);
+	kfree(ida_hardsizes);
+	kfree(ida_blocksizes);
+
+	kfree(ida_maxsectors);
+	kfree(ida_maxsegments);
+
+}
+#endif /* MODULE */
+
+/*
+ *  This is it.  Find all the controllers and register them.  I really hate
+ *  stealing all these major device numbers.
+ */
+void cpqarray_init(void)
+{
+	void (*request_fns[MAX_CTLR])(void) = {
+		do_ida_request0, do_ida_request1,
+		do_ida_request2, do_ida_request3,
+		do_ida_request4, do_ida_request5,
+		do_ida_request6, do_ida_request7,
+	};
+	int i;
+
+	/* detect controllers */
+#ifdef CONFIG_BLK_CPQ_DA_PCI
+	cpqarray_pci_detect();
+#endif
+#ifdef CONFIG_BLK_CPQ_DA_EISA
+	cpqarray_eisa_detect();
+#endif
+	
+	if (nr_ctlr == 0)
+		return;
+
+	printk(DRIVER_NAME "\n");
+	printk("Found %d controller(s)\n", nr_ctlr);
+
+	/* allocate space for disk structs */
+	ida = kmalloc(sizeof(struct hd_struct)*nr_ctlr*NWD*16, GFP_KERNEL);
+	ida_sizes =      kmalloc(sizeof(int)*nr_ctlr*NWD*16, GFP_KERNEL);
+	ida_blocksizes = kmalloc(sizeof(int)*nr_ctlr*NWD*16, GFP_KERNEL);
+	ida_hardsizes =  kmalloc(sizeof(int)*nr_ctlr*NWD*16, GFP_KERNEL);
+
+	ida_maxsegments =  kmalloc(sizeof(int)*nr_ctlr*NWD*16, GFP_KERNEL);
+	ida_maxsectors =  kmalloc(sizeof(int)*nr_ctlr*NWD*16, GFP_KERNEL);
+
+	memset(ida, 0, sizeof(struct hd_struct)*nr_ctlr*NWD*16);
+	memset(ida_sizes, 0, sizeof(int)*nr_ctlr*NWD*16);
+	memset(ida_blocksizes, 0, sizeof(int)*nr_ctlr*NWD*16);
+	memset(ida_hardsizes, 0, sizeof(int)*nr_ctlr*NWD*16);
+	memset(ida_maxsegments, 0, sizeof(int)*nr_ctlr*NWD*16);
+	memset(ida_maxsectors, 0, sizeof(int)*nr_ctlr*NWD*16);
+	memset(ida_gendisk, 0, sizeof(struct gendisk)*MAX_CTLR);
+
+	for(i=0; i<nr_ctlr*NWD*16; i++) {
+		ida_maxsegments[i] = SG_MAX;
+		ida_maxsectors[i] = 1024;
+	}
+	/* 
+	 * register block devices
+	 * Find disks and fill in structs
+	 * Get an interrupt, set the Q depth and get into /proc
+	 */
+	for(i=0; i< nr_ctlr; i++) {
+		smart2_write(0, hba[i], INTR_MASK);
+		if (request_irq(hba[i]->intr, do_ida_intr,
+			SA_INTERRUPT|SA_SHIRQ, hba[i]->devname, hba[i])) {
+
+			printk("Unable to get irq %d for %s\n", 
+				hba[i]->intr, hba[i]->devname);
+			continue;
+		}
+		if (register_blkdev(MAJOR_NR+i, hba[i]->devname, &ida_fops)) {
+			printk("Unable to get major number %d for ida\n",
+				MAJOR_NR+i);
+			continue;
+		}
+
+		hba[i]->cmd_pool = (cmdlist_t *)kmalloc(
+				NR_CMDS * sizeof(cmdlist_t), GFP_KERNEL);
+		hba[i]->cmd_pool_bits = (__u32*)kmalloc(
+				((NR_CMDS+31)/32)*sizeof(__u32), GFP_KERNEL);
+		memset(hba[i]->cmd_pool, 0, NR_CMDS * sizeof(cmdlist_t));
+		memset(hba[i]->cmd_pool_bits, 0, ((NR_CMDS+31)/32)*sizeof(__u32));
+
+		printk("Finding drives on %s", hba[i]->devname);
+		getgeometry(i);
+
+		smart2_write(FIFO_NOT_EMPTY, hba[i], INTR_MASK);
+
+		ida_procinit(i);
+		ida_gendisk[i].major = MAJOR_NR + i;
+		ida_gendisk[i].major_name = "ida";
+		ida_gendisk[i].minor_shift = NWD_SHIFT;
+		ida_gendisk[i].max_p = 16;
+		ida_gendisk[i].max_nr = 16;
+		ida_gendisk[i].init = ida_geninit;
+		ida_gendisk[i].part = ida + (i*256);
+		ida_gendisk[i].sizes = ida_sizes + (i*256);
+		/* ida_gendisk[i].nr_real is handled by getgeometry */
+	
+		blk_dev[MAJOR_NR+i].request_fn = request_fns[i];
+		blksize_size[MAJOR_NR+i] = ida_blocksizes + (i*256);
+		hardsect_size[MAJOR_NR+i] = ida_hardsizes + (i*256);
+		read_ahead[MAJOR_NR+i] = READ_AHEAD;
+		max_sectors[MAJOR_NR+i] = ida_maxsectors + (i*256);
+		max_segments[MAJOR_NR+i] = ida_maxsegments + (i*256);
+
+		/* Get on the disk list */
+		ida_gendisk[i].next = gendisk_head;
+		gendisk_head = &ida_gendisk[i];
+
+		init_timer(&hba[i]->timer);
+		hba[i]->timer.expires = jiffies + IDA_TIMER;
+		hba[i]->timer.data = (unsigned long)hba[i];
+		hba[i]->timer.function = ida_timer;
+		add_timer(&hba[i]->timer);
+
+	}
+	/* done ! */
+}
+
+#ifdef CONFIG_BLK_CPQ_DA_PCI
+/*
+ * Find the controller and initialize it
+ */
+static int cpqarray_pci_detect(void)
+{
+	int index;
+	unchar bus=0, dev_fn=0;
+	
+	for(index=0; ; index++) {
+		if (pcibios_find_device(PCI_VENDOR_ID_COMPAQ,
+			PCI_DEVICE_ID_COMPAQ_SMART2P, index, &bus, &dev_fn))
+			break;
+
+		if (index == 1000000) break;
+		if (nr_ctlr == 8) {
+			printk("This driver supports a maximum of "
+				"8 controllers.\n");
+			break;
+		}
+		
+		hba[nr_ctlr] = kmalloc(sizeof(ctlr_info_t), GFP_KERNEL);
+		memset(hba[nr_ctlr], 0, sizeof(ctlr_info_t));
+		cpqarray_pci_init(hba[nr_ctlr], bus, dev_fn);
+		sprintf(hba[nr_ctlr]->devname, "ida%d", nr_ctlr);
+		hba[nr_ctlr]->ctlr = nr_ctlr;
+		nr_ctlr++;
+	}
+
+	return nr_ctlr;
+}
+/*
+ * Find the IO address of the controller, its IRQ and so forth.  Fill
+ * in some basic stuff into the ctlr_info_t structure.
+ */
+static void cpqarray_pci_init(ctlr_info_t *c, unchar bus, unchar device_fn)
+{
+	ushort vendor_id, device_id, command;
+	unchar cache_line_size, latency_timer;
+	unchar irq, revision;
+	uint addr[6];
+
+	int i;
+
+	(void) pcibios_read_config_word(bus, device_fn,
+					PCI_VENDOR_ID, &vendor_id);
+	(void) pcibios_read_config_word(bus, device_fn,
+					PCI_DEVICE_ID, &device_id);
+	(void) pcibios_read_config_word(bus, device_fn,
+					PCI_COMMAND, &command);
+	for(i=0; i<6; i++)
+		(void) pcibios_read_config_dword(bus, device_fn,
+				PCI_BASE_ADDRESS_0 + i*4, addr+i);
+
+	(void) pcibios_read_config_byte(bus, device_fn,
+					PCI_CLASS_REVISION,&revision);
+	(void) pcibios_read_config_byte(bus, device_fn,
+					PCI_INTERRUPT_LINE, &irq);
+	(void) pcibios_read_config_byte(bus, device_fn,
+					PCI_CACHE_LINE_SIZE, &cache_line_size);
+	(void) pcibios_read_config_byte(bus, device_fn,
+					PCI_LATENCY_TIMER, &latency_timer);
+
+DBGINFO(
+	printk("vendor_id = %x\n", vendor_id);
+	printk("device_id = %x\n", device_id);
+	printk("command = %x\n", command);
+	for(i=0; i<6; i++)
+		printk("addr[%d] = %x\n", i, addr[i]);
+	printk("revision = %x\n", revision);
+	printk("irq = %x\n", irq);
+	printk("cache_line_size = %x\n", cache_line_size);
+	printk("latency_timer = %x\n", latency_timer);
+);
+
+	c->intr = irq;
+	c->ioaddr = addr[0] & ~0x1;
+
+	/*
+	 * Memory base addr is first addr with the first bit _not_ set
+	 */
+	for(i=0; i<6; i++)
+		if (!(addr[i] & 0x1)) {
+			c->paddr = addr[i];
+			break;
+		}
+	c->vaddr = remap_pci_mem(c->paddr, 128);
+}
+
+/*
+ * Map (physical) PCI mem into (virtual) kernel space
+ */
+static ulong remap_pci_mem(ulong base, ulong size)
+{
+        ulong page_base        = ((ulong) base) & PAGE_MASK;
+        ulong page_offs        = ((ulong) base) - page_base;
+        ulong page_remapped    = (ulong) ioremap(page_base, page_offs+size);
+
+        return (ulong) (page_remapped ? (page_remapped + page_offs) : 0UL);
+}
+#endif /* CONFIG_BLK_CPQ_DA_PCI */
+
+#ifdef CONFIG_BLK_CPQ_DA_EISA
+/*
+ * Copy the contents of the ints[] array passed to us by init.
+ */
+void cpqarray_setup(char *str, int *ints)
+{
+	int i;
+	if (ints[0] & 1) {
+		printk("SMART2 Parameter Usage:\n"
+			"     smart2=io,irq,io,irq,...\n");
+		return;
+	}
+
+	for(i=0; i<ints[0]; i++)
+		eisa[i] = ints[i+1];
+
+}
+
+/*
+ * Find an EISA controller's signature.  Set up an hba if we find it.
+ */
+static int cpqarray_eisa_detect(void)
+{
+	int i=0;
+
+	while(i<16 && eisa[i]) {
+		if (inl(eisa[i]+0xC80) == 0x3040110e) {
+			if (nr_ctlr == 8) {
+				printk("This driver supports a maximum of "
+					"8 controllers.\n");
+				break;
+			}
+			hba[nr_ctlr] = kmalloc(sizeof(ctlr_info_t), GFP_KERNEL);
+			memset(hba[nr_ctlr], 0, sizeof(ctlr_info_t));
+			hba[nr_ctlr]->ioaddr = eisa[i];
+			hba[nr_ctlr]->intr = eisa[i+1];
+			sprintf(hba[nr_ctlr]->devname, "ida%d", nr_ctlr);
+			hba[nr_ctlr]->ctlr = nr_ctlr;
+			nr_ctlr++;
+		} else {
+			printk("SMART2:  Could not find a controller at io=0x%04x irq=0x%x\n", eisa[i], eisa[i+1]);
+		}
+		i+=2;
+	}
+	return nr_ctlr;
+}
+#endif /* CONFIG_BLK_CPQ_DA_EISA */
+
+
+/*
+ * Open.  Make sure the device is really there.
+ */
+static int ida_open(struct inode *inode, struct file *filep)
+{
+	int ctlr = MAJOR(inode->i_rdev) - MAJOR_NR;
+	int dsk  = MINOR(inode->i_rdev) >> NWD_SHIFT;
+
+	DBGINFO(printk("ida_open %x (%x:%x)\n", inode->i_rdev, ctlr, dsk) );
+	if (ctlr > MAX_CTLR || hba[ctlr] == NULL)
+		return -ENXIO;
+
+	if (!suser() && ida_sizes[(ctlr << CTLR_SHIFT) +
+						MINOR(inode->i_rdev)] == 0)
+		return -ENXIO;
+
+	/*
+	 * Root is allowed to open raw volume zero even if its not configured
+	 * so array config can still work.  I don't think I really like this,
+	 * but I'm already using way to many device nodes to claim another one
+	 * for "raw controller".
+	 */
+	if (suser()
+		&& ida_sizes[(ctlr << CTLR_SHIFT) + MINOR(inode->i_rdev)] == 0 
+		&& MINOR(inode->i_rdev) != 0)
+		return -ENXIO;
+
+	hba[ctlr]->drv[dsk].usage_count++;
+	hba[ctlr]->usage_count++;
+	MOD_INC_USE_COUNT;
+	return 0;
+}
+
+/*
+ * Close.  Sync first.
+ */
+static int ida_release(struct inode *inode, struct file *filep)
+{
+	int ctlr = MAJOR(inode->i_rdev) - MAJOR_NR;
+	int dsk  = MINOR(inode->i_rdev) >> NWD_SHIFT;
+
+	DBGINFO(printk("ida_release %x (%x:%x)\n", inode->i_rdev, ctlr, dsk) );
+	fsync_dev(inode->i_rdev);
+
+	hba[ctlr]->drv[dsk].usage_count--;
+	hba[ctlr]->usage_count--;
+	MOD_DEC_USE_COUNT;
+	return 0;
+}
+
+/*
+ * Enqueuing and dequeuing functions for cmdlists.
+ */
+static inline void addQ(cmdlist_t **Qptr, cmdlist_t *c)
+{
+	if (*Qptr == NULL) {
+		*Qptr = c;
+		c->next = c->prev = c;
+	} else {
+		c->prev = (*Qptr)->prev;
+		c->next = (*Qptr);
+		(*Qptr)->prev->next = c;
+		(*Qptr)->prev = c;
+	}
+}
+
+static inline cmdlist_t *removeQ(cmdlist_t **Qptr, cmdlist_t *c)
+{
+	if (c && c->next != c) {
+		if (*Qptr == c) *Qptr = c->next;
+		c->prev->next = c->next;
+		c->next->prev = c->prev;
+	} else {
+		*Qptr = NULL;
+	}
+	return c;
+}
+
+/*
+ * Get a request and submit it to the controller.
+ * This routine needs to grab all the requests it possibly can from the
+ * req Q and submit them.  Interrupts are off (and need to be off) when you
+ * are in here (either via the dummy do_ida_request functions or by being
+ * called from the interrupt handler
+ */
+void do_ida_request(int ctlr)
+{
+	ctlr_info_t *h = hba[ctlr];
+	cmdlist_t *c;
+	int seg;
+	char *lastdataend;
+	struct buffer_head *bh;
+	struct request *creq;
+
+	creq = blk_dev[MAJOR_NR+ctlr].current_request;
+	if (creq == NULL || creq->rq_status == RQ_INACTIVE)
+		goto doreq_done;
+
+	if (ctlr != MAJOR(creq->rq_dev)-MAJOR_NR ||
+		ctlr > nr_ctlr || h == NULL) {
+		printk("doreq cmd for %d, %x at %p\n",
+				ctlr, creq->rq_dev, creq);
+		complete_buffers(creq->bh, 0);
+		goto doreq_done;
+	}
+
+	if ((c = cmd_alloc(h)) == NULL)
+		goto doreq_done;
+
+	blk_dev[MAJOR_NR+ctlr].current_request = creq->next;
+	creq->rq_status = RQ_INACTIVE;
+
+	bh = creq->bh;
+
+	c->ctlr = ctlr;
+	c->hdr.unit = MINOR(creq->rq_dev) >> NWD_SHIFT;
+	c->hdr.size = sizeof(rblk_t) >> 2;
+	c->size += sizeof(rblk_t);
+
+	c->req.hdr.sg_cnt = creq->nr_segments;
+	c->req.hdr.blk = ida[(ctlr<<CTLR_SHIFT) + MINOR(creq->rq_dev)].start_sect + creq->sector;
+	c->req.hdr.blk_cnt = creq->nr_sectors;
+	c->bh = bh;
+	
+	seg = 0; lastdataend = NULL;
+	while(bh) {
+		if (bh->b_data == lastdataend) {
+			c->req.sg[seg-1].size += bh->b_size;
+			lastdataend += bh->b_size;
+		} else {
+			c->req.sg[seg].size = bh->b_size;
+			c->req.sg[seg].addr = (__u32) virt_to_bus(bh->b_data);
+			lastdataend = bh->b_data + bh->b_size;
+			if (seg++ > SG_MAX)
+				panic("SG list overflow\n");
+		}
+		bh = bh->b_reqnext;
+	}
+	if (seg != creq->nr_segments)
+		panic("seg != nr_segments\n");
+
+	c->req.hdr.cmd = (creq->cmd == READ) ? IDA_READ : IDA_WRITE;
+	c->type = CMD_RWREQ;
+
+	/* Put the request on the tail of the request queue */
+	addQ(&h->reqQ, c);
+	h->Qdepth++;
+	if (h->Qdepth > h->maxQsinceinit) h->maxQsinceinit = h->Qdepth;
+	wake_up(&wait_for_request);
+
+doreq_done:
+	start_io(h);
+}
+
+/* 
+ * start_io submits everything on a controller's request queue
+ * and moves it to the completion queue.
+ *
+ * Interrupts had better be off if you're in here
+ */
+void start_io(ctlr_info_t *h)
+{
+	cmdlist_t *c;
+
+	while((c = h->reqQ) != NULL) {
+		/* Can't do anything if we're busy */
+		if (smart2_read(h, COMMAND_FIFO) == 0)
+			return;
+
+		/* Get the first entry from the request Q */
+		removeQ(&h->reqQ, c);
+		h->Qdepth--;
+	
+		/* Tell the controller to do our bidding */
+		smart2_write(c->busaddr, h, COMMAND_FIFO);
+
+		/* Get onto the completion Q */
+		addQ(&h->cmpQ, c);
+	}
+}
+
+static inline void complete_buffers(struct buffer_head *bh, int ok)
+{
+	struct buffer_head *xbh;
+	while(bh) {
+		xbh = bh->b_reqnext;
+		bh->b_reqnext = NULL;
+		
+		bh->b_end_io(bh, ok);
+
+		bh = xbh;
+	}
+}
+/*
+ * Mark all buffers that cmd was responsible for
+ */
+static inline void complete_command(cmdlist_t *cmd, int timeout)
+{
+	char buf[80];
+	int ok=1;
+
+	if (cmd->req.hdr.rcode & RCODE_NONFATAL &&
+	   (hba[cmd->ctlr]->misc_tflags & MISC_NONFATAL_WARN) == 0) {
+		sprintf(buf, "Non Fatal error on ida/c%dd%d\n",
+				cmd->ctlr, cmd->hdr.unit);
+		console_print(buf);
+		hba[cmd->ctlr]->misc_tflags |= MISC_NONFATAL_WARN;
+	}
+	if (cmd->req.hdr.rcode & RCODE_FATAL) {
+		sprintf(buf, "Fatal error on ida/c%dd%d\n",
+				cmd->ctlr, cmd->hdr.unit);
+		console_print(buf);
+		ok = 0;
+	}
+	if (cmd->req.hdr.rcode & RCODE_INVREQ) {
+				sprintf(buf, "Invalid request on ida/c%dd%d = (cmd=%x sect=%d cnt=%d sg=%d ret=%x)\n",
+				cmd->ctlr, cmd->hdr.unit, cmd->req.hdr.cmd,
+				cmd->req.hdr.blk, cmd->req.hdr.blk_cnt,
+				cmd->req.hdr.sg_cnt, cmd->req.hdr.rcode);
+		console_print(buf);
+		ok = 0;	
+	}
+	if (timeout) ok = 0;
+	complete_buffers(cmd->bh, ok);
+}
+
+/*
+ *  The controller will interrupt us upon completion of commands.
+ *  Find the command on the completion queue, remove it, tell the OS and
+ *  try to queue up more IO
+ */
+void do_ida_intr(int irq, void *dev_id, struct pt_regs *regs)
+{
+	ctlr_info_t *h = dev_id;
+	cmdlist_t *c;
+	unsigned long istat;
+	unsigned long flags;
+	__u32 a,a1;
+
+
+	istat = smart2_read(h, INTR_PENDING);
+	/* Is this interrupt for us? */
+	if (istat == 0)
+		return;
+
+	/*
+	 * If there are completed commands in the completion queue,
+	 * we had better do something about it.
+	 */
+	spin_lock_irqsave(&io_request_lock, flags);
+	if (istat & FIFO_NOT_EMPTY) {
+		while((a = smart2_read(h, COMMAND_COMPLETE_FIFO))) {
+			a1 = a; a &= ~3;
+			if ((c = h->cmpQ) == NULL) goto bad_completion;
+			while(c->busaddr != a) {
+				c = c->next;
+				if (c == h->cmpQ) break;
+			}
+			/*
+			 * If we've found the command, take it off the
+			 * completion Q and free it
+			 */
+			if (c->busaddr == a) {
+				removeQ(&h->cmpQ, c);
+				if (c->type == CMD_RWREQ) {
+					complete_command(c, 0);
+					cmd_free(h, c);
+				} else if (c->type == CMD_IOCTL_PEND) {
+					c->type = CMD_IOCTL_DONE;
+				}
+				continue;
+			}
+bad_completion:
+			printk("Completion of %08lx ignored\n", (unsigned long)a1);
+		}
+	}
+
+	/*
+	 * See if we can queue up some more IO
+	 */
+	do_ida_request(h->ctlr);
+	spin_unlock_irqrestore(&io_request_lock, flags);
+}
+
+/*
+ * This timer was for timing out requests that haven't happened after
+ * IDA_TIMEOUT.  That wasn't such a good idea.  This timer is used to
+ * reset a flags structure so we don't flood the user with
+ * "Non-Fatal error" messages.
+ */
+static void ida_timer(unsigned long tdata)
+{
+	ctlr_info_t *h = (ctlr_info_t*)tdata;
+
+	h->timer.expires = jiffies + IDA_TIMER;
+	add_timer(&h->timer);
+	h->misc_tflags = 0;
+}
+
+/*
+ *  ida_ioctl does some miscellaneous stuff like reporting drive geometry,
+ *  setting readahead and submitting commands from userspace to the controller.
+ */
+int ida_ioctl(struct inode *inode, struct file *filep, unsigned int cmd, unsigned long arg)
+{
+	int ctlr = MAJOR(inode->i_rdev) - MAJOR_NR;
+	int dsk  = MINOR(inode->i_rdev) >> NWD_SHIFT;
+	int error;
+	int diskinfo[4];
+	struct hd_geometry *geo = (struct hd_geometry *)arg;
+	ida_ioctl_t *io = (ida_ioctl_t*)arg;
+	ida_ioctl_t my_io;
+
+	switch(cmd) {
+	case HDIO_GETGEO:
+		if (hba[ctlr]->drv[dsk].cylinders) {
+			diskinfo[0] = hba[ctlr]->drv[dsk].heads;
+			diskinfo[1] = hba[ctlr]->drv[dsk].sectors;
+			diskinfo[2] = hba[ctlr]->drv[dsk].cylinders;
+		} else {
+			diskinfo[0] = 0xff;
+			diskinfo[1] = 0x3f;
+			diskinfo[2] = hba[ctlr]->drv[dsk].nr_blks / (0xff*0x3f);
+		}
+		put_user(diskinfo[0], &geo->heads);
+		put_user(diskinfo[1], &geo->sectors);
+		put_user(diskinfo[2], &geo->cylinders);
+		put_user(ida[(ctlr<<CTLR_SHIFT)+MINOR(inode->i_rdev)].start_sect, &geo->start);
+		return 0;
+	case IDAGETDRVINFO:
+		return copy_to_user(&io->c.drv,&hba[ctlr]->drv[dsk],sizeof(drv_info_t));
+	case BLKGETSIZE:
+		if (!arg) return -EINVAL;
+		put_user(ida[(ctlr<<CTLR_SHIFT)+MINOR(inode->i_rdev)].nr_sects, (long*)arg);
+		return 0;
+	case BLKRASET:
+		if (!suser()) return -EACCES;
+		if (!(inode->i_rdev)) return -EINVAL;
+		if (arg>0xff) return -EINVAL;
+		read_ahead[MAJOR(inode->i_rdev)] = arg;
+		return 0;
+	case BLKRAGET:
+		if (!arg) return -EINVAL;
+		put_user(read_ahead[MAJOR(inode->i_rdev)], (int*)arg);
+		return 0;
+	case BLKRRPART:
+		return revalidate_logvol(inode->i_rdev, 1);
+	case IDAPASSTHRU:
+		if (!suser()) return -EPERM;
+		error = copy_from_user(&my_io, io, sizeof(my_io));
+		if (error) return error;
+		error = ida_ctlr_ioctl(ctlr, dsk, &my_io);
+		if (error) return error;
+		error = copy_to_user(io, &my_io, sizeof(my_io));
+		return error;
+	case IDAGETCTLRSIG:
+		if (!arg) return -EINVAL;
+		put_user(hba[ctlr]->ctlr_sig, (int*)arg);
+		return 0;
+	case IDAREVALIDATEVOLS:
+		return revalidate_allvol(inode->i_rdev);
+
+	RO_IOCTLS(inode->i_rdev, arg);
+
+	default:
+		return -EBADRQC;
+	}
+		
+}
+/*
+ * ida_ctlr_ioctl is for passing commands to the controller from userspace.
+ * The command block (io) has already been copied to kernel space for us,
+ * however, any elements in the sglist need to be copied to kernel space
+ * or copied back to userspace.
+ *
+ * Only root may perform a controller passthru command, however I'm not doing
+ * any serious sanity checking on the arguments.  Doing an IDA_WRITE_MEDIA and
+ * putting a 64M buffer in the sglist is probably a *bad* idea.
+ */
+int ida_ctlr_ioctl(int ctlr, int dsk, ida_ioctl_t *io)
+{
+	ctlr_info_t *h = hba[ctlr];
+	cmdlist_t *c;
+	void *p = NULL;
+	unsigned long flags;
+	int error;
+
+	if ((c = cmd_alloc(NULL)) == NULL)
+		return -ENOMEM;
+	c->ctlr = ctlr;
+	c->hdr.unit = (io->unit & UNITVALID) ? (io->unit & ~UNITVALID) : dsk;
+	c->hdr.size = sizeof(rblk_t) >> 2;
+	c->size += sizeof(rblk_t);
+
+	c->req.hdr.cmd = io->cmd;
+	c->type = CMD_IOCTL_PEND;
+
+	/* Pre submit processing */
+	switch(io->cmd) {
+	case PASSTHRU_A:
+		p = kmalloc(io->sg[0].size, GFP_KERNEL);
+		if (!p) { error = -ENOMEM; goto ioctl_err_exit; }
+		copy_from_user(p, (void*)io->sg[0].addr, io->sg[0].size);
+		c->req.bp = virt_to_bus(&(io->c));
+		c->req.sg[0].size = io->sg[0].size;
+		c->req.sg[0].addr = virt_to_bus(p);
+		c->req.hdr.sg_cnt = 1;
+		break;
+	case IDA_READ:
+		p = kmalloc(io->sg[0].size, GFP_KERNEL);
+		if (!p) { error = -ENOMEM; goto ioctl_err_exit; }
+		c->req.sg[0].size = io->sg[0].size;
+		c->req.sg[0].addr = virt_to_bus(p);
+		c->req.hdr.sg_cnt = 1;
+		break;
+	case IDA_WRITE:
+	case IDA_WRITE_MEDIA:
+	case DIAG_PASS_THRU:
+		p = kmalloc(io->sg[0].size, GFP_KERNEL);
+		if (!p) { error = -ENOMEM; goto ioctl_err_exit; }
+		copy_from_user(p, (void*)io->sg[0].addr, io->sg[0].size);
+		c->req.sg[0].size = io->sg[0].size;
+		c->req.sg[0].addr = virt_to_bus(p);
+		c->req.hdr.sg_cnt = 1;
+		break;
+	default:
+		c->req.sg[0].size = sizeof(io->c);
+		c->req.sg[0].addr = virt_to_bus(&io->c);
+		c->req.hdr.sg_cnt = 1;
+	}
+
+	/* Put the request on the tail of the request queue */
+	spin_lock_irqsave(&io_request_lock, flags);
+	addQ(&h->reqQ, c);
+	h->Qdepth++;
+	start_io(h);
+	spin_unlock_irqrestore(&io_request_lock, flags);
+
+	/* Wait for completion */
+	while(c->type != CMD_IOCTL_DONE)
+		schedule();
+
+	/* Post submit processing */
+	switch(io->cmd) {
+	case PASSTHRU_A:
+	case IDA_READ:
+	case DIAG_PASS_THRU:
+		copy_to_user((void*)io->sg[0].addr, p, io->sg[0].size);
+		/* fall through and free p */
+	case IDA_WRITE:
+	case IDA_WRITE_MEDIA:
+		kfree(p);
+		break;
+	default:
+		/* Nothing to do */
+	}
+
+	io->rcode = c->req.hdr.rcode;
+	error = 0;
+ioctl_err_exit:
+	cmd_free(NULL, c);
+	return error;
+}
+
+/*
+ * Commands are pre-allocated in a large block.  Here we use a simple bitmap
+ * scheme to suballocte them to the driver.  Operations that are not time
+ * critical (and can wait for kmalloc and possibly sleep) can pass in NULL
+ * as the first argument to get a new command.
+ */
+cmdlist_t * cmd_alloc(ctlr_info_t *h)
+{
+	cmdlist_t * c;
+	int i;
+
+	if (h == NULL) {
+		c = (cmdlist_t*)kmalloc(sizeof(cmdlist_t), GFP_KERNEL);
+	} else {
+		do {
+			i = find_first_zero_bit(h->cmd_pool_bits, NR_CMDS);
+			if (i == NR_CMDS)
+				return NULL;
+		} while(test_and_set_bit(i%32, h->cmd_pool_bits+(i/32)) != 0);
+		c = h->cmd_pool + i;
+		h->nr_allocs++;
+	}
+
+	memset(c, 0, sizeof(cmdlist_t));
+	c->busaddr = virt_to_bus(c);
+	return c;
+}
+
+void cmd_free(ctlr_info_t *h, cmdlist_t *c)
+{
+	int i;
+
+	if (h == NULL) {
+		kfree(c);
+	} else {
+		i = c - h->cmd_pool;
+		clear_bit(i%32, h->cmd_pool_bits+(i/32));
+		h->nr_frees++;
+	}
+}
+
+/***********************************************************************
+    name:        sendcmd
+    Send a command to an IDA using the memory mapped FIFO interface
+    and wait for it to complete.  
+    This routine should only be called at init time.
+***********************************************************************/
+int sendcmd(
+	__u8	cmd,
+	int	ctlr,
+	void	*buff,
+	size_t	size,
+	unsigned int blk,
+	unsigned int blkcnt,
+	unsigned int log_unit )
+{
+	cmdlist_t *c;
+	int complete;
+	unsigned long temp;
+	unsigned long i;
+	ctlr_info_t *info_p = hba[ctlr];
+
+	c = cmd_alloc(info_p);
+	c->ctlr = ctlr;
+	c->hdr.unit = log_unit;
+	c->hdr.prio = 0;
+	c->hdr.size = sizeof(rblk_t) >> 2;
+	c->size += sizeof(rblk_t);
+
+	/* The request information. */
+	c->req.hdr.next = 0;
+	c->req.hdr.rcode = 0;
+	c->req.bp = 0;
+	c->req.hdr.sg_cnt = 1;
+	c->req.hdr.reserved = 0;
+	
+	if (size == 0)
+		c->req.sg[0].size = 512;
+	else
+		c->req.sg[0].size = size;
+
+	c->req.hdr.blk = blk;
+	c->req.hdr.blk_cnt = blkcnt;
+	c->req.hdr.cmd = (unsigned char) cmd;
+	c->req.sg[0].addr = (__u32) virt_to_bus(buff);
+	flushcomplete(ctlr);
+	/*
+	 * Disable interrupt
+	 */
+	smart2_write(0, info_p, INTR_MASK);
+	/* Make sure there is room in the command FIFO */
+	/* Actually it should be completely empty at this time. */
+	for (i = 200000; i > 0; i--) {
+		temp = smart2_read(info_p, COMMAND_FIFO);
+		if (temp != 0) {
+			break;
+		}
+		udelay(10);
+DBG(
+		printk("ida%d: idaSendPciCmd FIFO full, waiting!\n",
+		       ctlr);
+);
+	}
+	/*
+	 * Send the cmd
+	 */
+	smart2_write(c->busaddr, info_p, COMMAND_FIFO);
+	complete = pollcomplete(ctlr);
+	if (complete != 1) {
+		if (complete != c->busaddr) {
+			printk(
+			"ida%d: idaSendPciCmd "
+		      "Invalid command list address returned! (%08lx)\n",
+				ctlr, (unsigned long)complete);
+			cmd_free(info_p, c);
+			return (IO_ERROR);
+		}
+	} else {
+		printk(
+			"ida%d: idaSendPciCmd Timeout out, "
+			"No command list address returned!\n",
+			ctlr);
+		cmd_free(info_p, c);
+		return (IO_ERROR);
+	}
+
+	if (c->req.hdr.rcode & 0x00FE) {
+		if (!(c->req.hdr.rcode & BIG_PROBLEM)) {
+			printk(
+			"ida%d: idaSendPciCmd, error: Controller failed "
+				"at init time "
+				"cmd: 0x%x, return code = 0x%x\n",
+				ctlr, c->req.hdr.cmd, c->req.hdr.rcode);
+
+			cmd_free(info_p, c);
+			return (IO_ERROR);
+		}
+	}
+	cmd_free(info_p, c);
+	return (IO_OK);
+}
+
+int frevalidate_logvol(kdev_t dev)
+{
+	return revalidate_logvol(dev, 0);
+}
+
+/*
+ * revalidate_allvol is for online array config utilities.  After a
+ * utility reconfigures the drives in the array, it can use this function
+ * (through an ioctl) to make the driver zap any previous disk structs for
+ * that controller and get new ones.
+ *
+ * Right now I'm using the getgeometry() function to do this, but this
+ * function should probably be finer grained and allow you to revalidate one
+ * particualar logical volume (instead of all of them on a particular
+ * controller).
+ */
+static int revalidate_allvol(kdev_t dev)
+{
+	int ctlr, i;
+	unsigned long flags;
+
+	ctlr = MAJOR(dev) - MAJOR_NR;
+	if (MINOR(dev) != 0)
+		return -ENXIO;
+
+	spin_lock_irqsave(&io_request_lock, flags);
+	if (hba[ctlr]->usage_count > 1) {
+		spin_unlock_irqrestore(&io_request_lock, flags);
+		printk("Device busy for volume revalidation (usage=%d)\n",
+					hba[ctlr]->usage_count);
+		return -EBUSY;
+	}
+	spin_unlock_irqrestore(&io_request_lock, flags);
+	hba[ctlr]->usage_count++;
+
+	/*
+	 * Set the partition and block size structures for all volumes
+	 * on this controller to zero.  We will reread all of this data
+	 */
+	memset(ida+(ctlr*256),            0, sizeof(struct hd_struct)*NWD*16);
+	memset(ida_sizes+(ctlr*256),      0, sizeof(int)*NWD*16);
+	memset(ida_blocksizes+(ctlr*256), 0, sizeof(int)*NWD*16);
+	memset(ida_hardsizes+(ctlr*256),  0, sizeof(int)*NWD*16);
+	memset(hba[ctlr]->drv,            0, sizeof(drv_info_t)*NWD);
+	ida_gendisk[ctlr].nr_real = 0;
+
+	/*
+	 * Tell the array controller not to give us any interupts while
+	 * we check the new geometry.  Then turn interrupts back on when
+	 * we're done.
+	 */
+	smart2_write(0, hba[ctlr], INTR_MASK);
+	getgeometry(ctlr);
+	smart2_write(FIFO_NOT_EMPTY, hba[ctlr], INTR_MASK);
+
+	ida_geninit(&ida_gendisk[ctlr]);
+	for(i=0; i<NWD; i++)
+		if (ida_sizes[(ctlr<<CTLR_SHIFT) + (i<<NWD_SHIFT)])
+			revalidate_logvol(dev+(i<<NWD_SHIFT), 2);
+
+	hba[ctlr]->usage_count--;
+	return 0;
+}
+
+/* Borrowed and adapted from sd.c */
+int revalidate_logvol(kdev_t dev, int maxusage)
+{
+	int ctlr, target;
+	struct gendisk *gdev;
+	unsigned long flags;
+	int max_p;
+	int start;
+	int i;
+
+	target = DEVICE_NR(dev);
+	ctlr = MAJOR(dev) - MAJOR_NR;
+	gdev = &ida_gendisk[ctlr];
+	
+	spin_lock_irqsave(&io_request_lock, flags);
+	if (hba[ctlr]->drv[target].usage_count > maxusage) {
+		spin_unlock_irqrestore(&io_request_lock, flags);
+		printk("Device busy for revalidation (usage=%d)\n",
+					hba[ctlr]->drv[target].usage_count);
+		return -EBUSY;
+	}
+
+	hba[ctlr]->drv[target].usage_count++;
+	spin_unlock_irqrestore(&io_request_lock, flags);
+
+	max_p = gdev->max_p;
+	start = target << gdev->minor_shift;
+
+	for(i=max_p; i>=0; i--) {
+		int minor = start+i;
+		kdev_t devi = MKDEV(MAJOR_NR + ctlr, minor);
+		struct super_block *sb = get_super(devi);
+		sync_dev(devi);
+		if (sb) invalidate_inodes(sb);
+		invalidate_buffers(devi);
+		gdev->part[minor].start_sect = 0;	
+		gdev->part[minor].nr_sects = 0;	
+
+		/* reset the blocksize so we can read the partition table */
+		blksize_size[MAJOR_NR+ctlr][minor] = 1024;
+	}
+
+	gdev->part[start].nr_sects =  hba[ctlr]->drv[target].nr_blks;
+	resetup_one_dev(gdev, target);
+	hba[ctlr]->drv[target].usage_count--;
+	return 0;
+}
+
+
+/********************************************************************
+    name: pollcomplete
+    Wait polling for a command to complete.
+    The memory mapped FIFO is polled for the completion.
+    Used only at init time, interrupts disabled.
+ ********************************************************************/
+int pollcomplete(int ctlr)
+{
+	int done;
+	int i;
+
+	/* Wait (up to 2 seconds) for a command to complete */
+
+	for (i = 200000; i > 0; i--) {
+		done = smart2_read(hba[ctlr], COMMAND_COMPLETE_FIFO);
+		if (done == 0) {
+			udelay(10);	/* a short fixed delay */
+		} else
+			return (done);
+	}
+	/* Invalid address to tell caller we ran out of time */
+	return 1;
+}
+
+/*
+ * Clear the complete FIFO
+ *
+ * Polling routine.
+ * This should only be used at init time.
+ * Any commands unexpectedly found in the completed command fifo
+ * will be discarded.  There should be none.
+ * Note this reads and discards any completed commands but does not
+ * wait for any uncompleted commands.
+ * This is kinda goofy.
+ */
+void flushcomplete(int ctlr)
+{
+
+	unsigned long ret_addr;
+	unsigned int i;
+
+	for (i = 200000; i > 0; i--) {
+		ret_addr = smart2_read(hba[ctlr], COMMAND_COMPLETE_FIFO);
+		if (ret_addr == 0) {
+			break;
+		}
+		udelay(10);
+DBG(
+		printk("ida%d: flushcomplete "
+		       "Discarding completion %x!\n",
+		       ctlr, (unsigned int)ret_addr);
+);
+	}
+}
+
+
+
+/*****************************************************************
+    getgeometry
+    Get ida logical volume geometry from the controller 
+    This is a large bit of code which once existed in two flavors,
+    It is used only at init time.
+****************************************************************
+*/
+void getgeometry(int ctlr)
+{				
+	id_log_drv_t *id_ldrive;
+	id_ctlr_t *id_ctlr_buf;
+	sense_log_drv_stat_t *id_lstatus_buf;
+	config_t *sense_config_buf;
+	unsigned int log_unit, log_index;
+	int ret_code, size;
+	drv_info_t *drv;
+	ctlr_info_t *info_p = hba[ctlr];
+
+	id_ldrive = (id_log_drv_t *)kmalloc(sizeof(id_log_drv_t), GFP_KERNEL);
+	id_ctlr_buf = (id_ctlr_t *)kmalloc(sizeof(id_ctlr_t), GFP_KERNEL);
+	id_lstatus_buf = (sense_log_drv_stat_t *)kmalloc(sizeof(sense_log_drv_stat_t), GFP_KERNEL);
+	sense_config_buf = (config_t *)kmalloc(sizeof(config_t), GFP_KERNEL);
+
+	memset(id_ldrive, 0, sizeof(id_log_drv_t));
+	memset(id_ctlr_buf, 0, sizeof(id_ctlr_t));
+	memset(id_lstatus_buf, 0, sizeof(sense_log_drv_stat_t));
+	memset(sense_config_buf, 0, sizeof(config_t));
+
+	info_p->phys_drives = 0;
+	info_p->log_drv_map = 0;
+	info_p->drv_assign_map = 0;
+	info_p->drv_spare_map = 0;
+	info_p->mp_failed_drv_map = 0;	/* only initialized here */
+	/* Get controllers info for this logical drive */
+	ret_code = sendcmd(ID_CTLR, ctlr, id_ctlr_buf, 0, 0, 0, 0);
+	if (ret_code == IO_ERROR) {
+		/*
+		 * If can't get controller info, set the logical drive map to 0,
+		 * so the idastubopen will fail on all logical drives
+		 * on the controller.
+		 */
+		goto geo_ret;	/* release the buf and return */
+	}
+	info_p->log_drives = id_ctlr_buf->nr_drvs;;
+	*(__u32*)(info_p->firm_rev) = *(__u32*)(id_ctlr_buf->firm_rev);
+	info_p->board_id = id_ctlr_buf->board_id;
+	info_p->ctlr_sig = id_ctlr_buf->cfg_sig;
+
+	switch(info_p->board_id) {
+		case 0x0E114030: /* SMART-2/E */
+			info_p->product = 1;
+			break;
+		case 0x40300E11: /* SMART-2/P or SMART-2DH */
+			info_p->product = 2;
+			break;
+		case 0x40310E11: /* SMART-2SL */
+			info_p->product = 3;
+			break;
+		case 0x40320E11: /* SMART-3200 */
+			info_p->product = 4;
+			break;
+		case 0x40330E11: /* SMART-3100ES */
+			info_p->product = 5;
+			break;
+		case 0x40340E11: /* SMART-221 */
+			info_p->product = 6;
+			break;
+		default:  
+			/*
+			 * Well, its a SMART-2 or better, don't know which
+			 * kind.
+ 			 */
+			info_p->product = 0;
+	}
+	printk(" (%s)\n", product_names[info_p->product]);
+	/*
+	 * Initialize logical drive map to zero
+	 */
+	log_index = 0;
+	/*
+	 * Get drive geometry for all logical drives
+	 */
+	if (id_ctlr_buf->nr_drvs > 16)
+		printk("ida%d:  This driver supports 16 logical drives "
+			"per controller.\n.  Additional drives will not be "
+			"detected\n", ctlr);
+
+	for (log_unit = 0;
+	     (log_index < id_ctlr_buf->nr_drvs)
+	     && (log_unit < NWD);
+	     log_unit++) {
+
+		size = sizeof(sense_log_drv_stat_t);
+
+		/*
+		   Send "Identify logical drive status" cmd
+		 */
+		ret_code = sendcmd(SENSE_LOG_DRV_STAT,
+			     ctlr, id_lstatus_buf, size, 0, 0, log_unit);
+		if (ret_code == IO_ERROR) {
+			/*
+			   If can't get logical drive status, set
+			   the logical drive map to 0, so the
+			   idastubopen will fail for all logical drives
+			   on the controller. 
+			 */
+			info_p->log_drv_map = 0;	
+			printk(
+			     "ida%d: idaGetGeometry - Controller failed "
+				"to report status of logical drive %d\n"
+			 "Access to this controller has been disabled\n",
+				ctlr, log_unit);
+			goto geo_ret;	/* release the buf and return */
+
+		}
+		/*
+		   Make sure the logical drive is configured
+		 */
+		if (id_lstatus_buf->status != LOG_NOT_CONF) {
+			ret_code = sendcmd(ID_LOG_DRV, ctlr, id_ldrive,
+			       sizeof(id_log_drv_t), 0, 0, log_unit);
+			/*
+			   If error, the bit for this
+			   logical drive won't be set and
+			   idastubopen will return error. 
+			 */
+			if (ret_code != IO_ERROR) {
+				drv = &info_p->drv[log_unit];
+				drv->blk_size = id_ldrive->blk_size;
+				drv->nr_blks = id_ldrive->nr_blks;
+				drv->cylinders = id_ldrive->drv.cyl;
+				drv->heads = id_ldrive->drv.heads;
+				drv->sectors = id_ldrive->drv.sect_per_track;
+				info_p->log_drv_map |=	(1 << log_unit);
+
+	printk("ida/c%dd%d: blksz=%d nr_blks=%d\n",
+		ctlr, log_unit, drv->blk_size, drv->nr_blks);
+				ret_code = sendcmd(SENSE_CONFIG,
+						  ctlr, sense_config_buf,
+				 sizeof(config_t), 0, 0, log_unit);
+				if (ret_code == IO_ERROR) {
+					info_p->log_drv_map = 0;
+					goto geo_ret;	/* release the buf and return */
+				}
+				info_p->phys_drives =
+				    sense_config_buf->ctlr_phys_drv;
+				info_p->drv_assign_map
+				    |= sense_config_buf->drv_asgn_map;
+				info_p->drv_assign_map
+				    |= sense_config_buf->spare_asgn_map;
+				info_p->drv_spare_map
+				    |= sense_config_buf->spare_asgn_map;
+			}	/* end of if no error on id_ldrive */
+			log_index = log_index + 1;
+		}		/* end of if logical drive configured */
+	}			/* end of for log_unit */
+      geo_ret:
+	kfree(id_ctlr_buf);
+	kfree(id_ldrive);
+	kfree(id_lstatus_buf);
+	kfree(sense_config_buf);
+}
diff -ruN linux-2.2.3/drivers/block/cpqarray.h linux-2.2.3.smart2/drivers/block/cpqarray.h
--- linux-2.2.3/drivers/block/cpqarray.h	Wed Dec 31 19:00:00 1969
+++ linux-2.2.3.smart2/drivers/block/cpqarray.h	Sun Mar 21 23:40:28 1999
@@ -0,0 +1,101 @@
+/*
+ *    Disk Array driver for Compaq SMART2 Controllers
+ *    Copyright 1998 Compaq Computer Corporation
+ *
+ *    This program is free software; you can redistribute it and/or modify
+ *    it under the terms of the GNU General Public License as published by
+ *    the Free Software Foundation; either version 2 of the License, or
+ *    (at your option) any later version.
+ *
+ *    This program is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, GOOD TITLE or
+ *    NON INFRINGEMENT.  See the GNU General Public License for more details.
+ *
+ *    You should have received a copy of the GNU General Public License
+ *    along with this program; if not, write to the Free Software
+ *    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ *    Questions/Comments/Bugfixes to arrays@compaq.com
+ *
+ *    If you want to make changes, improve or add functionality to this
+ *    driver, you'll probably need the Compaq Array Controller Interface
+ *    Specificiation (Document number ECG086/1198)
+ */
+#ifndef CPQARRAY_H
+#define CPQARRAY_H
+
+#ifdef __KERNEL__
+#include <linux/blkdev.h>
+#include <linux/locks.h>
+#include <linux/malloc.h>
+#include <linux/config.h>
+#include <linux/proc_fs.h>
+#include <linux/md.h>
+#include <linux/timer.h>
+#endif
+
+#include "ida_cmd.h"
+
+#define IO_OK		0
+#define IO_ERROR	1
+#define NWD		16
+#define NWD_SHIFT	4
+
+#define IDA_TIMER	(5*HZ)
+#define IDA_TIMEOUT	(10*HZ)
+
+#define MISC_NONFATAL_WARN	0x01
+
+typedef struct {
+	unsigned blk_size;
+	unsigned nr_blks;
+	unsigned cylinders;
+	unsigned heads;
+	unsigned sectors;
+	int usage_count;
+} drv_info_t;
+
+#ifdef __KERNEL__
+typedef struct {
+	int	ctlr;
+	char	devname[8];
+	__u32	log_drv_map;
+	__u32	drv_assign_map;
+	__u32	drv_spare_map;
+	__u32	mp_failed_drv_map;
+
+	char	firm_rev[4];
+	int	ctlr_sig;
+
+	int	log_drives;
+	int	phys_drives;
+
+	__u32	board_id;
+	int	product;
+
+	__u32	vaddr;
+	__u32	paddr;
+	__u32	ioaddr;
+	int	intr;
+	int	usage_count;
+	drv_info_t	drv[NWD];
+	struct proc_dir_entry *proc;
+
+	cmdlist_t *reqQ;
+	cmdlist_t *cmpQ;
+	cmdlist_t *cmd_pool;
+	__u32	*cmd_pool_bits;
+
+	unsigned int Qdepth;
+	unsigned int maxQsinceinit;
+
+	unsigned int nr_requests;
+	unsigned int nr_allocs;
+	unsigned int nr_frees;
+	struct timer_list timer;
+	unsigned int misc_tflags;
+} ctlr_info_t;
+#endif
+
+#endif /* CPQARRAY_H */
diff -ruN linux-2.2.3/drivers/block/genhd.c linux-2.2.3.smart2/drivers/block/genhd.c
--- linux-2.2.3/drivers/block/genhd.c	Sun Mar 21 23:53:00 1999
+++ linux-2.2.3.smart2/drivers/block/genhd.c	Sun Mar 21 23:45:30 1999
@@ -111,6 +111,16 @@
 			 maj, controller, minor >> hd->minor_shift, partition);
 	    return buf;
 	  }
+	if (hd->major >= COMPAQ_SMART2_MAJOR && hd->major <= COMPAQ_SMART2_MAJOR+7) {
+	        int ctlr = hd->major - COMPAQ_SMART2_MAJOR;
+		int disk = minor >> hd->minor_shift;
+		int part = minor & (( 1 << hd->minor_shift) - 1);
+		if (part == 0)
+		        sprintf(buf, "%s/c%dd%d", maj, ctlr, disk);
+		else
+		    sprintf(buf, "%s/c%dd%dp%d", maj, ctlr, disk, part);
+		return buf;
+ 	}
 	part = minor & ((1 << hd->minor_shift) - 1);
 	if (hd->major >= SCSI_DISK1_MAJOR && hd->major <= SCSI_DISK7_MAJOR) {
 		unit = unit + (hd->major - SCSI_DISK1_MAJOR + 1) * 16;
@@ -136,6 +146,8 @@
 	hd->part[minor].nr_sects   = size;
 	if (hd->major >= DAC960_MAJOR+0 && hd->major <= DAC960_MAJOR+7)
 		printk(" p%d", (minor & ((1 << hd->minor_shift) - 1)));
+ 	if (hd->major >= COMPAQ_SMART2_MAJOR && hd->major <= COMPAQ_SMART2_MAJOR+7) 
+ 		printk(" p%d", (minor & ((1 << hd->minor_shift) - 1)));
 	else
 		printk(" %s", disk_name(hd, minor, buf));
 }
@@ -1326,6 +1338,7 @@
 __initfunc(void device_setup(void))
 {
 	extern void console_map_init(void);
+	extern void cpqarray_init();
 #ifdef CONFIG_PARPORT
 	extern int parport_init(void);
 #endif
@@ -1352,6 +1365,9 @@
 #endif
 #ifdef CONFIG_SCSI
 	scsi_dev_init();
+#endif
+#ifdef CONFIG_BLK_CPQ_DA
+	cpqarray_init();
 #endif
 #ifdef CONFIG_INET
 	net_dev_init();
diff -ruN linux-2.2.3/drivers/block/ida_cmd.h linux-2.2.3.smart2/drivers/block/ida_cmd.h
--- linux-2.2.3/drivers/block/ida_cmd.h	Wed Dec 31 19:00:00 1969
+++ linux-2.2.3.smart2/drivers/block/ida_cmd.h	Sun Mar 21 23:40:28 1999
@@ -0,0 +1,338 @@
+/*
+ *    Disk Array driver for Compaq SMART2 Controllers
+ *    Copyright 1998 Compaq Computer Corporation
+ *
+ *    This program is free software; you can redistribute it and/or modify
+ *    it under the terms of the GNU General Public License as published by
+ *    the Free Software Foundation; either version 2 of the License, or
+ *    (at your option) any later version.
+ *
+ *    This program is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, GOOD TITLE or
+ *    NON INFRINGEMENT.  See the GNU General Public License for more details.
+ *
+ *    You should have received a copy of the GNU General Public License
+ *    along with this program; if not, write to the Free Software
+ *    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ *    Questions/Comments/Bugfixes to arrays@compaq.com
+ *
+ *    If you want to make changes, improve or add functionality to this
+ *    driver, you'll probably need the Compaq Array Controller Interface
+ *    Specificiation (Document number ECG086/1198)
+ */
+#ifndef ARRAYCMD_H
+#define ARRAYCMD_H
+
+#include <asm/types.h>
+#if 0
+#include <linux/blkdev.h>
+#endif
+
+
+#define COMMAND_FIFO		0x04
+#define COMMAND_COMPLETE_FIFO	0x08
+#define INTR_MASK		0x0C
+#define INTR_STATUS		0x10
+#define INTR_PENDING		0x14
+
+#define FIFO_NOT_EMPTY		0x01
+#define FIFO_NOT_FULL		0x02
+
+#define BIG_PROBLEM		0x40
+#define LOG_NOT_CONF		2
+
+#pragma pack(1)
+typedef struct {
+	__u32	size;
+	__u32	addr;
+} sg_t;
+
+#define RCODE_NONFATAL	0x02
+#define RCODE_FATAL	0x04
+#define RCODE_INVREQ	0x10
+typedef struct {
+	__u16	next;
+	__u8	cmd;
+	__u8	rcode;
+	__u32	blk;
+	__u16	blk_cnt;
+	__u8	sg_cnt;
+	__u8	reserved;
+} rhdr_t;
+
+#define SG_MAX			32
+typedef struct {
+	rhdr_t	hdr;
+	sg_t	sg[SG_MAX];
+	__u32	bp;
+} rblk_t;
+
+typedef struct {
+	__u8	unit;
+	__u8	prio;
+	__u16	size;
+} chdr_t;
+
+#define CMD_RWREQ	0x00
+#define CMD_IOCTL_PEND	0x01
+#define CMD_IOCTL_DONE	0x02
+
+typedef struct cmdlist {
+	chdr_t	hdr;
+	rblk_t	req;
+	__u32	size;
+	int	retry_cnt;
+	__u32	busaddr;
+	int	ctlr;
+	struct cmdlist *prev;
+	struct cmdlist *next;
+	struct buffer_head *bh;
+	int type;
+} cmdlist_t;
+	
+#define ID_CTLR		0x11
+typedef struct {
+	__u8	nr_drvs;
+	__u32	cfg_sig;
+	__u8	firm_rev[4];
+	__u8	rom_rev[4];
+	__u8	hw_rev;
+	__u32	bb_rev;
+	__u32	drv_present_map;
+	__u32	ext_drv_map;
+	__u32	board_id;
+	__u8	cfg_error;
+	__u32	non_disk_bits;
+	__u8	bad_ram_addr;
+	__u8	cpu_rev;
+	__u8	pdpi_rev;
+	__u8	epic_rev;
+	__u8	wcxc_rev;
+	__u8	marketing_rev;
+	__u8	ctlr_flags;
+	__u8	host_flags;
+	__u8	expand_dis;
+	__u8	scsi_chips;
+	__u32	max_req_blocks;
+	__u32	ctlr_clock;
+	__u8	drvs_per_bus;
+	__u16	big_drv_present_map[8];
+	__u16	big_ext_drv_map[8];
+	__u16	big_non_disk_map[8];
+	__u16	task_flags;
+	__u8	icl_bus;
+	__u8	red_modes;
+	__u8	cur_red_mode;
+	__u8	red_ctlr_stat;
+	__u8	red_fail_reason;
+	__u8	reserved[403];
+} id_ctlr_t;
+
+typedef struct {
+	__u16	cyl;
+	__u8	heads;
+	__u8	xsig;
+	__u8	psectors;
+	__u16	wpre;
+	__u8	maxecc;
+	__u8	drv_ctrl;
+	__u16	pcyls;
+	__u8	pheads;
+	__u16	landz;
+	__u8	sect_per_track;
+	__u8	cksum;
+} drv_param_t;
+
+#define ID_LOG_DRV	0x10
+typedef struct {
+	__u16	blk_size;
+	__u32	nr_blks;
+	drv_param_t drv;
+	__u8	fault_tol;
+	__u8	reserved;
+	__u8	bios_disable;
+} id_log_drv_t;
+
+#define ID_LOG_DRV_EXT	0x18
+typedef struct {
+	__u32	log_drv_id;
+	__u8	log_drv_label[64];
+	__u8	reserved[418];
+} id_log_drv_ext_t;
+
+#define SENSE_LOG_DRV_STAT	0x12
+typedef struct {
+	__u8	status;
+	__u32	fail_map;
+	__u16	read_err[32];
+	__u16	write_err[32];
+	__u8	drv_err_data[256];
+	__u8	drq_timeout[32];
+	__u32	blks_to_recover;
+	__u8	drv_recovering;
+	__u16	remap_cnt[32];
+	__u32	replace_drv_map;
+	__u32	act_spare_map;
+	__u8	spare_stat;
+	__u8	spare_repl_map[32];
+	__u32	repl_ok_map;
+	__u8	media_exch;
+	__u8	cache_fail;
+	__u8	expn_fail;
+	__u8	unit_flags;
+	__u16	big_fail_map[8];
+	__u16	big_remap_map[8];
+	__u16	big_repl_map[8];
+	__u16	big_act_spare_map[8];
+	__u8	big_spar_repl_map[128];
+	__u16	big_repl_ok_map[8];
+	__u8	big_drv_rebuild;
+	__u8	reserved[36];
+} sense_log_drv_stat_t;
+
+#define START_RECOVER		0x13
+
+#define ID_PHYS_DRV		0x15
+typedef struct {
+	__u8	scsi_bus;
+	__u8	scsi_id;
+	__u16	blk_size;
+	__u32	nr_blks;
+	__u32	rsvd_blks;
+	__u8	drv_model[40];
+	__u8	drv_sn[40];
+	__u8	drv_fw[8];
+	__u8	scsi_iq_bits;
+	__u8	compaq_drv_stmp;
+	__u8	last_fail;
+	__u8	phys_drv_flags;
+	__u8	phys_drv_flags1;
+	__u8	scsi_lun;
+	__u8	phys_drv_flags2;
+	__u8	reserved;
+	__u32	spi_speed_rules;
+	__u8	phys_connector[2];
+	__u8	phys_box_on_bus;
+	__u8	phys_bay_in_box;
+} id_phys_drv_t;
+
+#define BLINK_DRV_LEDS		0x16
+typedef struct {
+	__u32	blink_duration;
+	__u32	reserved;
+	__u8	blink[256];
+	__u8	reserved1[248];
+} blink_drv_leds_t;
+
+#define SENSE_BLINK_LEDS	0x17
+typedef struct {
+	__u32	blink_duration;
+	__u32	btime_elap;
+	__u8	blink[256];
+	__u8	reserved1[248];
+} sense_blink_leds_t;
+
+#define IDA_READ		0x20
+#define IDA_WRITE		0x30
+#define IDA_WRITE_MEDIA		0x31
+#define RESET_TO_DIAG		0x40
+#define DIAG_PASS_THRU		0x41
+
+#define SENSE_CONFIG		0x50
+#define SET_CONFIG		0x51
+typedef struct {
+	__u32	cfg_sig;
+	__u16	compat_port;
+	__u8	data_dist_mode;
+	__u8	surf_an_ctrl;
+	__u16	ctlr_phys_drv;
+	__u16	log_unit_phys_drv;
+	__u16	fault_tol_mode;
+	__u8	phys_drv_param[16];
+	drv_param_t drv;
+	__u32	drv_asgn_map;
+	__u16	dist_factor;
+	__u32	spare_asgn_map;
+	__u8	reserved[6];
+	__u16	os;
+	__u8	ctlr_order;
+	__u8	extra_info;
+	__u32	data_offs;
+	__u8	parity_backedout_write_drvs;
+	__u8	parity_dist_mode;
+	__u8	parity_shift_fact;
+	__u8	bios_disable_flag;
+	__u32	blks_on_vol;
+	__u32	blks_per_drv;
+	__u8	scratch[16];
+	__u16	big_drv_map[8];
+	__u16	big_spare_map[8];
+	__u8	ss_source_vol;
+	__u8	mix_drv_cap_range;
+	struct {
+		__u16	big_drv_map[8];
+		__u32	blks_per_drv;
+		__u16	fault_tol_mode;
+		__u16	dist_factor;
+	} MDC_range[4];
+	__u8	reserved1[248];
+} config_t;
+
+#define BYPASS_VOL_STATE	0x52
+#define SS_CREATE_VOL		0x53
+#define CHANGE_CONFIG		0x54
+#define SENSE_ORIG_CONF		0x55
+#define REORDER_LOG_DRV		0x56
+typedef struct {
+	__u8	old_units[32];
+} reorder_log_drv_t;
+
+#define LABEL_LOG_DRV		0x57
+typedef struct {
+	__u8	log_drv_label[64];
+} label_log_drv_t;
+
+#define SS_TO_VOL		0x58
+	
+#define SET_SURF_DELAY		0x60
+typedef struct {
+	__u16	delay;
+	__u8	reserved[510];
+} surf_delay_t;
+
+#define SET_OVERHEAT_DELAY	0x61
+typedef struct {
+	__u16	delay;
+} overhead_delay_t;
+ 
+#define SET_MP_DELAY
+typedef struct {
+	__u16	delay;
+	__u8	reserved[510];
+} mp_delay_t;
+
+#define PASSTHRU_A	0x91
+typedef struct {
+	__u8	target;
+	__u8	bus;
+	__u8	lun;
+	__u32	timeout;
+	__u32	flags;
+	__u8	status;
+	__u8	error;
+	__u8	cdb_len;
+	__u8	sense_error;
+	__u8	sense_key;
+	__u32	sense_info;
+	__u8	sense_code;
+	__u8	sense_qual;
+	__u8	residual;
+	__u8	reserved[4];
+	__u8	cdb[12];	
+} scsi_param_t;
+
+#pragma pack()	
+
+#endif /* ARRAYCMD_H */
diff -ruN linux-2.2.3/drivers/block/ida_ioctl.h linux-2.2.3.smart2/drivers/block/ida_ioctl.h
--- linux-2.2.3/drivers/block/ida_ioctl.h	Wed Dec 31 19:00:00 1969
+++ linux-2.2.3.smart2/drivers/block/ida_ioctl.h	Sun Mar 21 23:40:28 1999
@@ -0,0 +1,80 @@
+/*
+ *    Disk Array driver for Compaq SMART2 Controllers
+ *    Copyright 1998 Compaq Computer Corporation
+ *
+ *    This program is free software; you can redistribute it and/or modify
+ *    it under the terms of the GNU General Public License as published by
+ *    the Free Software Foundation; either version 2 of the License, or
+ *    (at your option) any later version.
+ *
+ *    This program is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, GOOD TITLE or
+ *    NON INFRINGEMENT.  See the GNU General Public License for more details.
+ *
+ *    You should have received a copy of the GNU General Public License
+ *    along with this program; if not, write to the Free Software
+ *    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ *    Questions/Comments/Bugfixes to arrays@compaq.com
+ *
+ *    If you want to make changes, improve or add functionality to this
+ *    driver, you'll probably need the Compaq Array Controller Interface
+ *    Specificiation (Document number ECG086/1198)
+ */
+#ifndef IDA_IOCTL_H
+#define IDA_IOCTL_H
+
+#include "ida_cmd.h"
+#include "cpqarray.h"
+
+#define IDAGETDRVINFO		0x27272828
+#define IDAPASSTHRU		0x28282929
+#define IDAGETCTLRSIG		0x29293030
+#define IDAREVALIDATEVOLS	0x30303131
+
+/*
+ * Normally, the ioctl determines the logical unit for this command by
+ * the major,minor number of the fd passed to ioctl.  If you need to send
+ * a command to a different/nonexistant unit (such as during config), you
+ * can override the normal behavior by setting the unit valid bit. (Normally,
+ * it should be zero) The controller the command is sent to is still
+ * determined by the major number of the open device.
+ */
+
+#define UNITVALID	0x80
+typedef struct {
+	__u8	cmd;
+	__u8	rcode;
+	__u8	unit;
+
+/* currently, sg_cnt is assumed to be 1: only the 0th element of sg is used */
+	struct {
+		void	*addr;
+		size_t	size;
+	} sg[SG_MAX];
+	int	sg_cnt;
+
+	union ctlr_cmds {
+		drv_info_t		drv;
+		unsigned char		buf[512];
+
+		id_ctlr_t		id_ctlr;
+		drv_param_t		drv_param;
+		id_log_drv_t		id_log_drv;
+		id_log_drv_ext_t	id_log_drv_ext;
+		sense_log_drv_stat_t	sense_log_drv_stat;
+		id_phys_drv_t		id_phys_drv;
+		blink_drv_leds_t	blink_drv_leds;
+		sense_blink_leds_t	sense_blink_leds;
+		config_t		config;
+		reorder_log_drv_t	reorder_log_drv;
+		label_log_drv_t		label_log_drv;
+		surf_delay_t		surf_delay;
+		overhead_delay_t	overhead_delay;
+		mp_delay_t		mp_delay;
+		scsi_param_t		scsi_param;
+	} c;
+} ida_ioctl_t;
+
+#endif /* IDA_IOCTL_H */
diff -ruN linux-2.2.3/drivers/block/ll_rw_blk.c linux-2.2.3.smart2/drivers/block/ll_rw_blk.c
--- linux-2.2.3/drivers/block/ll_rw_blk.c	Sun Mar 21 23:53:00 1999
+++ linux-2.2.3.smart2/drivers/block/ll_rw_blk.c	Sun Mar 21 23:46:42 1999
@@ -362,7 +362,8 @@
 /* for SCSI devices, call request_fn unconditionally */
 	if (scsi_blk_major(major))
 		queue_new_request = 1;
-	if (major >= DAC960_MAJOR+0 && major <= DAC960_MAJOR+7)
+ 	if ((major >= DAC960_MAJOR+0 && major <= DAC960_MAJOR+7) ||
+ 	    (major>=COMPAQ_SMART2_MAJOR && major<=COMPAQ_SMART2_MAJOR+7))
 		queue_new_request = 1;
 
 out:
@@ -530,6 +531,14 @@
 	     case DAC960_MAJOR+5:
 	     case DAC960_MAJOR+6:
 	     case DAC960_MAJOR+7:
+	     case COMPAQ_SMART2_MAJOR+0:
+	     case COMPAQ_SMART2_MAJOR+1:
+	     case COMPAQ_SMART2_MAJOR+2:
+	     case COMPAQ_SMART2_MAJOR+3:
+	     case COMPAQ_SMART2_MAJOR+4:
+	     case COMPAQ_SMART2_MAJOR+5:
+	     case COMPAQ_SMART2_MAJOR+6:
+	     case COMPAQ_SMART2_MAJOR+7:
 		do {
 			if (req->sem)
 				continue;
diff -ruN linux-2.2.3/include/linux/blk.h linux-2.2.3.smart2/include/linux/blk.h
--- linux-2.2.3/include/linux/blk.h	Mon Mar  8 18:52:13 1999
+++ linux-2.2.3.smart2/include/linux/blk.h	Sun Mar 21 23:40:28 1999
@@ -19,7 +19,7 @@
  * NOTE that writes may use only the low 2/3 of these: reads
  * take precedence.
  */
-#define NR_REQUEST	64
+#define NR_REQUEST	256
 
 /*
  * This is used in the elevator algorithm.  We don't prioritise reads
@@ -356,6 +356,16 @@
 #define DEVICE_ON(device) 
 #define DEVICE_OFF(device)
 
+#elif (MAJOR_NR == COMPAQ_SMART2_MAJOR)
+
+#define DEVICE_NAME "ida"
+#define DEVICE_INTR do_ida
+#define TIMEOUT_VALUE (25*HZ)
+#define DEVICE_REQUEST do_ida_request0
+#define DEVICE_NR(device) (MINOR(device) >> 4)
+#define DEVICE_ON(device)
+#define DEVICE_OFF(device)
+
 #endif /* MAJOR_NR == whatever */
 
 #if (MAJOR_NR != SCSI_TAPE_MAJOR)
@@ -432,7 +442,7 @@
 
 #ifndef LOCAL_END_REQUEST	/* If we have our own end_request, we do not want to include this mess */
 
-#if ! SCSI_BLK_MAJOR(MAJOR_NR)
+#if ! SCSI_BLK_MAJOR(MAJOR_NR) && (MAJOR_NR != COMPAQ_SMART2_MAJOR)
 
 static void end_request(int uptodate) {
 	struct request *req = CURRENT;
diff -ruN linux-2.2.3/include/linux/major.h linux-2.2.3.smart2/include/linux/major.h
--- linux-2.2.3/include/linux/major.h	Sun Mar 21 23:53:00 1999
+++ linux-2.2.3.smart2/include/linux/major.h	Sun Mar 21 23:40:28 1999
@@ -90,6 +90,15 @@
 #define SCSI_DISK6_MAJOR	70
 #define SCSI_DISK7_MAJOR	71
 
+#define COMPAQ_SMART2_MAJOR	72
+#define COMPAQ_SMART2_MAJOR1	73
+#define COMPAQ_SMART2_MAJOR2	74
+#define COMPAQ_SMART2_MAJOR3	75
+#define COMPAQ_SMART2_MAJOR4	76
+#define COMPAQ_SMART2_MAJOR5	77
+#define COMPAQ_SMART2_MAJOR6	78
+#define COMPAQ_SMART2_MAJOR7	79
+
 #define SPECIALIX_NORMAL_MAJOR 75
 #define SPECIALIX_CALLOUT_MAJOR 76
 
diff -ruN linux-2.2.3/init/main.c linux-2.2.3.smart2/init/main.c
--- linux-2.2.3/init/main.c	Sun Mar 21 23:53:00 1999
+++ linux-2.2.3.smart2/init/main.c	Sun Mar 21 23:40:28 1999
@@ -326,6 +326,11 @@
 #ifdef CONFIG_LTPC
 extern void ltpc_setup(char *str, int *ints);
 #endif
+#ifdef CONFIG_BLK_CPQ_DA
+#ifdef CONFIG_BLK_CPQ_DA_EISA
+extern void cpqarray_setup(char *str, int *ints);
+#endif
+#endif
 
 #if defined(CONFIG_SYSVIPC)
 extern void ipc_init(void);
@@ -864,6 +869,11 @@
 #endif
 #ifdef CONFIG_LTPC
 	{ "ltpc=", ltpc_setup },
+#endif
+#ifdef CONFIG_BLK_CPQ_DA
+#ifdef CONFIG_BLK_CPQ_DA_EISA
+	{ "smart2=", cpqarray_setup },
+#endif
 #endif
 	{ 0, 0 }
 };
