Index: xc/programs/Xserver/hw/xfree86/xf86Version.h
diff -u xc/programs/Xserver/hw/xfree86/xf86Version.h:3.236.2.70 xc/programs/Xserver/hw/xfree86/xf86Version.h:3.236.2.76
--- xc/programs/Xserver/hw/xfree86/xf86Version.h:3.236.2.70	Thu Nov 19 03:42:22 1998
+++ xc/programs/Xserver/hw/xfree86/xf86Version.h	Tue Jan  5 06:16:05 1999
@@ -1,12 +1,13 @@
-/* $XFree86: xc/programs/Xserver/hw/xfree86/xf86Version.h,v 3.236.2.70 1998/11/18 16:42:22 hohndel Exp $ */
+/* $XFree86: xc/programs/Xserver/hw/xfree86/xf86Version.h,v 3.236.2.76 1999/01/04 19:16:05 hohndel Exp $ */
 
-#define XF86_VERSION " 3.3.3 "
+#define XF86_VERSION " 3.3.3.1 "
 
 /* The finer points in versions... */
 #define XF86_VERSION_MAJOR	3
 #define XF86_VERSION_MINOR	3
 #define XF86_VERSION_SUBMINOR	3
-#define XF86_VERSION_BETA	0	/* 0="", 1="A", 2="B", etc... */
+#define XF86_VERSION_PATCHLEV	1
+#define XF86_VERSION_BETA	XF86_VERSION_PATCHLEV
 #define XF86_VERSION_ALPHA	0	/* 0="", 1="a", 2="b", etc... */
 
 #define XF86_VERSION_NUMERIC(major,minor,subminor,beta,alpha)	\
@@ -18,6 +19,6 @@
 			XF86_VERSION_BETA,			\
 			XF86_VERSION_ALPHA)
 
-#define XF86_DATE	"November 18 1998"
+#define XF86_DATE	"January 4 1999"
 
 /* $XConsortium: xf86Version.h /main/78 1996/10/28 05:42:10 kaleb $ */
Index: xc/config/cf/DGUX.cf
diff -u xc/config/cf/DGUX.cf:1.1.1.3 xc/config/cf/DGUX.cf:1.1.1.3.2.4
--- xc/config/cf/DGUX.cf:1.1.1.3	Sun Dec 22 14:14:22 1996
+++ xc/config/cf/DGUX.cf	Mon Dec 28 23:00:46 1998
@@ -1,22 +1,223 @@
-XCOMM platform:  $XConsortium: DGUX.cf /main/5 1996/09/28 16:04:56 rws $
+XCOMM platform:  $XFree86: xc/config/cf/DGUX.cf,v 1.1.1.3.2.4 1998/12/28 12:00:46 dawes Exp $
+/* Copyright Takis Psarogiannakopoulos <takis@dpmms.cam.ac.uk>
+ * This is the DG/ux configuration file of X11R6.3 
+ */
+#ifndef OSName
+#define OSName			DefaultOSName
+#endif
+#ifndef OSMajorVersion
+#define OSMajorVersion		DefaultOSMajorVersion
+#endif
+#ifndef OSMinorVersion
+#define OSMinorVersion		DefaultOSMinorVersion
+#endif
+#ifndef OSTeenyVersion
+#define OSTeenyVersion		DefaultOSTeenyVersion
+#endif
 
+/* Fallbacks */
 #ifndef OSName
-#define OSName            DG/UX 4.32
+#define	OSName	DG/ux R4.20MU03
 #endif
-XCOMM operating system:  OSName
 #ifndef OSMajorVersion
-#define OSMajorVersion    4
+#define	OSMajorVersion	4
 #endif
 #ifndef OSMinorVersion
-#define OSMinorVersion    32
+#define	OSMinorVersion	20
+#endif
+#ifndef OSTeenyVersion
+#define	OSTeenyVersion	3
+#endif
+
+#ifndef OSVendor
+#define OSVendor Data General Corporation
+#endif
+
+XCOMM operating system:	OSName (OSMajorVersion./**/OSMinorVersion./**/OSTeenyVersion)
+
+#define i386Architecture
+#define BootstrapCFlags		-DDGUX
+
+/* Some stuff that all SVR4s ,so and DG/ux, should have */
+
+#define SystemV4		YES
+#ifndef HasLdRunPath
+#define HasLdRunPath		YES
+#endif
+#define HasPoll			YES
+#ifndef SVR4Architecture
+#define SVR4Architecture
+#endif
+#ifndef PatheticCpp
+#define PatheticCpp		YES
+#endif
+#define Malloc0ReturnsNull	YES		/* in case -lmalloc used */
+
+/*
+ * Here are the default paths to use tools for building.
+ */
+
+#define ArCmdBase       /usr/bin/ar
+#define AsCmd           /usr/bin/as
+#define CppCmd          /usr/lib/cpp
+#define LdCmd           /usr/bin/ld
+#define LexCmd          /usr/bin/lex
+#define CcCmd           /usr/local/bin/gcc      /* ?  -fpcc-struct-return */
+#define UNCOMPRESSPATH  /usr/bin/uncompress
+#define MakeCmd         /usr/local/bin/make
+#define YaccCmd         /usr/bin/yacc
+#define InstallCmd      /usr/bin/install   /* I use gnu install-sh */
+#define LnCmd           ln -s
+#define RanlibCmd true                         /* Or make a link ranlib->true */ 
+#define CplusplusCmd    /usr/local/bin/g++
+
+
+
+
+
+
+#ifndef MkdirHierCmd
+#define MkdirHierCmd mkdir -p
+#endif
+/* Stuff for SVR4 4.0 */
+#ifndef XawI18nDefines
+#define XawI18nDefines          -DUSE_XWCHAR_STRING
+#endif
+
+#if 0
+#define ProjectRoot /usr/X11R6.3   /* Look also in site.def for the default */
+#endif
+
+#define HasPutenv YES
+#define HasVFork YES
+#define HasVoidSignalReturn  YES
+#define HasBsearch YES
+#define HasSockets YES
+#define BuildServer YES
+#define HasSharedLibraries YES   /* to build shared libs */
+#define HasGcc YES
+#define HasGcc2 YES
+#define HasGcc2ForCplusplus YES
+#define HasCplusplus YES
+#define HasGnuMake YES          /* Added for 3.2Xc */
+#define UseGnuMalloc YES
+#define GnuMallocLibrary -L/usr/local/lib -lmalloc
+#define Malloc0ReturnsNull YES  /* Added for 3.2Xh,i... GNU does return 0 */
+#define Malloc0ReturnsNullDefines -DMALLOC_0_RETURNS_NULL   /* define for GNU malloc X3.2i */
+/*******TCL TK DEFINITIONS ***********/
+#define HasTk  YES                 /* Comment out if you dont have this */
+#define TkLibDir    /usr/X11R6.3/lib
+#define TkIncDir    /usr/X11R6.3/include
+#define TkLibName   tk8.0
+#define HasTcl YES
+#define TclLibName  tcl8.0
+#define TclLibDir   /usr/X11R6.3/lib
+#define TclIncDir   /usr/X11R6.3/include
+
+#define SystemManDirectory /usr/local/man/X
+
+#define ExtraLibraries -lelf -lgen -lresolv -lsocket -lnsl -lw
+
+#define StandardDefines -DDGUX -DSVR4 -Di386 -D__ix86 -D_DGUX_SOURCE -D_LITTLE_ENDIAN -D_PENTIUM_CHANGE
+
+#ifndef HasGcc2
+#define HasGcc2 YES     /* We suppose that your DG/ux has gcc-dg.2.7.2.88 */
+#endif                  /* Do NOT use native DG/ux gcc, it is faulty in general */
+#ifndef HasGcc
+#define HasGcc HasGcc2
+#endif
+
+#define PositionIndependentCFlags -fpic
+#define PositionIndependentCplusplusFlags -fpic
+
+/*
+ * To forceably build static libraries in addition to shared libraries,
+ * we put this.
+ */
+#define ForceNormalLib          YES
+
+#ifndef ToolkitStringsABIOptions
+#define ToolkitStringsABIOptions -intelabi -earlyR6bc
+#endif
+
+#define DefaultCCOptions     /* -ansi -pedantic */
+#define OptimizedCDebugFlags -O2  /* Add -g -mstandard for full debuging info */
+#define OptimizedCplusplusDebugFlags
+#define DebuggableCDebugFlags -g -mstandard
+#define DebuggableCplusplusDebugFlags
+#define SharedLibraryLoadFlags -G -z text
+#define PositionIndependentCFlags -fpic
+#define PositionIndependentCplusplusFlags -fpic
+
+
+
+/*
+ * The default optimisation flags for GCC 2.x.  -fno-strength-reduce is
+ * here to work around a bug in -O2 for GCC 2.x on i386 platforms.
+ * If you are using a version that doesn't have this bug, you can
+ * uncomment the following line, and remove '-fno-strength-reduce'
+ *
+#define DefaultGcc2i386Opt      -O2 -fno-strength-reduce
+ */
+
+/* Compress all the Fonts */
+#define CompressAllFonts        YES
+
+
+
+/* Manual pages installed under their full names */ 
+
+#define ExpandManNames          YES
+#define CompressManPages        YES
+
+
+
+
+/* Install with stripping before ? */
+#define StripInstalledPrograms  YES
+
+/* Server to Install */
+#define XserverNeedsSetUID YES
+#define InstallXserverSetUID YES
+
+
+#ifndef ServerOSDefines
+#define ServerOSDefines -DDDXTIME XFree86ServerOSDefines
+#endif
+#ifndef BuildDynamicLoading
+#define BuildDynamicLoading NO
+#endif
+#if BuildDynamicLoading
+#define ServerExtraSysLibs -ldl
+#endif
+
+/*
+ * The TLI interface is more robust on most SVR4s, so it will be the default.
+ */
+#ifndef ConnectionFlags
+#define ConnectionFlags	-DSTREAMSCONN -DUNIXCONN -DLOCALCONN
 #endif
 
-#define BootstrapCFlags   -DDGUX
-#define StandardDefines   -DDGUX -DSYSV
-#define SystemV           YES
-#define HasPutenv         YES
-#define HasGcc            YES
-#define BuildServer       NO
-#define UNCOMPRESSPATH /usr/bin/X11/uncompress
+#ifndef ManSuffix
+#define ManSuffix               1x
+#define ManDir			$(MANSOURCEPATH)1
+#endif
+#ifndef LibManSuffix
+#define LibManSuffix            3x
+#define LibmanDir		$(MANSOURCEPATH)3
+#endif
+#ifndef FileManSuffix
+#define FileManSuffix           4
+#endif
+
+#ifndef StaticLibrary
+#if !HasGcc
+#define StaticLibrary(libpath,libname) -B static Concat(-L,libpath) Concat(-l,libname) -B dynamic
+#endif
+#endif
+
+#ifdef i386Architecture
+#include <xfree86.cf>
+#endif
 
-#define ExtraFilesToClean *.lg
+#include <sv4Lib.rules>
Index: xc/config/cf/FreeBSD.cf
diff -u xc/config/cf/FreeBSD.cf:3.58.2.17 xc/config/cf/FreeBSD.cf:3.58.2.19
--- xc/config/cf/FreeBSD.cf:3.58.2.17	Sun Nov  8 20:06:27 1998
+++ xc/config/cf/FreeBSD.cf	Fri Dec 18 22:56:07 1998
@@ -1,5 +1,5 @@
 XCOMM platform:  $TOG: FreeBSD.cf /main/18 1997/06/12 07:40:35 kaleb $
-XCOMM platform:  $XFree86: xc/config/cf/FreeBSD.cf,v 3.58.2.17 1998/11/08 09:06:27 dawes Exp $
+XCOMM platform:  $XFree86: xc/config/cf/FreeBSD.cf,v 3.58.2.19 1998/12/18 11:56:07 dawes Exp $
 
 #ifndef UseElfFormat
 #define UseElfFormat		DefaultToElfFormat
@@ -35,15 +35,15 @@
 #define GccUsesGas		YES
 #define UseGas			YES
 #define GnuCpp			YES
-#define HasNdbm         	YES
-#define HasPutenv       	YES
+#define HasNdbm			YES
+#define HasPutenv		YES
 #define HasSnprintf		YES
 #define HasBSD44Sockets 	YES
 #ifndef HasLibCrypt
 # define HasLibCrypt		YES
 #endif
 #ifndef HasShm
-# define HasShm          	YES
+# define HasShm			YES
 #endif
 #define HasWChar32		YES
 
@@ -124,7 +124,7 @@
  * and they can remove it from the list of directories they add to ld.so.cache 
  * in their /etc/rc file.
  */
-#if OSMajorVersion > 2 || (OsMajorVersion == 2 && OSMinorVersion >= 2)
+#if OSMajorVersion > 2 || (OSMajorVersion == 2 && OSMinorVersion >= 2)
 #ifndef ExtraLoadFlags
 #if UseElfFormat
 #define ExtraLoadFlags		-Wl,-rpath,$(USRLIBDIRPATH)
@@ -321,9 +321,9 @@
 # define PreIncDir	/usr/include
 #endif
 
-#define TroffCmd        groff -Tps
+#define TroffCmd	groff -Tps
 #define NroffCmd	groff -Tascii
-#define SetTtyGroup     YES
+#define SetTtyGroup	YES
 
 #ifndef ExtraFilesToClean
 # define ExtraFilesToClean *.core
@@ -341,7 +341,7 @@
  * Compress manual pages
  */
 #ifndef CompressManPages
-# define CompressManPages        YES
+# define CompressManPages	YES
 #endif
 
 #if CompressManPages
@@ -352,37 +352,37 @@
    COMPRESSMANCMD = CompressManCmd
 
 #ifndef InstallManPageLong
-#define InstallManPageLong(file,destdir,dest)                           @@\
-install.man:: file.man                                                  @@\
-	MakeDir($(DESTDIR)destdir)                                      @@\
-	$(RM) $(DESTDIR)destdir/dest.$(MANSUFFIX)*                      @@\
-	$(INSTALL) -c $(INSTMANFLAGS) file.man \                        @@\
-          $(DESTDIR)destdir/dest.$(MANSUFFIX)                           @@\
+#define InstallManPageLong(file,destdir,dest)				@@\
+install.man:: file.man							@@\
+	MakeDir($(DESTDIR)destdir)					@@\
+	$(RM) $(DESTDIR)destdir/dest.$(MANSUFFIX)*			@@\
+	$(INSTALL) -c $(INSTMANFLAGS) file.man \			@@\
+	  $(DESTDIR)destdir/dest.$(MANSUFFIX)				@@\
 	-$(COMPRESSMANCMD) $(DESTDIR)destdir/dest.$(MANSUFFIX)
 #endif
 
 #ifndef InstallGenManPageLong
-#define InstallGenManPageLong(file,destdir,dest,suffix)                 @@\
-install.man:: file.man                                                  @@\
-	MakeDir($(DESTDIR)destdir)                                      @@\
-	$(RM) $(DESTDIR)destdir/dest.suffix*                            @@\
-	$(INSTALL) -c $(INSTMANFLAGS) file.man \                        @@\
-          $(DESTDIR)destdir/dest.suffix                                 @@\
+#define InstallGenManPageLong(file,destdir,dest,suffix)			@@\
+install.man:: file.man							@@\
+	MakeDir($(DESTDIR)destdir)					@@\
+	$(RM) $(DESTDIR)destdir/dest.suffix*				@@\
+	$(INSTALL) -c $(INSTMANFLAGS) file.man \			@@\
+	  $(DESTDIR)destdir/dest.suffix					@@\
 	-$(COMPRESSMANCMD) $(DESTDIR)destdir/dest.suffix
 #endif
 
 #ifndef InstallMultipleMan
-#define InstallMultipleMan(list,dest)                                   @@\
-install.man:: list                                                      @@\
+#define InstallMultipleMan(list,dest)					@@\
+install.man:: list							@@\
 	MakeDir($(DESTDIR)dest)						@@\
-	@case '${MFLAGS}' in *[i]*) set +e;; esac; \                    @@\
-	for i in list; do \                                             @@\
-	        (set -x; \                                              @@\
-	        MNAME=`echo $$i | cut -f1 -d.`; \			@@\
-	        $(RM) $(DESTDIR)dest/$${MNAME}*; \                      @@\
-	        $(INSTALL) -c $(INSTMANFLAGS) $$i \                     @@\
-		  $(DESTDIR)dest/$${MNAME}.$(MANSUFFIX); \              @@\
-	        $(COMPRESSMANCMD) $(DESTDIR)dest/$${MNAME}.$(MANSUFFIX)); \  @@\
+	@case '${MFLAGS}' in *[i]*) set +e;; esac; \			@@\
+	for i in list; do \						@@\
+		(set -x; \						@@\
+		MNAME=`echo $$i | cut -f1 -d.`; \			@@\
+		$(RM) $(DESTDIR)dest/$${MNAME}*; \			@@\
+		$(INSTALL) -c $(INSTMANFLAGS) $$i \			@@\
+		  $(DESTDIR)dest/$${MNAME}.$(MANSUFFIX); \		@@\
+		$(COMPRESSMANCMD) $(DESTDIR)dest/$${MNAME}.$(MANSUFFIX)); \ @@\
 	done
 #endif
 
@@ -390,13 +390,13 @@
  * InstallManPageAliases - install soft links for aliases.
  */
 #ifndef InstallManPageAliases
-#define InstallManPageAliases(file,destdir,aliases)                     @@\
-install.man::                                                           @@\
+#define InstallManPageAliases(file,destdir,aliases)			@@\
+install.man::								@@\
 	@(SUFFIX=`echo $(DESTDIR)destdir/file.* | sed -e 's,.*/[^\.]*.,,'`; \ @@\
-	for i in aliases; do (set -x; \                                 @@\
-	$(RM) $(DESTDIR)destdir/$$i.*; \                                @@\
-	(cd $(DESTDIR)destdir; $(LN) file.$${SUFFIX} \                  @@\
-	$$i.$${SUFFIX})); \                                             @@\
+	for i in aliases; do (set -x; \					@@\
+	$(RM) $(DESTDIR)destdir/$$i.*; \				@@\
+	(cd $(DESTDIR)destdir; $(LN) file.$${SUFFIX} \			@@\
+	$$i.$${SUFFIX})); \						@@\
 	done)
 #endif
 
@@ -404,7 +404,7 @@
  * InstallGenManPageAliases - install soft links for aliases.
  */
 #ifndef InstallGenManPageAliases
-#define InstallGenManPageAliases(file,destdir,suffix,aliases)              @@\
+#define InstallGenManPageAliases(file,destdir,suffix,aliases)		@@\
 	InstallManPageAliases(file,destdir,aliases)
 #endif
 #endif
Index: xc/config/cf/Imake.cf
diff -u xc/config/cf/Imake.cf:3.34.2.9 xc/config/cf/Imake.cf:3.34.2.11
--- xc/config/cf/Imake.cf:3.34.2.9	Thu Nov 12 21:34:47 1998
+++ xc/config/cf/Imake.cf	Tue Dec 22 22:23:01 1998
@@ -1,5 +1,5 @@
 XCOMM $TOG: Imake.cf /main/28 1997/06/25 08:31:36 barstow $
-XCOMM $XFree86: xc/config/cf/Imake.cf,v 3.34.2.9 1998/11/12 10:34:47 dawes Exp $
+XCOMM $XFree86: xc/config/cf/Imake.cf,v 3.34.2.11 1998/12/22 11:23:01 hohndel Exp $
 /*
  * To add support for another platform:
  * 
@@ -406,7 +406,7 @@
 # endif
 #endif /* MOTOROLA */
 
-#ifdef SVR4
+#if defined(SVR4) && !defined(DGUX)
 # ifdef i386
 #  define i386Architecture
 #  undef i386
@@ -500,6 +500,8 @@
 #endif /* SYSV386 */
 
 #ifdef DGUX
+# define i386Architecture
+# define SVR4Architecture
 # define MacroIncludeFile <DGUX.cf>
 # define MacroFile DGUX.cf
 # undef DGUX
@@ -655,8 +657,14 @@
 #endif /* minix */
 
 #ifdef MACH
+#ifdef __GNU__
+#define MacroIncludeFile <gnu.cf>
+#define MacroFile gnu.cf
+#define GNUMachArchitecture
+#else
 #define MacroIncludeFile <mach.cf>
 #define MacroFile mach.cf
+#endif
 #undef MACH
 #ifdef	i386
 #define i386MachArchitecture
Index: xc/config/cf/Imakefile
diff -u xc/config/cf/Imakefile:3.13.2.2 xc/config/cf/Imakefile:3.13.2.3
--- xc/config/cf/Imakefile:3.13.2.2	Sun Jul 27 12:41:03 1997
+++ xc/config/cf/Imakefile	Tue Dec 22 22:23:01 1998
@@ -1,5 +1,5 @@
 XCOMM $XConsortium: Imakefile /main/38 1996/11/07 14:43:46 kaleb $
-XCOMM $XFree86: xc/config/cf/Imakefile,v 3.13.2.2 1997/07/27 02:41:03 dawes Exp $
+XCOMM $XFree86: xc/config/cf/Imakefile,v 3.13.2.3 1998/12/22 11:23:01 hohndel Exp $
 
 XCOMM Some compilers generate fatal errors if an -L directory does
 XCOMM not exist.  Since BUILDLIBDIR may not exist yet suppress its use.
@@ -27,6 +27,7 @@
 X11.rules \
 bsdLib.rules \
 cde.rules \
+gnuLib.rules \
 hpLib.rules \
 ibmLib.rules \
 lnxLib.rules \
@@ -57,6 +58,7 @@
 bsdLib.tmpl \
 cde.tmpl \
 hpLib.tmpl \
+gnuLib.tmpl \
 ibmLib.tmpl \
 lnxLib.tmpl \
 lnxdoc.tmpl \
@@ -86,6 +88,7 @@
 cray.cf \
 fujitsu.cf \
 generic.cf \
+gnu.cf \
 hp.cf \
 ibm.cf \
 isc.cf \
Index: xc/config/cf/NetBSD.cf
diff -u xc/config/cf/NetBSD.cf:3.49.2.11 xc/config/cf/NetBSD.cf:3.49.2.12
--- xc/config/cf/NetBSD.cf:3.49.2.11	Sat Nov  7 00:54:15 1998
+++ xc/config/cf/NetBSD.cf	Tue Dec 22 22:23:02 1998
@@ -2,7 +2,7 @@
 
 
 
-XCOMM platform:  $XFree86: xc/config/cf/NetBSD.cf,v 3.49.2.11 1998/11/06 13:54:15 dawes Exp $
+XCOMM platform:  $XFree86: xc/config/cf/NetBSD.cf,v 3.49.2.12 1998/12/22 11:23:02 hohndel Exp $
 
 
 #ifndef OSName
@@ -135,6 +135,12 @@
 #endif
 
 #ifdef i386Architecture
+# ifndef DefaultGcc2i386Opt
+#  if OSMajorVersion > 1 || (OSMajorVersion == 1 && OSMinorVersion > 2)
+    /* The GCC strength-reduce bug is fixed for NetBSD 1.3 and later */
+#   define DefaultGcc2i386Opt -O2
+#  endif
+# endif
 # define OptimizedCDebugFlags 	DefaultGcc2i386Opt
 # if OSMajorVersion < 1
 #  define ServerOSDefines	XFree86ServerOSDefines -DDDXTIME -DXNO_SYSCONF
Index: xc/config/cf/OpenBSD.cf
diff -u xc/config/cf/OpenBSD.cf:3.1.2.12 xc/config/cf/OpenBSD.cf:3.1.2.13
--- xc/config/cf/OpenBSD.cf:3.1.2.12	Sun Oct  4 23:36:13 1998
+++ xc/config/cf/OpenBSD.cf	Tue Dec 22 22:23:02 1998
@@ -1,4 +1,4 @@
-XCOMM platform:  $XFree86: xc/config/cf/OpenBSD.cf,v 3.1.2.12 1998/10/04 13:36:13 hohndel Exp $
+XCOMM platform:  $XFree86: xc/config/cf/OpenBSD.cf,v 3.1.2.13 1998/12/22 11:23:02 hohndel Exp $
 XCOMM
 XCOMM $OpenBSD: OpenBSD.cf,v 1.33 1998/09/27 04:52:48 rahnds Exp $
 XCOMM
@@ -77,7 +77,13 @@
 #define AsmDefines 		-DUSE_GAS
 
 #ifdef i386Architecture
-# define OptimizedCDebugFlags 	DefaultGcc2i386Opt
+# ifndef DefaultGcc2i386Opt
+#  if (OSMajorVersion == 2 && OSMinorVersion >= 3) || OSMajorVersion > 2
+    /* The GCC strength-reduce bug is fixed for OpenBSD 2.3 and later */
+#   define DefaultGcc2i386Opt	-O2
+#  endif
+# endif
+# define OptimizedCDebugFlags	DefaultGcc2i386Opt
 # define ServerOSDefines	XFree86ServerOSDefines -DDDXTIME
 # define ServerExtraSysLibs	-li386
 # define LdPostLib		/**/
Index: xc/config/cf/X11.tmpl
diff -u xc/config/cf/X11.tmpl:1.8.2.8 xc/config/cf/X11.tmpl:1.8.2.9
--- xc/config/cf/X11.tmpl:1.8.2.8	Sun Nov  8 20:06:28 1998
+++ xc/config/cf/X11.tmpl	Wed Dec 30 21:04:09 1998
@@ -5,7 +5,7 @@
 XCOMM
 XCOMM
 XCOMM
-XCOMM $XFree86: xc/config/cf/X11.tmpl,v 1.8.2.8 1998/11/08 09:06:28 dawes Exp $
+XCOMM $XFree86: xc/config/cf/X11.tmpl,v 1.8.2.9 1998/12/30 10:04:09 dawes Exp $
 
 /***************************************************************************
  *                                                                         *
@@ -1743,7 +1743,11 @@
 all::   Concat(subdir,.dir)						@@\
 									@@\
 Concat(subdir,.dir):							@@\
+	RemoveFile(Concat(subdir,.dir))					@@\
 	$(XKBCOMPCMD) -lfhlpR -o Concat(subdir,.dir) '*'		@@\
+									@@\
+clean::									@@\
+	RemoveFile(Concat(subdir,.dir))					@@\
 									@@\
 InstallTarget(install,Concat(subdir,.dir),$(INSTDATFLAGS),basedir)
 #endif
Index: xc/config/cf/gnu.cf
diff -u /dev/null xc/config/cf/gnu.cf:1.2.2.2
--- /dev/null	Wed Jan  6 00:29:39 1999
+++ xc/config/cf/gnu.cf	Tue Dec 22 23:27:31 1998
@@ -0,0 +1,113 @@
+XCOMM platform:  $XFree86: xc/config/cf/gnu.cf,v 1.2.2.2 1998/12/22 12:27:31 hohndel Exp $
+
+#ifndef OSName
+#define OSName			GNU 0.2
+#endif
+#ifndef OSVendor
+#define OSVendor		/**/
+#endif
+#ifndef OSMajorVersion
+#define OSMajorVersion		DefaultOSMajorVersion
+#endif
+#ifndef OSMinorVersion
+#define OSMinorVersion		DefaultOSMinorVersion
+#endif
+#ifndef OSTeenyVersion
+#define OSTeenyVersion		DefaultOSTeenyVersion
+#endif
+XCOMM operating system:  OSName (OSMajorVersion./**/OSMinorVersion./**/OSTeenyVersion)
+
+#define HasGcc 			YES
+#define HasGcc2			YES
+#define GccUsesGas		YES
+#define UseGas			YES
+#define GnuCpp			YES
+#define UseGccMakeDepend	YES
+#define HasGnuMake		YES
+#ifndef HasGcc2ForCplusplus
+#define HasGcc2ForCplusplus	YES
+#endif
+
+#define XserverNeedsSetUID	YES
+
+#define ProjectRoot 		/usr/X11R6
+#define YaccCmd                 bison -y
+#define LexCmd			flex
+#ifndef LexLib
+#define LexLib			-lfl
+#endif
+#define ArCmd			/bin/ar clq
+#define AsCmd			/bin/as
+#define CcCmd			/bin/gcc
+#define CppCmd			/lib/gcc-lib/i586--gnu/egcs-2.91.60/cpp
+#define PreProcessCmd		CcCmd -EP -x c
+#define RanlibCmd		/bin/ranlib
+#define LdCmd			/bin/ld
+#define DefaultCCOptions	-pedantic
+#define GccGasOption 		-DGCCUSESGAS
+#define DefaultGcc2i386Opt 	-O2
+#if HasGcc2 && defined(i386Architecture)
+#define OptimizedCDebugFlags	DefaultGcc2i386Opt
+#else
+#define OptimizedCDebugFlags	
+#endif
+
+
+#define AsmDefines		-DUSE_GAS
+#define BootstrapCFlags		
+#define ExtensionOSDefines	
+
+#ifdef i386Architecture
+#define ServerExtraDefines	GccGasOption XFree86ServerDefines -DNO_ALLOCA
+#else
+#define ServerExtraDefines	GccGasOption
+#endif
+#define StandardCppDefines	-traditional StandardDefines 
+#define StandardDefines		-D_XOPEN_SOURCE -D_POSIX_SOURCE -D_BSD_SOURCE  -D__ELF__
+#define ServerOSDefines		XFree86ServerOSDefines -DDDXTIME
+#define ConnectionFlags		-DTCPCONN
+#define HasBSD44Sockets		YES
+#define HasSockets		YES
+
+#define UseElfFormat		YES
+#define	HasSharedLibraries	YES
+#include <gnuLib.rules>
+
+#define BuildXCSecurity		YES
+#define AvoidNullMakeCommand	YES
+#define CompressAllFonts	YES
+#define DirFailPrefix -
+#define HasNdbm         	YES
+#define HasPutenv       	YES
+#define Malloc0ReturnsNull	NO
+#define NeedConstPrototypes	YES
+#define NeedFunctionPrototypes	YES
+#define NeedNestedPrototypes	YES
+#define NeedVarargsPrototypes	YES
+#define NeedWidePrototypes	NO
+#define StripInstalledPrograms	YES
+#ifndef HasLibCrypt
+# define HasLibCrypt		YES
+#endif
+#define HasPoll			YES
+#define TermcapLibrary		-lncurses
+#ifndef GnuMallocLibrary
+#define GnuMallocLibrary	/* -lgnumalloc */
+#endif
+
+#ifdef InstallCmd
+#undef  InstallCmd
+#endif
+#define InstallCmd		/bin/install
+
+#define TroffCmd        groff -Tps
+
+#ifndef ExtraFilesToClean
+# define ExtraFilesToClean *.core
+#endif
+
+#ifdef i386Architecture
+# include <xfree86.cf>
+#endif
+
+
Index: xc/config/cf/gnuLib.rules
diff -u /dev/null xc/config/cf/gnuLib.rules:1.1.2.2
--- /dev/null	Wed Jan  6 00:29:40 1999
+++ xc/config/cf/gnuLib.rules	Tue Dec 22 23:27:32 1998
@@ -0,0 +1,121 @@
+/*
+ * GNU/Hurd shared library rules
+ *
+ * $XFree86: xc/config/cf/gnuLib.rules,v 1.1.2.2 1998/12/22 12:27:32 hohndel Exp $
+ */
+
+#ifndef UseElfFormat
+#define UseElfFormat YES
+#endif
+
+/*
+ * GNU/Hurd shared library rules
+ * Cloned from NetBSD/FreeBSD (ELF) shared library rules
+ *
+ */
+
+#ifndef HasSharedLibraries
+#define HasSharedLibraries YES
+#endif
+#ifndef ForceNormalLib
+#define ForceNormalLib YES
+#endif
+
+#ifndef BaseShLibReqs
+#define BaseShLibReqs		/* -lc implied by $(CC) */
+#endif
+
+#ifndef SharedDataSeparation
+#define SharedDataSeparation NO
+#endif
+#ifndef SharedCodeDef
+#define SharedCodeDef /**/
+#endif
+#ifndef SharedLibraryDef
+#define SharedLibraryDef /**/
+#endif
+#ifndef ShLibIncludeFile
+#define ShLibIncludeFile <gnuLib.tmpl>
+#endif
+#ifndef SharedLibraryLoadFlags
+#define SharedLibraryLoadFlags -shared -Wl,-rpath=$(USRLIBDIR)
+#endif
+#ifndef PositionIndependentCFlags
+#define PositionIndependentCFlags -fPIC
+#endif
+#ifndef PositionIndependentCplusplusFlags
+#define PositionIndependentCplusplusFlags -fPIC
+#endif
+#ifndef ExtraLoadFlags
+#ifdef UseInstalled
+#define ExtraLoadFlags -Wl,-rpath=$(USRLIBDIRPATH)
+#else
+#define ExtraLoadFlags -Wl,-dynamic-linker=/lib/ld.so.1 -Wl,-rpath=/lib:$(USRLIBDIRPATH) -Wl,-rpath-link=$(BUILDLIBDIR)
+#endif
+#endif
+
+/*
+ * InstallSharedLibrary - generate rules to install the shared library.
+ * NOTE: file must be executable, hence "INSTBINFLAGS"
+ */
+#ifndef InstallSharedLibrary
+#define InstallSharedLibrary(libname,rev,dest)				@@\
+install:: Concat(lib,libname.so.rev) 					@@\
+	MakeDir($(DESTDIR)dest)						@@\
+	$(INSTALL) $(INSTALLFLAGS) $(INSTBINFLAGS) Concat(lib,libname.so.rev) $(DESTDIR)dest @@\
+	(T=`echo Concat($(DESTDIR)dest/lib,libname.so.rev) | sed 's/\.[^\.]*$$//'`;\
+		$(RM) $$T && $(LN) Concat(lib,libname.so.rev) $$T)	@@\
+	(T=`echo Concat($(DESTDIR)dest/lib,libname.so.rev) | sed 's/\.so.*$$/.so/'`;\
+		$(RM) $$T && $(LN) Concat(lib,libname.so.rev) $$T)	@@\
+	$(RM) Concat($(DESTDIR)dest/lib,libname.so)			@@\
+	$(LN) Concat(lib,libname.so.rev) Concat($(DESTDIR)dest/lib,libname.so)
+#endif /* InstallSharedLibrary */
+
+/*
+ * InstallSharedLibraryData - generate rules to install the shared library data
+ */
+#ifndef InstallSharedLibraryData
+#define InstallSharedLibraryData(libname,rev,dest)
+#endif /* InstallSharedLibraryData */
+
+
+/*
+ * SharedLibraryTarget - generate rules to create a shared library;
+ * build it into a different name so that we do not hose people by having
+ * the library gone for long periods.
+ */
+#ifndef SharedLibraryTarget
+#ifdef UseInstalled  
+#define LinkBuildSonameLibrary(lib) true
+#else
+#define LinkBuildSonameLibrary(lib) (RemoveFile($(BUILDLIBDIR)/lib); \
+	cd $(BUILDLIBDIR); $(LN) $(BUILDINCTOP)/$(CURRENT_DIR)/lib .)
+#endif
+
+#define SharedLibraryTarget(libname,rev,solist,down,up)			@@\
+AllTarget(Concat(lib,libname.so.rev))					@@\
+									@@\
+Concat(lib,libname.so.rev):  solist					@@\
+	$(RM) $@~							@@\
+	SONAME=`echo $@ | sed 's/\.[^\.]*$$//'`; \			@@\
+		(cd down; $(CC) -o up/$@~ $(SHLIBLDFLAGS) -Wl,-soname,$$SONAME solist $(REQUIREDLIBS) BaseShLibReqs); \ @@\
+		$(RM) $$SONAME; $(LN) $@ $$SONAME; \			@@\
+		LinkBuildSonameLibrary($$SONAME)			@@\
+	$(RM) $@							@@\
+	$(MV) $@~ $@							@@\
+	$(RM) Concat(lib,libname.so)					@@\
+	$(LN) $@ Concat(lib,libname.so)					@@\
+	LinkBuildLibrary($@)						@@\
+	LinkBuildLibrary(Concat(lib,libname.so))			@@\
+									@@\
+clean::									@@\
+	$(RM) Concat(lib,libname.so.rev)
+
+#endif /* SharedLibraryTarget */
+
+/*
+ * SharedLibraryDataTarget - generate rules to create shlib data file;
+ */
+#ifndef SharedLibraryDataTarget
+#define SharedLibraryDataTarget(libname,rev,salist)
+#endif /* SharedLibraryTarget */
Index: xc/config/cf/gnuLib.tmpl
diff -u /dev/null xc/config/cf/gnuLib.tmpl:1.1.2.2
--- /dev/null	Wed Jan  6 00:29:40 1999
+++ xc/config/cf/gnuLib.tmpl	Tue Dec 22 23:27:32 1998
@@ -0,0 +1,33 @@
+/*
+ * GNU Hurd shared library template
+ *
+ * $XFree86: xc/config/cf/gnuLib.tmpl,v 1.1.2.2 1998/12/22 12:27:32 hohndel Exp $
+ */
+
+#ifndef FixupLibReferences
+#define FixupLibReferences()						@@\
+XMULIBONLY = -lXmu							@@\
+XMULIB = $(XMULIBONLY) $(XTOOLLIB) $(XLIB)
+#endif
+
+#ifndef XawClientLibs
+#define XawClientLibs $(XAWLIB) $(XMULIBONLY) $(XTOOLLIB) $(XLIB)
+#endif
+
+#define CplusplusLibC
+#define FrescoSysLibs	CplusplusLibC MathLibrary
+
+#define SharedX11Reqs
+#define SharedOldXReqs	$(LDPRELIB) $(XLIBONLY)
+#define SharedXtReqs	$(LDPRELIB) $(XLIBONLY) $(SMLIB) $(ICELIB)
+#define SharedXawReqs	$(LDPRELIB) $(XMULIB) $(XTOOLLIB) $(XLIB)
+#define SharedXmuReqs	$(LDPRELIB) $(XTOOLLIB) $(XLIB)
+#define SharedXextReqs	$(LDPRELIB) $(XLIBONLY)
+#define SharedXiReqs	$(LDPRELIB) $(XLIB)
+#define SharedPexReqs	$(LDPRELIB) $(XLIBONLY) MathLibrary
+#define SharedXtstReqs	$(LDPRELIB) $(XLIB)
+#define SharedXieReqs	$(LDPRELIB) $(XLIBONLY)
+#define SharedSMReqs	$(LDPRELIB) $(ICELIB)
+#define SharedFrescoReqs	$(LDPRELIB) $(XLIBONLY) FrescoSysLibs
+#define SharedXtfReqs	$(LDPRELIB) $(FRESCOLIB) $(XTOOLLIB) $(XLIB) FrescoSysLibs
+
Index: xc/config/cf/lnxLib.rules
diff -u xc/config/cf/lnxLib.rules:3.28.2.3 xc/config/cf/lnxLib.rules:3.28.2.4
--- xc/config/cf/lnxLib.rules:3.28.2.3	Sun Jun 22 20:32:20 1997
+++ xc/config/cf/lnxLib.rules	Fri Dec 18 22:56:08 1998
@@ -1,5 +1,5 @@
 XCOMM $XConsortium: lnxLib.rules /main/13 1996/09/28 16:11:01 rws $
-XCOMM $XFree86: xc/config/cf/lnxLib.rules,v 3.28.2.3 1997/06/22 10:32:20 dawes Exp $
+XCOMM $XFree86: xc/config/cf/lnxLib.rules,v 3.28.2.4 1998/12/18 11:56:08 dawes Exp $
 
 /*
  * Linux shared library rules (DLL & ELF versions)
@@ -22,6 +22,7 @@
 #define UseInternalMalloc NO
 #endif
 
+#if LinuxCLibMajorVersion <= 5
 /*
  *	#define BaseShLibReqs	-lc
  *
@@ -39,6 +40,10 @@
  *
  */
 #define BaseShLibReqs
+#else
+/* With GNU libc 2 this works fine. */
+#define BaseShLibReqs	-lc
+#endif
 
 #ifndef SharedDataSeparation
 #define SharedDataSeparation NO
Index: xc/config/cf/os2.cf
diff -u xc/config/cf/os2.cf:3.18.2.6 xc/config/cf/os2.cf:3.18.2.7
--- xc/config/cf/os2.cf:3.18.2.6	Thu Nov  5 00:17:43 1998
+++ xc/config/cf/os2.cf	Sun Dec 20 21:37:54 1998
@@ -2,7 +2,7 @@
 
 
 
-XCOMM platform:  $XFree86: xc/config/cf/os2.cf,v 3.18.2.6 1998/11/04 13:17:43 hohndel Exp $
+XCOMM platform:  $XFree86: xc/config/cf/os2.cf,v 3.18.2.7 1998/12/20 10:37:54 dawes Exp $
 
 #define OSName           OS/2
 #define OSVendor	 IBM
@@ -19,7 +19,6 @@
  */
 #define BootstrapCFlags   -DBSD43
 
-/* X_WCHAR and X_LOCALE are set in Xosdefs.h */
 #define StandardDefines   -DX_LOCALE -DX_WCHAR
 #define XawI18nDefines    -DUSE_XWCHAR_STRING -DUSE_XMBTOWC
 
Index: xc/config/cf/sco5.cf
diff -u xc/config/cf/sco5.cf:3.1.2.4 xc/config/cf/sco5.cf:3.1.2.5
--- xc/config/cf/sco5.cf:3.1.2.4	Sat Jul 19 14:59:08 1997
+++ xc/config/cf/sco5.cf	Mon Dec 14 01:11:59 1998
@@ -1,4 +1,4 @@
-XCOMM $XFree86: xc/config/cf/sco5.cf,v 3.1.2.4 1997/07/19 04:59:08 dawes Exp $
+XCOMM $XFree86: xc/config/cf/sco5.cf,v 3.1.2.5 1998/12/13 14:11:59 dawes Exp $
 
 /*
  * This is for SCO Open Server 5.0.2 or later.
@@ -59,6 +59,8 @@
 
 #ifdef BuildDynamicLoading
 #define SCODynamicFlags         -Wl,-Bexport
+#else
+#define SCODynamicFlags
 #endif
 
 #define XawI18nDefines          -DHAS_WCHAR_H -DHAS_ISW_FUNCS
Index: xc/config/imake/imakemdep.h
diff -u xc/config/imake/imakemdep.h:3.24.2.9 xc/config/imake/imakemdep.h:3.24.2.11
--- xc/config/imake/imakemdep.h:3.24.2.9	Thu Nov 12 21:34:48 1998
+++ xc/config/imake/imakemdep.h	Mon Dec 28 00:10:09 1998
@@ -25,7 +25,7 @@
 in this Software without prior written authorization from the X Consortium.
 
 */
-/* $XFree86: xc/config/imake/imakemdep.h,v 3.24.2.9 1998/11/12 10:34:48 dawes Exp $ */
+/* $XFree86: xc/config/imake/imakemdep.h,v 3.24.2.11 1998/12/27 13:10:09 dawes Exp $ */
 
 
 /* 
@@ -173,8 +173,12 @@
 #endif
 
 #ifdef  MACH
+#ifdef __GNU__
+#define imake_ccflags ""
+#else
 #define imake_ccflags "-DNOSTDHDRS"
 #endif
+#endif
 
 /* this is for OS/2 under EMX. This won't work with DOS */
 #if defined(__EMX__)
@@ -269,6 +273,9 @@
 /* expects cpp in PATH */
 #define DEFAULT_CPP "cpp"
 #endif
+#if defined(__GNU__)
+#define USE_CC_E
+#endif
 
 #if defined(Lynx)
 /* On LynxOS 2.4.0 imake gets built with the old "legacy"
@@ -305,7 +312,7 @@
 	"-Uunix",	/* remove unix symbol so that filename unix.c okay */
 #endif
 #endif
-#if defined(__386BSD__) || defined(__NetBSD__) || defined(__OpenBSD__) || defined(__FreeBSD__) || defined(MACH) || defined(linux)
+#if defined(__386BSD__) || defined(__NetBSD__) || defined(__OpenBSD__) || defined(__FreeBSD__) || defined(MACH) || defined(linux) || defined(__GNU__)
 # ifdef __i386__
 	"-D__i386__",
 # endif
@@ -692,6 +699,11 @@
 	if ((__sp = strchr((buf), ' ')) != NULL)			\
 		*__sp = '/';						\
     } while (0)
+#elif defined(DGUX)
+# define DEFAULT_OS_MAJOR_REV	"r R%[0-9]"
+# define DEFAULT_OS_MINOR_REV	"r R%*d.%[0-9]"
+# define DEFAULT_OS_TEENY_REV	"r R%*d.%*dMU%[0-9]"
+# define DEFAULT_OS_NAME	"smr %[^\n]"
 #else
 # if defined(__Lynx__) || defined(Lynx)
 /* Lynx 2.4.0 /bin/cc doesn't like #elif */
Index: xc/programs/Xserver/PEX5/dipex/dispatch/dipexExt.c
diff -u xc/programs/Xserver/PEX5/dipex/dispatch/dipexExt.c:3.3.4.2 xc/programs/Xserver/PEX5/dipex/dispatch/dipexExt.c:3.3.4.3
--- xc/programs/Xserver/PEX5/dipex/dispatch/dipexExt.c:3.3.4.2	Sun Sep 20 15:42:29 1998
+++ xc/programs/Xserver/PEX5/dipex/dispatch/dipexExt.c	Sun Dec 20 21:37:54 1998
@@ -1,5 +1,5 @@
 /* $XConsortium: dipexExt.c,v 5.11 94/04/17 20:36:04 dpw Exp $ */
-/* $XFree86: xc/programs/Xserver/PEX5/dipex/dispatch/dipexExt.c,v 3.3.4.2 1998/09/20 05:42:29 dawes Exp $ */
+/* $XFree86: xc/programs/Xserver/PEX5/dipex/dispatch/dipexExt.c,v 3.3.4.3 1998/12/20 10:37:54 dawes Exp $ */
 
 /***********************************************************
 
@@ -130,7 +130,7 @@
     if (!PEXStructType || !PEXSearchType || !PEXRendType || !PEXWksDrawableType
 	|| !PEXWksType || !PEXPipeType   || !PEXNameType || !PEXFontType 
 	|| !PEXLutType || !PEXPickType   || !PEXClass    || !PEXContextType ) {
-	    ErrorF("PEXExtensionInit: Could not create PEX resource types");
+	    ErrorF("PEXExtensionInit: Could not create PEX resource types\n");
 	    return;
 	}
 
Index: xc/programs/Xserver/cfb/cfbblt.c
diff -u xc/programs/Xserver/cfb/cfbblt.c:3.1 xc/programs/Xserver/cfb/cfbblt.c:3.1.2.1
--- xc/programs/Xserver/cfb/cfbblt.c:3.1	Mon Dec  9 22:50:52 1996
+++ xc/programs/Xserver/cfb/cfbblt.c	Mon Dec 14 01:12:03 1998
@@ -31,7 +31,9 @@
 
 */
 /* $XConsortium: cfbblt.c,v 1.13 94/04/17 20:28:44 dpw Exp $ */
-/* $XFree86: xc/programs/Xserver/cfb/cfbblt.c,v 3.1 1996/12/09 11:50:52 dawes Exp $ */
+/* $XFree86: xc/programs/Xserver/cfb/cfbblt.c,v 3.1.2.1 1998/12/13 14:12:03 dawes Exp $ */
+
+/* 24-bit bug fixes: Peter Wainwright, 1998/11/28 */
 
 #include	"X.h"
 #include	"Xmd.h"
@@ -57,6 +59,103 @@
 #define DO_MEMCPY
 #endif
 
+/* ................................................. */
+/* SPECIAL CODE FOR 24 BITS      by Peter Wainwright */
+
+#if PSZ == 24 && (MROP) == 0
+
+/* The default macros are defined in mergerop.h, and none of them are
+   really appropriate for what we want to do.
+
+   There are two ways of fixing this: either define SLOW_24BIT_COPY
+   to copy pixel by pixel, or (by default) use the following macros
+   modified from mergerop.h
+
+   MROP_SOLID and MROP_MASK are defined for each of the operations,
+   i.e. each value of MROP.
+
+   There are special cases for Mcopy, McopyInverted, Mxor, and Mor.
+   There is a completely generic version for MROP=0, and a simplified
+   generic version which works for (Mcopy|Mxor|MandReverse|Mor).
+
+   However, the generic version does not work for the 24-bit case
+   because the pixels cannot be packed exactly into a machine word (32
+   bits).
+
+   Alternative macros MROP_SOLID24 and MROP_MASK24 are provided for
+   the 24-bit case. However, these each copy a single *pixel*, not a
+   single machine word. They take an rvalue source pixel, an lvalue
+   destination, and the pixel index. The latter is used to find the
+   position of the pixel data within the two words *dst and *(dst+1).
+
+   Further macros MROP_SOLID24P and MROP_MASK24P are used to copy from
+   an lvalue source to an lvalue destination. MROP_PIXEL24 is used to
+   assemble the source pixel from the adjacent words *src and
+   *(src+1), and this is then split between the destination words
+   using the non-P macros above.
+
+   But we want to copy entire words for the sake of efficiency.
+   Unfortunately if a plane mask is specified this must be shifted
+   from one word to the next.  Fortunately the pattern repeats after 3
+   words, so we unroll the planemask here and redefine MROP_SOLID
+   and MROP_MASK. */
+
+#define DeclareMergeRop24i() unsigned long   _ca1[3], _cx1[3], _ca2[3], _cx2[3];
+
+#if	(BITMAP_BIT_ORDER == MSBFirst)
+#define InitializeMergeRop24i(alu,pm) {		\
+  unsigned long _pm;				\
+  mergeRopPtr  _bits;				\
+  int i;					\
+  for (i = 0; i < 3; i++) {			\
+    _pm = ((pm << (8+8*i)) | (pm >> (16-8*i)));	\
+    _bits = &mergeRopBits[alu];			\
+    _ca1[i] = _bits->ca1 &  _pm;		\
+    _cx1[i] = _bits->cx1 | ~_pm;		\
+    _ca2[i] = _bits->ca2 &  _pm;		\
+    _cx2[i] = _bits->cx2 &  _pm;		\
+  }						\
+}
+#else	/* (BITMAP_BIT_ORDER == LSBFirst) */
+#define InitializeMergeRop24i(alu,pm) {		\
+  unsigned long _pm;				\
+  mergeRopPtr  _bits;				\
+  int i;					\
+  for (i = 0; i < 3; i++) {			\
+    _pm = ((pm >> (8*i)) | (pm << (24-8*i)));	\
+    _bits = &mergeRopBits[alu];			\
+    _ca1[i] = _bits->ca1 &  _pm;		\
+    _cx1[i] = _bits->cx1 | ~_pm;		\
+    _ca2[i] = _bits->ca2 &  _pm;		\
+    _cx2[i] = _bits->cx2 &  _pm;		\
+  }						\
+}
+#endif	/* (BITMAP_BIT_ORDER == MSBFirst) */
+
+#define DoMergeRop24i(src, dst, i)					\
+((dst) & ((src) & _ca1[i] ^ _cx1[i]) ^ ((src) & _ca2[i] ^ _cx2[i]))
+
+#define DoMaskMergeRop24i(src, dst, mask, i)							\
+((dst) & (((src) & _ca1[i] ^ _cx1[i]) | ~(mask)) ^ (((src) & _ca2[i] ^ _cx2[i]) & (mask)))
+
+#undef MROP_DECLARE
+#define MROP_DECLARE()			DeclareMergeRop24i()
+/* We can't put the arrays in registers */
+#undef MROP_DECLARE_REG
+#define MROP_DECLARE_REG()		DeclareMergeRop24i()
+#undef MROP_INITIALIZE
+#define MROP_INITIALIZE(alu, pm)	InitializeMergeRop24i(alu, pm)
+#undef MROP_SOLID
+#define MROP_SOLID(src, dst)		\
+	DoMergeRop24i(src, dst, (&(dst)-pdstBase) % 3)
+#undef MROP_MASK
+#define MROP_MASK(src, dst, mask)	\
+	DoMaskMergeRop24i(src, dst, mask, (&(dst)-pdstBase) % 3)
+
+#endif /* MROP == 0 && PSZ == 24 */
+
+/* ................................................. */
+
 void
 MROP_NAME(cfbDoBitblt)(pSrc, pDst, alu, prgnDst, pptSrc, planemask)
     DrawablePtr	    pSrc, pDst;
@@ -286,9 +385,39 @@
 #else /* ! DO_MEMCPY */
 	if (xdir == 1)
 	{
+#if defined(SLOW_24BIT_COPY) && PSZ == 24 && MROP == 0
+	  while (h--)
+	    {
+	      /* Unfortunately a word-by-word copy is difficult for 24-bit
+		 pixmaps, since the planemask is in a different position
+		 for each word (though the pattern repeats every 3
+		 words). So instead we copy pixel by pixel.
+
+		 We can accelerate this by unrolling the loop and copying
+		 3 words at a time. */
+	      register int i, si, sii, di;
+
+	      for (i = 0, si = pptSrc->x, di = pbox->x1;
+		   i < w;
+		   i++, si++, di++) {
+		psrc = psrcLine + ((si * 3) >> 2);
+		pdst = pdstLine + ((di * 3) >> 2);
+		sii = (si & 3);
+		MROP_SOLID24P(psrc, pdst, sii, di);
+	      }
+	      pdstLine += widthDst;
+	      psrcLine += widthSrc;
+	    }
+#else /* ! (defined(SLOW_24BIT_COPY) && PSZ == 24 && MROP == 0) */
 #if PSZ == 24
-	    xoffSrc = (4 - pptSrc->x) & 3;
-	    xoffDst = (4 - pbox->x1) & 3;
+	    /* Note: x is a pixel number; the byte offset is 3*x;
+	       therefore the offset within a word is (3*x) & 3 ==
+	       (4*x-x) & 3 == (-x) & 3.  The offsets therefore
+	       DECREASE by 1 for each pixel.
+	       Note: We are assuming 4 bytes per word here!
+	    */
+	    xoffSrc = (-pptSrc->x) & 3;
+	    xoffDst = (-pbox->x1) & 3;
 	    pdstLine += (pbox->x1 * 3) >> 2;
 	    psrcLine += (pptSrc->x * 3) >> 2;
 #else
@@ -486,10 +615,35 @@
 		}
 	    }
 #endif /* DO_UNALIGNED_BITBLT */
+#endif /* defined(SLOW_24BIT_COPY) && PSZ == 24 && MROP == 0 */
 	}
 #endif /* ! DO_MEMCPY */
 	else	/* xdir == -1 */
 	{
+#if defined(SLOW_24BIT_COPY) && PSZ == 24 && MROP == 0
+	  while (h--)
+	    {
+	      /* Unfortunately a word-by-word copy is difficult for 24-bit
+		 pixmaps, since the planemask is in a different position
+		 for each word (though the pattern repeats every 3
+		 words). So instead we copy pixel by pixel.
+
+		 We can accelerate this by unrolling the loop and copying
+		 3 words at a time. */
+	      register int i, si, sii, di;
+
+	      for (i = 0, si = pptSrc->x, di = pbox->x1;
+		   i < w;
+		   i++, si++, di++) {
+		psrc = psrcLine + ((si * 3) >> 2);
+		pdst = pdstLine + ((di * 3) >> 2);
+		sii = (si & 3);
+		MROP_SOLID24P(psrc, pdst, sii, di);
+	      }
+	      psrcLine += widthSrc;
+	      pdstLine += widthDst;
+	    }
+#else /* ! (defined(SLOW_24BIT_COPY) && PSZ == 24 && MROP == 0) */
 #if PSZ == 24
 	    xoffSrc = (pptSrc->x + w) & 3;
 	    xoffDst = pbox->x2 & 3;
@@ -681,6 +835,7 @@
 		}
 	    }
 #endif
+#endif /* defined(SLOW_24BIT_COPY) && PSZ == 24 && MROP == 0 */
 	}
 	pbox++;
 	pptSrc++;
Index: xc/programs/Xserver/hw/xfree68/doc/Imakefile
diff -u xc/programs/Xserver/hw/xfree68/doc/Imakefile:3.3.2.5 xc/programs/Xserver/hw/xfree68/doc/Imakefile:3.3.2.6
--- xc/programs/Xserver/hw/xfree68/doc/Imakefile:3.3.2.5	Sat Nov  7 23:00:46 1998
+++ xc/programs/Xserver/hw/xfree68/doc/Imakefile	Mon Nov 30 23:16:47 1998
@@ -3,7 +3,7 @@
 
 
 
-XCOMM $XFree86: xc/programs/Xserver/hw/xfree68/doc/Imakefile,v 3.3.2.5 1998/11/07 12:00:46 dawes Exp $
+XCOMM $XFree86: xc/programs/Xserver/hw/xfree68/doc/Imakefile,v 3.3.2.6 1998/11/30 12:16:47 dawes Exp $
 
 #include <Server.tmpl>
 #include <lnxdoc.rules>
@@ -84,7 +84,7 @@
             README.chips README.cirrus README.Video7 README.P9000 README.agx \
             README.S3 README.S3V README.SiS README.W32 README.Oak \
             README.Mach32 \
-            README.Mach64 README.ark README.MGA README.NV1 README.fbdev \
+            README.Mach64 README.ark README.MGA README.NVIDIA README.fbdev \
             README.mouse
 
 MAINDOCS = COPYRIGHT README README.Config BUILD RELNOTES
@@ -112,7 +112,7 @@
 LinkFile(README.Mach32,$(XF86SRC)/doc/READ.Mach32)
 LinkFile(README.Mach64,$(XF86SRC)/doc/READ.Mach64)
 LinkFile(README.FreeBSD,$(XF86SRC)/doc/READ.FreeBSD)
-LinkFile(README.Riva128,$(XF86SRC)/doc/README.NV1)
+LinkFile(README.Riva128,$(XF86SRC)/doc/README.NVIDIA)
 LinkSourceFile(README,$(XF86SRC)/doc)
 LinkSourceFile(README.Bsdi,$(XF86SRC)/doc)
 LinkSourceFile(README.Config,$(XF86SRC)/doc)
@@ -122,7 +122,7 @@
 LinkSourceFile(README.LynxOS,$(XF86SRC)/doc)
 LinkSourceFile(README.Mach,$(XF86SRC)/doc)
 LinkSourceFile(README.MGA,$(XF86SRC)/doc)
-LinkSourceFile(README.NV1,$(XF86SRC)/doc)
+LinkSourceFile(README.NVIDIA,$(XF86SRC)/doc)
 LinkSourceFile(README.NetBSD,$(XF86SRC)/doc)
 LinkSourceFile(README.OpenBSD,$(XF86SRC)/doc)
 LinkSourceFile(README.OS2,$(XF86SRC)/doc)
Index: xc/programs/Xserver/hw/xfree86/CHANGELOG
diff -u xc/programs/Xserver/hw/xfree86/CHANGELOG:3.390.2.194 xc/programs/Xserver/hw/xfree86/CHANGELOG:3.390.2.212
--- xc/programs/Xserver/hw/xfree86/CHANGELOG:3.390.2.194	Thu Nov 19 03:42:18 1998
+++ xc/programs/Xserver/hw/xfree86/CHANGELOG	Tue Jan  5 06:16:01 1999
@@ -1,3 +1,94 @@
+XFree86 3.3.3.1 (4 January 1998)
+1299. Put a copy of <linux/fb.h> in hw/xfree86/etc for reference.
+1298. Document the MGA hw cursor problem with virtual screens >= 8MB.
+1297. Update PC98 documentation (#2350. Takaaki Nomura).
+
+XFree86 3.3.3Z (29 December 1998)
+1296. Add a "cursor_bug" option to enable an experimental workaround for
+      the hw cursor problem that shows up with some Millennium II cards.
+1295. Fix startx incorrectly handling client/server arguments that start with
+      '.' or '/'.
+1294. Fix a tgui problem introduced with item 1276.
+1293. Some minor DG/ux and scanpci updates (Takis Psarogiannakopoulos).
+1292. Fix problem with SVGA s3v driver not turning off the HW cursor when
+      entering DGA mode.
+1291. Fix problem with mouse movement causing viewport changes while in
+      DGA mode.
+1290. Fix some build problems on SVR4.0.
+1289. Documentation updates.
+1288. Fix DGA with NVIDIA driver (#2339, Itai Nahshon).
+1287. Fix XF86Setup, resync PC98 Imakefiles, update Cards98 and XF98Conf.cpp
+      (#2341, Takaaki Nomura).
+
+XFree86 3.3.3b (22 December 1998)
+1286. Fix bug with AceCAD and SummaGraphics XINPUT drivers (#2334, 
+      Frederic Lepied).
+1285. Add support for GNU/Hurd(gnu-0.2) and also glibc-pre2.1 based Hurd
+      (#2329, Uchiyama Yasushi).
+1284. Remove -fno-strength-reduce on NetBSD and OpenBSD (#2328,
+      Matthieu Herrb).
+1283. Update XF86Setup to show correct chipsets for Trident and Matrox driver
+      (Dirk Hohndel).
+1282. Add later Matrox chipsets to SuperProbe (Dirk Hohndel).
+1281. Documentation update for xterm (#2333, Tom Dickey).
+1280. Add Gamma correction to Mach64 server (#2324, Kevin Martin).
+1279. Documentation update and PC98 resync (#2330, Takaaki Nomura).
+1278. Add the newly rewritten Riva code from NVIDIA. Fixes some bugs with 
+      multiple server instances running and other problems with the previous
+      code. The NV1 code is unchanged. The code looks to be Open Source.
+      (#2336, David Schmenk, NVIDIA).
+1277. Fix some drawing errors in the cyrix driver (#2335, Annius Groenink).
+1276. Trident fix to only disable PCI bursting on the 9440 (#2338, 
+      Alan Hourihane).
+
+XFree86 3.3.3a (20 December 1998)
+1275. Disable hardware cursor for MGA if there is not enough memory.
+1274. Documentation updates.
+1273. Add support for the Number Nine I128 Rev IV (Galen Brooks).
+1272. Fix Wacom driver to not send two release events (#2323, Frederic Lepied).
+1271. Change the default name of the SGI dial box to conform to the GLUT
+      default (#2323, Frederic Lepied).
+1270. Fix multi-mouse XInput support (#2323, Frederic Lepied).
+1269. Fix DGA relative mouse movement events when XINPUT is defined.
+1268. DG/ux i386 support (Takis Psarogiannakopoulos).
+1267. Some enhanced XKB files for French-Canadian keyboards (#2204,
+      Eric Moreau).
+1266. Make the X server read an Xauthority file using the real user id
+      to avoid problems when it is located on an NFS-mounted filesystem.
+      (as suggested by #2276, MIHIRA Sanpei Yoshiro).
+1265. Fix an xset segfault (#2320, Itai Nahshon).
+1264. Fix the incorrect mga memory message for Millennium II and G100 cards.
+1263. Only show the mga driver "Read OPTION" message once.
+1262. Avoid an S3V server lockup (#2222, Harald Koenig).
+1261. Set BaseShLibReqs to "-lc" for Linux + glibc2, which avoids problems
+      on systems with both libc5 and glibc2-based X libraries.
+1261. Fix cfb24 bitblt for non-trivial planemasks (Peter Wainwright).
+1260. Fix a typo in FreeBSD.cf that affects adding the runtime library
+      search patch for 2.2.x (#2305, Keisuke Inoue).
+1259. Fix an incorrect realloc in xmodmap (#2303, Alexander V. Lukyanov).
+1258. Some SCO updates (#2302, J. Kean Johnston).
+1257. Fix PC98 XKB (#2292, Hirofumi Nishizuka and #2300, Tetsuo Tsukamoto).
+1256. Update PC98 docs and sample config file (#2292, 2300, Takaaki Nomura).
+1255. Fix MGAG200RamdacInit() not being called for PCI versions of G100/G200
+      cards (Mark Vojkovich).
+1254. Fix Cyrix problem with non-trivial rops (Dave Gotwisner).
+1253. Fix an Xlib  problem with _XimLookupMBText() when using KOI8-R
+      (#2282, Alexander Kabaev).
+1252. Fix the pattern source address mask for the C&T HiQV chips, which
+      was causing 8x8 pattern problems when using more than 2MB of video
+      memory (#2281, Peter Wainwright).
+1251. Fix a mode name typo in xf86config (#2280, Darrin B. Jewell).
+1250. Update PC98 Card database (#2279, 2292, Takaaki Nomura).
+1249. Update sco_mouse.c for XInput changes in 3.3.3 (#2278, Dan Rosenblatt).
+1248. Fix a core dump problem in xauth when interrupted while attempting
+      to lock the auth file.  Also fix a potential problem with calling
+      printf() from within a signal handler (#2274, BSDI/Jeff Polk).
+1247. Fix a problem that shows up occasionally with the X server's PCI probe
+      code detecting phantom entries.
+1246. Fix typo in the 3Dlabs driver that causes serious problems for most OSs.
+1245. Fix some relatively minor install problems (#2238, Geert Uytterhoeven
+      and #2268, Matthieu Herrb).
+
 XFree86 3.3.3 (18 November 1998)
 1244. Obfuscate the NVIDIA sources by NVIDIA's request.
 
@@ -304,7 +395,7 @@
 1096. VSTATUS support in xterm (#2019, Robert Earl).
 1095. Support for arc4random() in xdm/genauth.c (#2019, Michael Shalayeff).
 1094. German amiga XKB maps (#2019, Bernd Ernesti).
-1093. Swedish sun keyboad support in Xsun and xkb (#2019, Magnus Holmberg).
+1093. Swedish sun keyboard support in Xsun and xkb (#2019, Magnus Holmberg).
 1092. OpenBSD/amiga support in imake (#2019, Niklas Hallqvist).
 1091. Make LinkVarDirectory handle DESTDIR, OpenBSD.cf synchronisation, fix
       TopXInclude definition in X11.rules (for building contrib against $TOP
@@ -5457,4 +5548,4 @@
 
 XFree86 3.0 (26 April 1994)
 
-$XFree86: xc/programs/Xserver/hw/xfree86/CHANGELOG,v 3.390.2.194 1998/11/18 16:42:18 hohndel Exp $
+$XFree86: xc/programs/Xserver/hw/xfree86/CHANGELOG,v 3.390.2.212 1999/01/04 19:16:01 hohndel Exp $
Index: xc/programs/Xserver/hw/xfree86/SuperProbe/I128.c
diff -u xc/programs/Xserver/hw/xfree86/SuperProbe/I128.c:3.6 xc/programs/Xserver/hw/xfree86/SuperProbe/I128.c:3.6.2.3
--- xc/programs/Xserver/hw/xfree86/SuperProbe/I128.c:3.6	Fri Jan  3 18:59:20 1997
+++ xc/programs/Xserver/hw/xfree86/SuperProbe/I128.c	Wed Dec  9 01:32:48 1998
@@ -1,4 +1,4 @@
-/* $XFree86: xc/programs/Xserver/hw/xfree86/SuperProbe/I128.c,v 3.6 1997/01/03 07:59:20 dawes Exp $ */
+/* $XFree86: xc/programs/Xserver/hw/xfree86/SuperProbe/I128.c,v 3.6.2.3 1998/12/08 14:32:48 robin Exp $ */
 /*
  * (c) Copyright 1993,1994 by Robin Cutshaw <robin@xfree86.org>
  *
@@ -96,7 +96,8 @@
 	    pcibus | cardnum, vendor, device);
 #endif
 		    if ((vendor == 0x105D) &&
-		        ((device == 0x2309) || (device == 0x2339))) {
+		        ((device == 0x2309) || (device == 0x2339) ||
+		         (device == 0x493D) || (device == 0x5348))) {
 			outpl(PCI_MODE1_ADDRESS_REG, PCI_EN | pcibus | cardnum | 0x24);
 			iobase = inpl(PCI_MODE1_DATA_REG) & 0xFFFFFF00;
 
@@ -154,7 +155,8 @@
 #endif
 
 	    if ((vendor != 0x105D) ||
-		((device != 0x2309) && (device != 0x2339))) {
+		((device != 0x2309) && (device != 0x2339) &&
+		 (device != 0x493D) && (device != 0x5348))) {
 	        DisableIOPorts(NUMPORTS, Ports);
 	        continue;
 	    }
Index: xc/programs/Xserver/hw/xfree86/SuperProbe/Imakefile
diff -u xc/programs/Xserver/hw/xfree86/SuperProbe/Imakefile:3.23.2.4 xc/programs/Xserver/hw/xfree86/SuperProbe/Imakefile:3.23.2.6
--- xc/programs/Xserver/hw/xfree86/SuperProbe/Imakefile:3.23.2.4	Mon Oct 19 06:41:59 1998
+++ xc/programs/Xserver/hw/xfree86/SuperProbe/Imakefile	Tue Dec 22 22:23:13 1998
@@ -4,9 +4,9 @@
 
 
 
-XCOMM $XFree86: xc/programs/Xserver/hw/xfree86/SuperProbe/Imakefile,v 3.23.2.4 1998/10/18 20:41:59 hohndel Exp $
+XCOMM $XFree86: xc/programs/Xserver/hw/xfree86/SuperProbe/Imakefile,v 3.23.2.6 1998/12/22 11:23:13 hohndel Exp $
 
-#if defined(SVR3Architecture) || defined(SVR4Architecture) || defined(SCOArchitecture)
+#if (defined(SVR3Architecture) || defined(SVR4Architecture) || defined(SCOArchitecture)) && !defined(DguxArchitecture)
 # define OSModule OS_SYSV
 #endif
 
@@ -14,6 +14,10 @@
 # include <Server.tmpl>
 #endif
 
+#if defined(DguxArchitecture)
+# define OSModule OS_DGUX
+#endif
+
 #if defined(SVR4Architecture) && defined(SunArchitecture) && !HasGcc
   OS_IO_SRC = SolX86IO.s
   OS_IO_OBJ = SolX86IO.o
@@ -35,8 +39,13 @@
 # define OSModule OS_Minix
 #endif
 #if defined(i386MachArchitecture)
+#if defined(GNUMachArchitecture)
+   SYS_LIBRARIES = 
+# define OSModule OS_GNUmach
+#else
    SYS_LIBRARIES = /usr/lib/libmach.a
 # define OSModule OS_Mach
+#endif
 #endif
 #if defined(OS2Architecture)
 # define OSModule OS_Os2
Index: xc/programs/Xserver/hw/xfree86/SuperProbe/Main.c
diff -u xc/programs/Xserver/hw/xfree86/SuperProbe/Main.c:3.17.2.9 xc/programs/Xserver/hw/xfree86/SuperProbe/Main.c:3.17.2.10
--- xc/programs/Xserver/hw/xfree86/SuperProbe/Main.c:3.17.2.9	Tue Oct 27 16:19:53 1998
+++ xc/programs/Xserver/hw/xfree86/SuperProbe/Main.c	Fri Dec 18 22:56:20 1998
@@ -28,7 +28,7 @@
  *
  */
 
-/* $XFree86: xc/programs/Xserver/hw/xfree86/SuperProbe/Main.c,v 3.17.2.9 1998/10/27 05:19:53 dawes Exp $ */
+/* $XFree86: xc/programs/Xserver/hw/xfree86/SuperProbe/Main.c,v 3.17.2.10 1998/12/18 11:56:20 dawes Exp $ */
 
 #include "Probe.h"
 #include "PatchLevel.h"
@@ -550,16 +550,20 @@
 #endif
     if (f != (FILE *)NULL)
     {
+#if !defined(DGUX)  /* It craches SuperProbe in DG/ux */
         putc('\007', f);
         putc('\007', f);
         putc('\007', f);
+#endif
         fprintf(f, "WARNING - THIS SOFTWARE COULD HANG YOUR MACHINE.\n");
         fprintf(f, "          READ THE SuperProbe.1 MANUAL PAGE BEFORE\n");
         fprintf(f, "          RUNNING THIS PROGRAM.\n\n");
         fprintf(f, "          INTERRUPT WITHIN FIVE SECONDS TO ABORT!\n\n");
+#if !defined(DGUX)  /* It craches SuperProbe in DG/ux */
         putc('\007', f);
         putc('\007', f);
         putc('\007', f);
+#endif
         fflush(f);
         sleep(5);
     }
Index: xc/programs/Xserver/hw/xfree86/SuperProbe/Matrox.c
diff -u xc/programs/Xserver/hw/xfree86/SuperProbe/Matrox.c:3.2.2.4 xc/programs/Xserver/hw/xfree86/SuperProbe/Matrox.c:3.2.2.5
--- xc/programs/Xserver/hw/xfree86/SuperProbe/Matrox.c:3.2.2.4	Sat Aug  2 23:48:08 1997
+++ xc/programs/Xserver/hw/xfree86/SuperProbe/Matrox.c	Tue Dec 22 22:23:14 1998
@@ -1,4 +1,4 @@
-/* $XFree86: xc/programs/Xserver/hw/xfree86/SuperProbe/Matrox.c,v 3.2.2.4 1997/08/02 13:48:08 dawes Exp $ */
+/* $XFree86: xc/programs/Xserver/hw/xfree86/SuperProbe/Matrox.c,v 3.2.2.5 1998/12/22 11:23:14 hohndel Exp $ */
 /*
  * (c) Copyright 1997 Alan Hourihane <alanh@fairlite.demon.co.uk>
  *
@@ -73,6 +73,21 @@
 				break;
 			case PCI_CHIP_MGA2085PX:
 				*Chipset = CHIP_MGA2085PX;
+				break;
+			case PCI_CHIP_MGA2164W_AGP:
+				*Chipset = CHIP_MGA2164WAGP;
+				break;
+			case PCI_CHIP_MGAG100_PCI:
+				*Chipset = CHIP_MGAG100PCI;
+				break;
+			case PCI_CHIP_MGAG100_AGP:
+				*Chipset = CHIP_MGAG100AGP;
+				break;
+			case PCI_CHIP_MGAG200_PCI:
+				*Chipset = CHIP_MGAG200PCI;
+				break;
+			case PCI_CHIP_MGAG200_AGP:
+				*Chipset = CHIP_MGAG200AGP;
 				break;
 			default:
 				Chip_data = chip;
Index: xc/programs/Xserver/hw/xfree86/SuperProbe/OS_DGUX.c
diff -u /dev/null xc/programs/Xserver/hw/xfree86/SuperProbe/OS_DGUX.c:1.1.2.1
--- /dev/null	Wed Jan  6 00:30:26 1999
+++ xc/programs/Xserver/hw/xfree86/SuperProbe/OS_DGUX.c	Fri Dec 18 22:56:20 1998
@@ -0,0 +1,243 @@
+/* $XFree86: xc/programs/Xserver/hw/xfree86/SuperProbe/OS_DGUX.c,v 1.1.2.1 1998/12/18 11:56:20 dawes Exp $ */
+/*
+ * INTEL DG/UX RELEASE 4.20 MU03
+ * Copyright Takis Psarogiannakopoulos
+ * e-mail <takis@pmms.cam.ac.uk>
+ *
+ * Permission to use, copy, modify, distribute, and sell this software and its
+ * documentation for any purpose is hereby granted without fee, provided that
+ * the above copyright notice appear in all copies and that both that
+ * copyright notice and this permission notice appear in supporting
+ * documentation.
+ * XCONSORTIUM DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE.
+ * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ * FITNESS, IN NO EVENT SHALL XCONSORTIUM BE LIABLE FOR
+ * ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER
+ * RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF
+ * CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ *
+ */
+
+
+#include "Probe.h"
+#include <fcntl.h>
+#include <sys/types.h>
+#include <sys/param.h>
+#include <sys/kd.h>
+#include <sys/proc.h>
+#include <sys/mman.h>
+#define DEV_MEM	"/dev/mem"
+
+int Takis_fd;
+static int BIOS_fd = -1;
+
+/*
+ * OpenVideo --
+ */
+int OpenVideo()
+{
+        int fd;
+        char takis[20];
+
+        if (geteuid() != 0)
+        {
+                fprintf(stderr,
+                        "%s: Must be run as root or installed suid-root\n",
+                        MyName);
+                return(-1);
+        }
+        if ((fd = open("/dev/console", O_RDWR, 0)) < 0)
+        {
+                fprintf(stderr, "%s: Cannot open /dev/console\n",
+                        MyName);
+                return(-1);
+        }
+        close(fd);
+        sprintf(takis, "/dev/console");
+
+        if ((Takis_fd = open(takis, O_RDWR|O_NDELAY, 0)) < 0)
+        {
+                fprintf(stderr, "%s: Could not open system Console \n",
+                        MyName);
+                return(-1);
+        }
+
+        if (ioctl(Takis_fd, KDENABIO, 0) < 0)
+        {
+                 perror("ioctl()");
+                 close(Takis_fd);
+                 Takis_fd = -1;
+                 return(-1);
+        }
+
+    return(Takis_fd);
+}
+
+
+/*
+ * CloseVideo --
+ *
+ * Disable access to the video hardware, ie Close system console,
+ * and re-enable IO protection.
+ */
+void CloseVideo()
+{
+    if (Takis_fd>0)
+    {
+      ioctl(Takis_fd,KDDISABIO,0); /* Call RESET_IOPL for disable I/O to ports */
+      close(Takis_fd);
+      Takis_fd= -1;
+
+    }
+
+}
+
+
+/*
+ * MapVGA --
+ */
+Byte *MapVGA()
+{
+        int fd;
+        Byte *base;
+
+        if ((fd = open(DEV_MEM, O_RDWR)) < 0)
+        {
+                fprintf(stderr, "%s: Failed to open %s\n", MyName, DEV_MEM);
+                return((Byte *)0);
+        }
+        base = (Byte *)mmap((caddr_t)0, 0x10000, PROT_READ|PROT_WRITE,
+                            MAP_SHARED, fd, (off_t)0xA0000);
+        close(fd);
+        if ((long)base == -1)
+        {
+                fprintf(stderr, "%s: Failed to mmap framebuffer\n", MyName);
+                return((Byte *)0);
+        }
+        return(base);
+}
+
+
+Byte *MapMem(address,size)
+	unsigned long address;
+	unsigned long size;
+{
+	return((Byte*)0);
+}
+
+
+/*
+ * UnMapVGA --
+ *
+ * Unmap the VGA memory window.
+ */
+void UnMapVGA(base)
+Byte *base;
+{
+   munmap((caddr_t)base, 0x10000);
+   return;
+}
+
+
+void UnMapMem(base,size)
+	Byte *base;
+	unsigned long size;
+{
+	return;
+}
+
+/*
+ * ReadBIOS --
+ *
+ * Read 'Len' bytes from the video BIOS at address 'Bios_Base'+'Offset' into
+ * buffer 'Buffer'.
+ */
+int ReadBIOS(Offset, Buffer, Len)
+unsigned Offset;
+Byte *Buffer;
+int Len;
+{
+        Byte *Base = Bios_Base + Offset;
+        Word *tmp;
+        Byte *ptr;
+        unsigned long page_offset = (unsigned long)Base & 0xFFF;
+        unsigned long mmap_base = (unsigned long)Base & ~0xFFF;
+        unsigned long mmap_len = Len + page_offset;
+
+        if (BIOS_fd == -1)
+        {
+                if ((BIOS_fd = open(DEV_MEM, O_RDONLY, 0)) < 0)
+                {
+                        fprintf(stderr, "%s: cannot open %s\n",
+                                MyName, DEV_MEM);
+                        return(-1);
+                }
+        }
+        if ((off_t)((off_t)Base & 0x7FFF) != (off_t)0)
+        {
+                tmp = (Word *)mmap((caddr_t)0, 0x1000, PROT_READ, MAP_SHARED,
+                                   BIOS_fd, (off_t)((off_t)Base & 0xF8000));
+                if ((int)tmp == -1)
+                {
+                        fprintf(stderr, "%s: Failed to mmap() %s, addr=%x\n",
+                                MyName, DEV_MEM, (int)Base);
+                        return(-1);
+                }
+                if (*tmp != (Word)0xAA55)
+                {
+                        fprintf(stderr,
+                                "%s: BIOS sanity check failed, addr=%x\n",
+                                MyName, (int)Base);
+                        return(-1);
+                }
+                (void)munmap((caddr_t)tmp, 0x1000);
+        }
+        ptr = (Byte *)mmap((caddr_t)0, mmap_len, PROT_READ, MAP_SHARED,
+                           BIOS_fd, (off_t)mmap_base);
+        if ((int)ptr == -1)
+        {
+                fprintf(stderr, "%s: Failed to mmap() %s, addr=%x\n",
+                        MyName, DEV_MEM, (int)Base);
+                return(-1);
+        }
+        (void)memcpy((void *)Buffer, (void *)(ptr + page_offset), Len);
+        (void)munmap((caddr_t)ptr, mmap_len);
+        return(Len);
+}
+
+
+/*
+ * EnableIOPort --
+ */
+/*ADDED FOR INTEL DG/ux */
+int EnableIOPorts(NumPorts, Ports)
+CONST int NumPorts;
+CONST Word *Ports;
+{
+	return(0);
+}
+
+/*
+ * DisableIOPort --
+ */
+
+/*ADDED FOR INTEL DG/ux */
+int DisableIOPorts(NumPorts, Port)
+CONST int NumPorts;
+CONST Word *Port;
+{
+	return(0);
+}
+
+/*
+ * ShortSleep --
+ */
+
+/*ADDED FOR INTEL DG/ux */
+void ShortSleep(Delay)
+int Delay;
+{
+        usleep(Delay * 1000);
+}
+
Index: xc/programs/Xserver/hw/xfree86/SuperProbe/OS_GNUmach.c
diff -u /dev/null xc/programs/Xserver/hw/xfree86/SuperProbe/OS_GNUmach.c:1.1.2.1
--- /dev/null	Wed Jan  6 00:30:26 1999
+++ xc/programs/Xserver/hw/xfree86/SuperProbe/OS_GNUmach.c	Tue Dec 22 23:20:11 1998
@@ -0,0 +1,247 @@
+/* $XFree86: xc/programs/Xserver/hw/xfree86/SuperProbe/OS_GNUmach.c,v 1.1.2.1 1998/12/22 12:20:11 hohndel Exp $ */
+/*
+ * (c) Copyright 1993,1994 by Robert V. Baron 
+ *			<Robert.Baron@ernst.mach.cs.cmu.edu>
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a 
+ * copy of this software and associated documentation files (the "Software"), 
+ * to deal in the Software without restriction, including without limitation 
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense, 
+ * and/or sell copies of the Software, and to permit persons to whom the 
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ * 
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL 
+ * ROBERT V. BARON  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, 
+ * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF 
+ * OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE 
+ * SOFTWARE.
+ * 
+ * Except as contained in this notice, the name of Robert V. Baron shall not be
+ * used in advertising or otherwise to promote the sale, use or other dealings
+ * in this Software without prior written authorization from Robert V. Baron.
+ *
+ */
+/* $XConsortium: OS_Mach.c /main/5 1996/02/21 17:11:12 kaleb $ */
+/* GNU/Hurd port by UCHIYAMA Yasushi */
+#define _GNU_SOURCE
+#define MACH3
+#include<hurd.h>
+#include<device/device.h>
+
+#include "Probe.h"
+
+#include <fcntl.h>
+#include <sys/ioctl.h>
+#include <errno.h>
+
+/* These can be Mach 2.5 or 3.0 headers */
+#include <mach.h>
+#include <mach_error.h>
+#include <mach/message.h>
+
+static device_t device_master = MACH_PORT_NULL;
+static int iopl_dev = MACH_PORT_NULL;
+static memory_object_t iopl_mem = MACH_PORT_NULL;
+static vm_address_t mapped_address;
+
+/*
+ * OpenVideo --
+ *
+ * Enable access to the installed video hardware.  For Mach, we disable
+ * IO protection, since this is currently the only way to access any
+ * IO registers.
+ */
+int screen_addr;
+
+int OpenVideo()
+{
+  int ret;
+#define C /*Bios_Base*/ 0xc0000
+#define S 0x40000
+  if(KERN_SUCCESS != get_privileged_ports(0,&device_master)){
+    fprintf(stderr,"Failed get_privileged_ports\n");
+    return -1;
+  }
+  if (KERN_SUCCESS != device_open(device_master,D_READ|D_WRITE,"iopl",&iopl_dev)){
+    fprintf(stderr, "Failed to device_open iopl\n");
+    return -1;
+  }
+  if(KERN_SUCCESS != device_map(iopl_dev,VM_PROT_READ|VM_PROT_WRITE, C , S ,&iopl_mem,0)){
+    fprintf(stderr, "Failed to device_map\n");
+    return -1;
+  }
+  if(KERN_SUCCESS != vm_map(mach_task_self(),
+			    &mapped_address,S,
+			    0,1,iopl_mem,C,0,VM_PROT_READ|VM_PROT_WRITE,
+			    VM_PROT_READ|VM_PROT_WRITE,VM_INHERIT_NONE)){
+    fprintf(stderr,"Failed to vm_map\n");
+    return -1;
+  }
+
+  screen_addr = (int)mapped_address;
+
+  return TRUE;
+
+}
+
+/*
+ * CloseVideo --
+ *
+ * Disable access to the video hardware.  For Mach, we re-enable
+ * IO protection.
+ */
+void CloseVideo()
+{
+	if (KERN_SUCCESS != vm_deallocate(mach_task_self(), screen_addr, S)) {
+		fprintf(stderr, "Failed vmdeallocate %x\n", S);
+	}
+
+}
+
+/*
+ * MapVGA --
+ *
+ * Map the VGA memory window (0xA0000-0xAFFFF) as read/write memory for
+ * the process for use in probing memory.
+ */
+Byte *MapVGA()
+{
+        return((Byte *)0);
+}
+
+Byte *MapMem(address,size)
+	unsigned long address;
+	unsigned long size;
+{
+	return((Byte *)0);
+}
+
+/*
+ * UnMapVGA --
+ *
+ * Unmap the VGA memory window.
+ */
+void UnMapVGA(base)
+Byte *base;
+{
+	return;
+}
+
+void UnMapMem(base,size)
+Byte *base;
+unsigned long size;
+{
+	return;
+}
+
+/*
+ * ReadBIOS --
+ *
+ * Read 'Len' bytes from the video BIOS at address 'Bios_Base'+'Offset' into 
+ * buffer 'Buffer'.
+ */
+int ReadBIOS(Offset, Buffer, Len)
+unsigned Offset;
+Byte *Buffer;
+int Len;
+{
+	Word tmp;
+	Byte *Base;
+
+	Base = (Byte *)(screen_addr + Bios_Base + Offset - C);
+#ifdef DEBUG
+	{int i;
+		fprintf(stderr, "ReadBIOS(Offset %x, Buffer %x, Len %x) .. ",
+			Offset, Buffer, Len);
+		for (i=0;i<Len;i++)
+			fprintf(stderr," [%c](%x)|", *(Base+i), *(Base+i));
+		fprintf(stderr,"\n");
+	}
+#endif
+	bcopy(Base, Buffer, Len);
+	return (Len);
+}
+
+/*
+ * EnableIOPort --
+ *
+ * Enable access to 'NumPorts' IO ports listed in array 'Ports'.  For Mach, 
+ * we've disabled IO protections so this is a no-op.
+ */
+/*ARGSUSED*/
+int EnableIOPorts(NumPorts, Ports)
+CONST int NumPorts;
+CONST Word *Ports;
+{
+	return(0);
+}
+
+/*
+ * DisableIOPort --
+ *
+ * Disable access to 'NumPorts' IO ports listed in array  'Ports'.  For Mach, 
+ * we've disabled IO protections so this is a no-op.
+ */
+/*ARGSUSED*/
+int DisableIOPorts(NumPorts, Port)
+CONST int NumPorts;
+CONST Word *Port;
+{
+	return(0);
+}
+
+/*
+ * ShortSleep --
+ *
+ * Sleep for the number of milliseconds specified in 'Delay'.
+ */
+void ShortSleep(Delay)
+int Delay;
+{
+#ifdef MACH3
+	struct trial {
+		mach_msg_header_t	h;
+		mach_msg_type_t	t;
+		int		d;
+	} msg_rcv;
+	mach_port_t		my_port;
+#else
+	/* This does Mach 2.5 IPC */	
+	struct trial {
+		msg_header_t	h;
+		msg_type_t	t;
+		int		d;
+	} msg_rcv;
+	port_t		my_port;
+#endif
+	kern_return_t	error;
+	int		ret;
+
+	if ((error = mach_port_allocate(mach_task_self(),MACH_PORT_RIGHT_PORT_SET,&my_port)) != KERN_SUCCESS) {
+		printf("ShortSleep: mach_port_allocate failed with %d: %s\n", 
+			error, mach_error_string(error));
+		return;
+	}
+	
+#ifdef MACH3
+	msg_rcv.h.msgh_size = sizeof(msg_rcv);
+	if ((ret = mach_msg_receive(&msg_rcv.h, MACH_RCV_TIMEOUT,	Delay)) != MACH_RCV_TIMED_OUT) {
+#else
+	if ((ret = mach_msg_receive(&msg_rcv.h, RCV_TIMEOUT,	Delay)) != RCV_TIMED_OUT) {
+	msg_rcv.h.msg_local_port = my_port;
+#endif
+		mach_error("ShortSleep: mach_msg_receive returned ", ret);
+		return;
+	}
+
+	if ((error = mach_port_deallocate(mach_task_self(), my_port)) != KERN_SUCCESS) {
+		printf("ShortSleep: port_deallocate failed with %d: %s\n", 
+			error, mach_error_string(error));
+		return;
+	}
+}
Index: xc/programs/Xserver/hw/xfree86/SuperProbe/PCI.h
diff -u xc/programs/Xserver/hw/xfree86/SuperProbe/PCI.h:3.17.2.10 xc/programs/Xserver/hw/xfree86/SuperProbe/PCI.h:3.17.2.11
--- xc/programs/Xserver/hw/xfree86/SuperProbe/PCI.h:3.17.2.10	Mon Oct 26 01:15:11 1998
+++ xc/programs/Xserver/hw/xfree86/SuperProbe/PCI.h	Tue Dec 22 22:23:14 1998
@@ -1,4 +1,4 @@
-/* $XFree86: xc/programs/Xserver/hw/xfree86/SuperProbe/PCI.h,v 3.17.2.10 1998/10/25 14:15:11 hohndel Exp $ */ 
+/* $XFree86: xc/programs/Xserver/hw/xfree86/SuperProbe/PCI.h,v 3.17.2.11 1998/12/22 11:23:14 hohndel Exp $ */ 
 /*
  * PCI Probe
  *
@@ -234,6 +234,11 @@
 #define PCI_CHIP_MGA2064W	0x0519
 #define PCI_CHIP_MGA1064SG	0x051A
 #define PCI_CHIP_MGA2164W	0x051B
+#define PCI_CHIP_MGA2164W_AGP	0x051F
+#define PCI_CHIP_MGAG100_PCI	0x1000
+#define PCI_CHIP_MGAG100_AGP	0x1001
+#define PCI_CHIP_MGAG200_PCI	0x0520
+#define PCI_CHIP_MGAG200_AGP	0x0521
 
 /* ATI */
 #define PCI_CHIP_MACH32		0x4158
Index: xc/programs/Xserver/hw/xfree86/SuperProbe/PatchLevel.h
diff -u xc/programs/Xserver/hw/xfree86/SuperProbe/PatchLevel.h:3.20.2.5 xc/programs/Xserver/hw/xfree86/SuperProbe/PatchLevel.h:3.20.2.6
--- xc/programs/Xserver/hw/xfree86/SuperProbe/PatchLevel.h:3.20.2.5	Thu Oct 22 14:31:01 1998
+++ xc/programs/Xserver/hw/xfree86/SuperProbe/PatchLevel.h	Tue Dec 22 22:23:15 1998
@@ -26,10 +26,10 @@
  *
  */
 
-/* $XFree86: xc/programs/Xserver/hw/xfree86/SuperProbe/PatchLevel.h,v 3.20.2.5 1998/10/22 04:31:01 hohndel Exp $ */
+/* $XFree86: xc/programs/Xserver/hw/xfree86/SuperProbe/PatchLevel.h,v 3.20.2.6 1998/12/22 11:23:15 hohndel Exp $ */
 
 #define VERSION 	2
-#define PATCHLEV 	17
-#define RELDATE		"22 October 1998"
+#define PATCHLEV 	18
+#define RELDATE		"22 December 1998"
 #define PRINT_VERSION	printf("\n%s Version %d.%d (%s)\n", \
 				MyName,VERSION,PATCHLEV,RELDATE)
Index: xc/programs/Xserver/hw/xfree86/SuperProbe/Print.c
diff -u xc/programs/Xserver/hw/xfree86/SuperProbe/Print.c:3.46.2.15 xc/programs/Xserver/hw/xfree86/SuperProbe/Print.c:3.46.2.16
--- xc/programs/Xserver/hw/xfree86/SuperProbe/Print.c:3.46.2.15	Mon Oct 26 01:15:13 1998
+++ xc/programs/Xserver/hw/xfree86/SuperProbe/Print.c	Tue Dec 22 22:23:15 1998
@@ -26,7 +26,7 @@
  *
  */
 
-/* $XFree86: xc/programs/Xserver/hw/xfree86/SuperProbe/Print.c,v 3.46.2.15 1998/10/25 14:15:13 hohndel Exp $ */
+/* $XFree86: xc/programs/Xserver/hw/xfree86/SuperProbe/Print.c,v 3.46.2.16 1998/12/22 11:23:15 hohndel Exp $ */
 
 #include "Probe.h"
 
@@ -202,7 +202,12 @@
 		  "Matrox Atlas",
 		  "Matrox Millennium",
 		  "Matrox Mystique",
-		  "Matrox Millennium II" },
+		  "Matrox Millennium II",
+		  "Matrox Millennium II AGP",
+		  "Matrox G100 PCI",
+		  "Matrox G100 AGP",
+		  "Matrox G200 PCI",
+		  "Matrox G200 AGP" },
 /* Sigma Designs */	{ "Sigma Designs (chipset unknown)",
 		  "Sigma Designs REALmagic64/GX (SD 6425)" },
 /* Intergraphcis */	{ "Intergraphics (chipset unknown)",
@@ -291,6 +296,10 @@
 	  "ICS5301 GENDAC 15/16/24-bit DAC w/clock-PLL" },
 	{ "MGA1064SG",
 	  "Matrox Mystique built-in DAC w/clock" },
+	{ "MGAG100",
+	  "Matrox G100 built-in DAC w/clock" },
+	{ "MGAG200",
+	  "Matrox G200 built-in DAC w/clock" },
 };
 
 static CONST char *CoProc_Names[NUM_CP_TYPES][CHPS_PER_CPTYPE] = 
Index: xc/programs/Xserver/hw/xfree86/SuperProbe/Probe.h
diff -u xc/programs/Xserver/hw/xfree86/SuperProbe/Probe.h:3.45.2.16 xc/programs/Xserver/hw/xfree86/SuperProbe/Probe.h:3.45.2.17
--- xc/programs/Xserver/hw/xfree86/SuperProbe/Probe.h:3.45.2.16	Mon Oct 26 01:15:14 1998
+++ xc/programs/Xserver/hw/xfree86/SuperProbe/Probe.h	Tue Dec 22 22:23:16 1998
@@ -26,7 +26,7 @@
  *
  */
 
-/* $XFree86: xc/programs/Xserver/hw/xfree86/SuperProbe/Probe.h,v 3.45.2.16 1998/10/25 14:15:14 hohndel Exp $ */
+/* $XFree86: xc/programs/Xserver/hw/xfree86/SuperProbe/Probe.h,v 3.45.2.17 1998/12/22 11:23:16 hohndel Exp $ */
 
 /*
  * Includes
@@ -347,8 +347,10 @@
 #define DAC_ICS5341	52	/* ICS5341 16-bit SDAC-like DAC used on ET4000W32p */
 #define DAC_ICS5301	53	/* ICS5301 8-bit GENDAC-like DAC used on ET4000W32 */
 #define DAC_MGA1064SG	54	/* Matrox Mystique integrated DAC */
+#define DAC_MGAG100	55	/* Matrox G100 integrated DAC */
+#define DAC_MGAG200	56	/* Matrox G200 integrated DAC */
 
-#define DAC_MAX		DAC_MGA1064SG	/* UPDATE THIS! */
+#define DAC_MAX		DAC_MGAG200	/* UPDATE THIS! */
 
 #define DAC_6_8_PROGRAM	0x40	/* RAMDAC programmable for 6/8-bit tables */
 #define DAC_8BIT	0x80	/* RAMDAC with 8-bit wide lookup tables */
@@ -629,6 +631,11 @@
 #define CHIP_MGA2064W	SVGA_TYPE(V_MATROX,2)	/* Matrox Millennium	*/
 #define CHIP_MGA1064SG	SVGA_TYPE(V_MATROX,3)	/* Matrox Mystique	*/
 #define CHIP_MGA2164W	SVGA_TYPE(V_MATROX,4)	/* Matrox Millennium II	*/
+#define CHIP_MGA2164WAGP SVGA_TYPE(V_MATROX,5)	/* Matrox Millennium II AGP */
+#define CHIP_MGAG100PCI	SVGA_TYPE(V_MATROX,6)	/* Matrox G100 PCI	*/
+#define CHIP_MGAG100AGP	SVGA_TYPE(V_MATROX,7)	/* Matrox G100 AGP	*/
+#define CHIP_MGAG200PCI	SVGA_TYPE(V_MATROX,8)	/* Matrox G200 PCI	*/
+#define CHIP_MGAG200AGP	SVGA_TYPE(V_MATROX,9)	/* Matrox G200 AGP	*/
 #define CHIP_TSENG_UNK	SVGA_TYPE(V_TSENG,0)	/* Tseng unknown	*/
 #define CHIP_ET3000	SVGA_TYPE(V_TSENG,1)	/* Tseng ET3000		*/
 #define CHIP_ET4000	SVGA_TYPE(V_TSENG,2)	/* Tseng ET4000		*/
Index: xc/programs/Xserver/hw/xfree86/SuperProbe/RamDac.c
diff -u xc/programs/Xserver/hw/xfree86/SuperProbe/RamDac.c:3.26.2.7 xc/programs/Xserver/hw/xfree86/SuperProbe/RamDac.c:3.26.2.8
--- xc/programs/Xserver/hw/xfree86/SuperProbe/RamDac.c:3.26.2.7	Sat Aug  2 23:48:10 1997
+++ xc/programs/Xserver/hw/xfree86/SuperProbe/RamDac.c	Tue Dec 22 22:23:16 1998
@@ -30,7 +30,7 @@
  * 
  */
 
-/* $XFree86: xc/programs/Xserver/hw/xfree86/SuperProbe/RamDac.c,v 3.26.2.7 1997/08/02 13:48:10 dawes Exp $ */
+/* $XFree86: xc/programs/Xserver/hw/xfree86/SuperProbe/RamDac.c,v 3.26.2.8 1998/12/22 11:23:16 hohndel Exp $ */
 
 #include "Probe.h"
 
@@ -1158,10 +1158,14 @@
 			*RamDac = DAC_BT485;
 		if (Chipset == CHIP_MGA2064W)
 			*RamDac = DAC_TVP3026;
-		if (Chipset == CHIP_MGA2164W)
+		if ((Chipset == CHIP_MGA2164W)||(Chipset == CHIP_MGA2164WAGP))
 			*RamDac = DAC_TVP3026;
 		if (Chipset == CHIP_MGA1064SG)
 			*RamDac = DAC_MGA1064SG;
+		if ((Chipset == CHIP_MGAG100PCI)||(Chipset == CHIP_MGAG100AGP))
+			*RamDac = DAC_MGAG100;
+		if ((Chipset == CHIP_MGAG200PCI)||(Chipset == CHIP_MGAG200AGP))
+			*RamDac = DAC_MGAG200;
 		DisableIOPorts(NUMPORTS, Ports);
 		return;
 	}
Index: xc/programs/Xserver/hw/xfree86/XF86Setup/carddata.tcl
diff -u xc/programs/Xserver/hw/xfree86/XF86Setup/carddata.tcl:3.12.2.14 xc/programs/Xserver/hw/xfree86/XF86Setup/carddata.tcl:3.12.2.16
--- xc/programs/Xserver/hw/xfree86/XF86Setup/carddata.tcl:3.12.2.14	Sat Nov 14 20:20:44 1998
+++ xc/programs/Xserver/hw/xfree86/XF86Setup/carddata.tcl	Thu Dec 24 00:36:25 1998
@@ -3,7 +3,7 @@
 #
 #
 #
-# $XFree86: xc/programs/Xserver/hw/xfree86/XF86Setup/carddata.tcl,v 3.12.2.14 1998/11/14 09:20:44 dawes Exp $
+# $XFree86: xc/programs/Xserver/hw/xfree86/XF86Setup/carddata.tcl,v 3.12.2.16 1998/12/23 13:36:25 hohndel Exp $
 #
 # Copyright 1996 by Joseph V. Moss <joe@XFree86.Org>
 #
@@ -68,12 +68,15 @@
 set CardChipSets(SVGA-s3v)	s3_virge
 set CardChipSets(SVGA-sis)	{ sis86c201 sis86c202 sis86c205 sis86c215 \
 				  sis86c225 sis5597 sis5598 sis6326 }
-set CardChipSets(SVGA-tvga8900)	{ tvga8200lx tvga8800cs tvga8900b tvga8900c \
-				  tvga8900cl tvga8900d tvga9000 tvga9000i \
-				  tvga9100b tvga9200cxr \
-				  tgui9320lcd tgui9400cxi tgui9420 \
-				  tgui9420dgi tgui9430dgi tgui9440agi \
-				  tgui96xx cyber938x }
+set CardChipSets(SVGA-tvga8900)	{ tvga8200lx tvga8800cs tvga8900b \
+                                  tvga8900c tvga8900cl tvga8900d tvga9000 \
+                                  tvga9000i tvga9100b tvga9200cxr \
+                                  tgui9400cxi tgui9420 tgui9420dgi tgui9430dgi \
+                                  tgui9440agi cyber9320 tgui9660 tgui9680 \
+				  tgui9682 tgui9685 cyber9382 cyber9385 \
+                                  cyber9388 cyber9397 cyber9520 \
+                                  3dimage975 3dimage985 }
+
 set CardChipSets(SVGA-video7)	video7
 set CardChipSets(SVGA-neo)	{ NM2070 NM2090 NM2093 NM2097 NM2160 NM2200 }
 set chiplist ""
@@ -147,8 +150,9 @@
 set CardChipSets(WSNA)	   { clgd5426 clgd5428 clgd5429 clgd5430 \
 			     clgd5434 clgd5440 clgd5446 clgd7543 \
 			     clgd7548 clgd7555 }
-set CardChipSets(TGUI)	   { tgui9660xgi tgui9680 cyber938x }
-set CardChipSets(MGA)	   { }
+set CardChipSets(TGUI)	   { cyber9320 cyber9382 cyber9385 \
+		             tgui9660 tgui9680 tgui9682 tgui9685 3dimage975 }
+set CardChipSets(MGA)	   { mga2064w mga1064sg }
 set CardChipSets(NECS3)	   { s3_generic mmio_928 }
 set CardChipSets(PWSKB)	   { s3_generic mmio_928 }
 set CardChipSets(PWLB)	   { mmio_928 s3_generic }
@@ -325,14 +329,14 @@
 			     enable_bitblt epsonmemwin extern_disp \
 			     fast_dram favour_bitblt favor_bitblt \
 			     fb_debug fifo_aggressive fifo_conservative \
-			     first_wwait ga98nb1 ga98nb2 ga98nb4 \
+			     first_wwait \
 			     hibit_high hibit_low hw_clocks hw_cursor \
 			     intern_disp lcd_center lcd_stretch \
 			     legend linear med_dram mmio nec_cirrus \
 			     noaccel nolinear no_2mb_banksel no_bitblt \
 			     no_imageblt no_pci_probe no_pixmap_cache \
 			     no_program_clocks \
-			     no_wait one_wait pc98_tgui pci_burst_off \
+			     no_wait one_wait pci_burst_off \
 			     pci_burst_on pci_retry power_saver probe_clocks \
 			     read_wait secondary \
 			     slow_dram swap_hibit sw_cursor tgui_mclk_66 \
@@ -350,7 +354,7 @@
 			     linear med_dram \
 			     mmio noaccel nolinear no_pci_probe \
 			     no_program_clocks no_wait one_wait \
-			     pc98_tgui pci_burst_off pci_burst_on pci_retry \
+			     pci_burst_off pci_burst_on pci_retry \
 			     power_saver probe_clocks read_wait \
 			     secondary \
 			     slow_dram tgui_mclk_66 \
@@ -368,8 +372,7 @@
 			     favor_bitblt fb_debug fifo_aggressive \
 			     fifo_conservative fifo_moderate \
 			     first_wwait fix_panel_size \
-			     fpm_vram ga98nb1 \
-			     ga98nb2 ga98nb4 hibit_high hibit_low \
+			     fpm_vram hibit_high hibit_low \
 			     hw_clocks hw_cursor intern_disp \
 			     late_ras_precharge lcd_center \
 			     lcd_centre legend linear \
@@ -377,7 +380,7 @@
 			     no_2mb_banksel no_bitblt no_imageblt \
 			     no_pci_probe no_pixmap_cache \
 			     no_program_clocks no_stretch no_wait \
-			     one_wait pc98_tgui pci_burst_off\
+			     one_wait pci_burst_off\
 			     pci_burst_on pci_retry power_saver probe_clocks \
 			     read_wait slow_edoram slow_dram stn suspend_hack \
 			     swap_hibit sw_cursor sync_on_green \
@@ -450,19 +453,27 @@
 set CardOptions(EGC)		{}
 set CardOptions(NEC480)		{}
 set CardOptions(GANBWAP)	{ ga98nb1 ga98nb2 ga98nb4 wap epsonmemwin \
-				  sw_cursor }
-set CardOptions(NKVNEC)		{ nec_cirrus }
-set CardOptions(WABS)		{}
-set CardOptions(WABEP)		{ med_dram }
-set CardOptions(WSNA)		{ epsonmemwin sw_cursor med_dram }
-set CardOptions(TGUI)		{ noaccel }
-set CardOptions(MGA)		{ noaccel }
-set CardOptions(NECS3)		{ necwab nomemaccess dac_8_bit bt485_curs }
+				  sw_cursor power_saver \
+			          xaa_benchmark xaa_no_color_exp }
+set CardOptions(NKVNEC)		{ nec_cirrus power_saver sw_cursor \
+			          xaa_benchmark xaa_no_color_exp }
+set CardOptions(WABS)		{ power_saver sw_cursor xaa_benchmark }
+set CardOptions(WABEP)		{ med_dram power_saver sw_cursor \
+			          xaa_benchmark xaa_no_color_exp }
+set CardOptions(WSNA)		{ epsonmemwin sw_cursor med_dram power_saver \
+				  xaa_benchmark xaa_no_color_exp }
+set CardOptions(TGUI)		{ noaccel power_saver sw_cursor \
+			          xaa_benchmark xaa_no_color_exp }
+set CardOptions(MGA)		{ noaccel power_saver sw_cursor \
+			          xaa_benchmark xaa_no_color_exp }
+set CardOptions(NECS3)		{ necwab nomemaccess dac_8_bit bt485_curs \
+				  power_saver sw_cursor }
 set CardOptions(PWSKB)		{ pcskb pcskb4 pchkb pw805i pw_mux \
 				  nomemaccess epsonmemwin dac_8_bit \
-				  bt485_curs }
-set CardOptions(PWLB)		{ pw_localbus dac_8_bit bt485_curs numbernine }
-set CardOptions(GA968)		{}
+				  bt485_curs power_saver sw_cursor }
+set CardOptions(PWLB)		{ pw_localbus dac_8_bit bt485_curs numbernine \
+				  power_saver sw_cursor }
+set CardOptions(GA968)		{ power_saver sw_cursor }
 
 # For each server, what readme files are applicable?
 set CardReadmes(SVGA-ark)	README.ark
@@ -519,7 +530,7 @@
 
 set CardReadmes(8514)	   {}
 set CardReadmes(AGX)	   README.agx
-set CardReadmes(I128)	   {}
+set CardReadmes(I128)	   README.I128
 set CardReadmes(Mach8)	   {}
 set CardReadmes(Mach32)	   README.Mach32
 set CardReadmes(Mach64)	   README.Mach64
Index: xc/programs/Xserver/hw/xfree86/XF86Setup/mseproto.cpp
diff -u xc/programs/Xserver/hw/xfree86/XF86Setup/mseproto.cpp:1.1.2.5 xc/programs/Xserver/hw/xfree86/XF86Setup/mseproto.cpp:1.1.2.6
--- xc/programs/Xserver/hw/xfree86/XF86Setup/mseproto.cpp:1.1.2.5	Sat Feb 28 19:54:10 1998
+++ xc/programs/Xserver/hw/xfree86/XF86Setup/mseproto.cpp	Fri Dec 18 22:56:21 1998
@@ -1,4 +1,4 @@
-/* $XFree86: xc/programs/Xserver/hw/xfree86/XF86Setup/mseproto.cpp,v 1.1.2.5 1998/02/28 08:54:10 dawes Exp $ */
+/* $XFree86: xc/programs/Xserver/hw/xfree86/XF86Setup/mseproto.cpp,v 1.1.2.6 1998/12/18 11:56:21 dawes Exp $ */
 
 #if defined(PC98)
 set SerialMouseTypes [list \
@@ -65,6 +65,9 @@
 #define MOUSE_TYPES $SerialMouseTypes $BusMouseTypes $StandardPS2Types
 #elif defined(sun) && defined(i386) && defined(SVR4)
 #define MOUSE_TYPES $SerialMouseTypes $BusMouseTypes $StandardPS2Types
+#elif defined(DGUX)
+#define MOUSE_TYPES $SerialMouseTypes $BusMouseTypes $StandardPS2Types \
+			$PnpMouseTypes $ExtendedPS2Types
 #elif defined (SVR4) || defined(SYSV)
 #define MOUSE_TYPES $SerialMouseTypes $PnpMouseTypes
 #else
Index: xc/programs/Xserver/hw/xfree86/accel/glint/glint_regs.h
diff -u xc/programs/Xserver/hw/xfree86/accel/glint/glint_regs.h:1.16.2.3 xc/programs/Xserver/hw/xfree86/accel/glint/glint_regs.h:1.16.2.4
--- xc/programs/Xserver/hw/xfree86/accel/glint/glint_regs.h:1.16.2.3	Sun Sep 13 22:29:03 1998
+++ xc/programs/Xserver/hw/xfree86/accel/glint/glint_regs.h	Mon Nov 30 22:58:16 1998
@@ -1,4 +1,4 @@
-/* $XFree86: xc/programs/Xserver/hw/xfree86/accel/glint/glint_regs.h,v 1.16.2.3 1998/09/13 12:29:03 hohndel Exp $ */
+/* $XFree86: xc/programs/Xserver/hw/xfree86/accel/glint/glint_regs.h,v 1.16.2.4 1998/11/30 11:58:16 dawes Exp $ */
 
 /*
  * glint register file 
@@ -933,7 +933,7 @@
 	*(unsigned int *)((char*)GLINTMMIOBase+r)
 
 #define GLINT_SLOW_READ_REG(r) \
-	( outb(80,0),*(unsigned int *)((char*)GLINTMMIOBase+r))
+	( outb(0x80,0),*(unsigned int *)((char*)GLINTMMIOBase+r))
 
 #define GLINT_WAIT(n)	\
  	if (!UsePCIRetry)  \
Index: xc/programs/Xserver/hw/xfree86/accel/i128/i128.c
diff -u xc/programs/Xserver/hw/xfree86/accel/i128/i128.c:3.22.2.12 xc/programs/Xserver/hw/xfree86/accel/i128/i128.c:3.22.2.13
--- xc/programs/Xserver/hw/xfree86/accel/i128/i128.c:3.22.2.12	Sat Oct 24 12:12:39 1998
+++ xc/programs/Xserver/hw/xfree86/accel/i128/i128.c	Sun Dec 20 02:40:50 1998
@@ -1,28 +1,29 @@
 /* $XConsortium: i128.c /main/13 1996/10/27 11:04:19 kaleb $ */
 /*
  * Copyright 1995 by Robin Cutshaw <robin@XFree86.Org>
- *
+ * Copyright 1998 by Number Nine Visual Technology, Inc.
+ * 
  * Permission to use, copy, modify, distribute, and sell this software and its
  * documentation for any purpose is hereby granted without fee, provided that
  * the above copyright notice appear in all copies and that both that
  * copyright notice and this permission notice appear in supporting
  * documentation, and that the name of Robin Cutshaw not be used in
  * advertising or publicity pertaining to distribution of the software without
- * specific, written prior permission.  Robin Cutshaw makes no representations
- * about the suitability of this software for any purpose.  It is provided
- * "as is" without express or implied warranty.
+ * specific, written prior permission.  Robin Cutshaw and Number Nine make no
+ * representations about the suitability of this software for any purpose.  It
+ * is provided "as is" without express or implied warranty.
  *
- * ROBIN CUTSHAW DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
- * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
- * EVENT SHALL ROBIN CUTSHAW BE LIABLE FOR ANY SPECIAL, INDIRECT OR
- * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
- * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
- * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
- * PERFORMANCE OF THIS SOFTWARE.
+ * ROBIN CUTSHAW AND NUMBER NINE DISCLAIM ALL WARRANTIES WITH REGARD TO THIS
+ * SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS, IN NO EVENT SHALL ROBIN CUTSHAW OR NUMBER NINE BE LIABLE FOR
+ * ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN
+ * AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING
+ * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
  *
  */
 
-/* $XFree86: xc/programs/Xserver/hw/xfree86/accel/i128/i128.c,v 3.22.2.12 1998/10/24 02:12:39 robin Exp $ */
+/* $XFree86: xc/programs/Xserver/hw/xfree86/accel/i128/i128.c,v 3.22.2.13 1998/12/19 15:40:50 robin Exp $ */
 
 #include "i128.h"
 #include "i128reg.h"
@@ -126,6 +127,7 @@
    { IBM524_DAC,	"ibm524" },
    { IBM526_DAC,	"ibm526" },
    { IBM528_DAC,	"ibm528" },
+   { SILVER_HAMMER_DAC,	"SilverHammerDAC" },
    { -1,		"" },
 };
 
@@ -136,6 +138,7 @@
 ScreenPtr i128savepScreen;
 Bool  i128DAC8Bit = FALSE;
 Bool  i128DACSyncOnGreen = FALSE;
+Bool  i128FlatPanel = FALSE;
 int i128DisplayWidth;
 int i128DisplayOffset = 0;
 int i128Weight;
@@ -149,6 +152,7 @@
 int i128DeviceType;
 int i128MemoryType = I128_MEMORY_UNKNOWN;
 int i128RamdacType = UNKNOWN_DAC;
+Bool i128Doublescan = FALSE;
 
 extern Bool xf86Exiting, xf86Resetting;
 
@@ -197,6 +201,7 @@
    pciConfigPtr pcrp, *pcrpp;
    CARD32 tmpl, tmph, tmp;
    extern i128Registers iR;
+   int PitchAlignment;
 
    pcrpp = xf86scanpci(i128InfoRec.scrnIndex);
 
@@ -207,7 +212,8 @@
    while ((pcrp = pcrpp[i]) != (pciConfigPtr)NULL) {
       if ((pcrp->_device_vendor == I128_DEVICE_ID1) ||
           (pcrp->_device_vendor == I128_DEVICE_ID2) ||
-          (pcrp->_device_vendor == I128_DEVICE_ID3))
+          (pcrp->_device_vendor == I128_DEVICE_ID3) ||
+          (pcrp->_device_vendor == I128_DEVICE_ID4))
         break;
       i++;
    }
@@ -228,7 +234,7 @@
    i128io.rbase_i = inl(iR.iobase + 0x10) & 0xFFFFFF00;
    i128io.rbase_e = inl(iR.iobase + 0x14) & 0xFFFF8003;
    i128io.id =      inl(iR.iobase + 0x18) & /* 0x7FFFFFFF */ 0xFFFFFFFF;
-   i128io.config1 = inl(iR.iobase + 0x1C) & /* 0xF3333F1F */ 0xFF333F1F;
+   i128io.config1 = inl(iR.iobase + 0x1C) & /* 0xF3333F1F */ 0xFF333F3F;
    i128io.config2 = inl(iR.iobase + 0x20) & 0xC1F70FFF;
    i128io.sgram   = inl(iR.iobase + 0x24) & 0xFFFFFFFF;
    i128io.soft_sw = inl(iR.iobase + 0x28) & 0x0000FFFF;
@@ -284,16 +290,21 @@
    iR.config1 = i128io.config1;
    iR.config2 = i128io.config2;
    iR.sgram = i128io.sgram;
-   i128io.sgram = 0x21089030;
+   if (i128DeviceType == I128_DEVICE_ID4)
+	i128io.sgram = 0x211BF030;
+   else
+	i128io.sgram = 0x21089030;
    /* vga_ctl is saved later */
 
    /* enable all of the memory mapped windows */
 
    i128io.config1 &= 0xFF00001F;
-   i128io.config1 |= 0x00333F10;
+   i128io.config1 |= 0x00331F10;
    outl(iR.iobase + 0x1C, i128io.config1);
 
-   if (i128DeviceType == I128_DEVICE_ID3) {
+   if (i128DeviceType == I128_DEVICE_ID4)
+		i128MemoryType = I128_MEMORY_SGRAM;
+   else if (i128DeviceType == I128_DEVICE_ID3) {
 	if ((i128io.config2&6) == 2)
 		i128MemoryType = I128_MEMORY_SGRAM;
 	else
@@ -318,7 +329,8 @@
    ErrorF("%s %s: I128%s%s revision (%d)\n", 
 	  XCONFIG_PROBED, i128InfoRec.name,
 	  i128DeviceType == I128_DEVICE_ID2 ? "-II" :
-	  i128DeviceType == I128_DEVICE_ID3 ? "-T2R (Rev3D)" : "",
+	  i128DeviceType == I128_DEVICE_ID3 ? "-T2R (Rev3D)" :
+	  i128DeviceType == I128_DEVICE_ID4 ? "-T2R4 (Rev4)" : "",
 	  i128DeviceType != I128_DEVICE_ID3 ? "" :
 	   i128MemoryType == I128_MEMORY_SGRAM ? "-SGRAM" : "-WRAM",
 	  i128io.id&0x7);
@@ -336,6 +348,30 @@
 
    i128InfoRec.videoRam = 0;
 
+   if (i128DeviceType == I128_DEVICE_ID4) {
+      /* Use the subsystem ID to determine the memory size */
+      switch ((pcrp->rsvd2>>16) & 0x0007) {
+         case 0x00:      /* 4MB card */
+	    i128InfoRec.videoRam = 4 * 1024; break;
+         case 0x01:      /* 8MB card */
+	    i128InfoRec.videoRam = 8 * 1024; break;
+         case 0x02:      /* 12MB card */
+            i128InfoRec.videoRam = 12 * 1024; break;
+         case 0x03:      /* 16MB card */
+	    i128InfoRec.videoRam = 16 * 1024; break;
+         case 0x04:      /* 20MB card */
+	    i128InfoRec.videoRam = 20 * 1024; break;
+         case 0x05:      /* 24MB card */
+	    i128InfoRec.videoRam = 24 * 1024; break;
+         case 0x06:      /* 28MB card */
+	    i128InfoRec.videoRam = 28 * 1024; break;
+         case 0x07:      /* 32MB card */
+	    i128InfoRec.videoRam = 32 * 1024; break;
+         default: /* Unknown board... */
+            break;
+      }
+   }
+
    if (i128DeviceType == I128_DEVICE_ID3) {
       switch ((pcrp->rsvd2>>16)&0xFFF7) {
 	 case 0x00:	/* 4MB card, no daughtercard */
@@ -450,8 +486,8 @@
 #endif
    i128mem.xyw_ada = (unsigned char *)xf86MapVidMem(0, 2,
 			(pointer)(pcrp->_base2 & 0xFFC00000),
-                        i128InfoRec.videoRam * 1024);
-#ifdef TOOMANYMMAPS
+                        4 * 1024 * 1024);  /* Never use more than 4MB here */
+#if 0 /* #ifdef TOOMANYMMAPS */ /* This is never used */
    i128mem.xyw_adb = (CARD32 *)xf86MapVidMem(0, 3,
 			(pointer)(pcrp->_base3 & 0xFFC00000),
                         i128InfoRec.videoRam * 1024);
@@ -475,6 +511,8 @@
 	 i128RamdacType = IBM526_DAC;
    } else if (pcrp->_device_vendor == I128_DEVICE_ID3) {
 	 i128RamdacType = IBM526_DAC;
+   } else if (pcrp->_device_vendor == I128_DEVICE_ID4) {
+	 i128RamdacType = SILVER_HAMMER_DAC;
    } else {
             ErrorF("%s: Unknown I128 rev (%x).\n", i128InfoRec.name,
 		pcrp->_device_vendor);
@@ -593,6 +631,45 @@
 	           XCONFIG_PROBED, i128InfoRec.name, mclk / 1000.0);
          break;
 
+      case SILVER_HAMMER_DAC:
+         /* verify that the ramdac is a Silver Hammer */
+
+         i128InfoRec.ramdac = "SilverHammer";
+	 tmph = i128mem.rbase_g[IDXH_I] & 0xFF;
+	 tmpl = i128mem.rbase_g[IDXL_I] & 0xFF;
+	 tmp = i128mem.rbase_g[DATA_I] & 0xFF;
+
+         i128mem.rbase_g[IDXL_I] = IBMRGB_sysclk_ref_div;		MB;
+	 n = i128mem.rbase_g[DATA_I] & 0x1f;
+         i128mem.rbase_g[IDXL_I] = IBMRGB_sysclk_vco_div;		MB;
+	 m = i128mem.rbase_g[DATA_I];
+	 df = m>>6;
+	 m &= 0x3f;
+	 if (n == 0) { m=0; n=1; }
+	 mclk = ((3750000 * (m+65)) / n / (8>>df) + 50) / 100;
+
+	 i128mem.rbase_g[IDXL_I] = tmpl;				MB;
+	 i128mem.rbase_g[IDXH_I] = tmph;				MB;
+         if (pcrp->_device_vendor != I128_DEVICE_ID4) {
+            ErrorF("%s: %s Ramdac not found.\n", i128InfoRec.name,
+		i128InfoRec.ramdac);
+            return(FALSE);
+         }
+
+	 if (i128mem.rbase_g[CRT_1CON] & 0x00000100) {
+            i128FlatPanel = TRUE;
+            if (xf86Verbose)
+               ErrorF("%s %s: Digital flat panel detected\n",
+	              XCONFIG_PROBED, i128InfoRec.name);
+         }
+
+         OFLG_SET(CLOCK_OPTION_IBMRGB, &i128InfoRec.clockOptions);
+
+         if (xf86Verbose)
+            ErrorF("%s %s: Using IBM 526 programmable clock (MCLK %1.3f MHz)\n",
+	           XCONFIG_PROBED, i128InfoRec.name, mclk / 1000.0);
+         break;
+
       default:
          ErrorF("%s: Unknown Ramdac.\n", i128InfoRec.name);
          return(FALSE);
@@ -611,6 +688,8 @@
           (pcrp->_device_vendor == I128_DEVICE_ID3) ||
           (i128InfoRec.videoRam == 8192))
 	 i128InfoRec.dacSpeeds[0] = 220000;
+      else if (pcrp->_device_vendor == I128_DEVICE_ID4)
+	 i128InfoRec.dacSpeeds[0] = 270000;
       else
 	 i128InfoRec.dacSpeeds[0] = 175000;
    }
@@ -679,6 +758,15 @@
    if ((tx != i128InfoRec.virtualX) || (ty != i128InfoRec.virtualY))
       OFLG_CLR(XCONFIG_VIRTUAL,&i128InfoRec.xconfigFlag);
 
+#if 0
+   /* The code below is whacked...
+    *
+    * The rules for virtualX are:
+    *      On a WRAM board, the pitch must be a multiple of 128 bytes.
+    *      Otherwise, the pitch must be a multiple of 256 bits.
+    * There is no need to force the numbers to 800, 1024, etc.
+    * The memory size check (above) should be done AFTER the pitch is changed!
+    */
    if (pcrp->_device_vendor == I128_DEVICE_ID3) {
       i128DisplayWidth = i128InfoRec.virtualX;
       if ((i128InfoRec.virtualX % 128) != 0)
@@ -699,8 +787,23 @@
       i128DisplayWidth = 1920;
    else
       i128DisplayWidth = 2048;
+#else
+   i128DisplayWidth = i128InfoRec.virtualX;
+   /* Normally, the pitch must be a multiple of 256 bits */
+   PitchAlignment = 256;
+
+   /* For WRAM, the pitch must be a multiple of 256 bytes */
+   if (i128MemoryType == I128_MEMORY_WRAM)
+      PitchAlignment = 256 * 8;
+
+   PitchAlignment /= xf86bpp;
+   if ((i128InfoRec.virtualX % PitchAlignment) != 0)
+         i128DisplayWidth +=  PitchAlignment - (i128InfoRec.virtualX % PitchAlignment);
+#endif
 
-   if (i128InfoRec.videoRam > 4096)
+   if (i128InfoRec.videoRam > 4096 &&
+       i128MemoryType != I128_MEMORY_DRAM &&
+       i128MemoryType != I128_MEMORY_SGRAM)
       i128DisplayOffset = 0x400000L %
 		          (i128DisplayWidth * (i128InfoRec.bitsPerPixel/8));
 
@@ -869,7 +972,8 @@
    i128mem.rbase_g[DATA_I] = tmp2 | ((flags & V_DBLCLK) ? 0x03 : 0x01);	MB;
 
    i128mem.rbase_g[IDXL_I] = IBMRGB_sync;				MB;
-   i128mem.rbase_g[DATA_I] = 0x00;  /* 0x10 +Hsync, 0x20 +Vsync */	MB;
+   i128mem.rbase_g[DATA_I] = ((flags & V_PHSYNC) ? 0x10 : 0x00)
+                           | ((flags & V_PVSYNC) ? 0x20 : 0x00);	MB;
    i128mem.rbase_g[IDXL_I] = IBMRGB_hsync_pos;				MB;
    i128mem.rbase_g[DATA_I] = 0x01;  /* Delay syncs by 1 pclock */	MB;
    i128mem.rbase_g[IDXL_I] = IBMRGB_pwr_mgmt;				MB;
@@ -896,7 +1000,8 @@
 	 (i128InfoRec.bitsPerPixel > 16)))
 	tmp2 |= 0x40;
    if ((i128MemoryType == I128_MEMORY_SGRAM) &&
-	 (i128InfoRec.bitsPerPixel > 16))
+	 (i128InfoRec.bitsPerPixel > 16) &&
+         (i128RamdacType != SILVER_HAMMER_DAC) )
 	tmp2 &= 0x3F;
    i128mem.rbase_g[DATA_I] = tmp2;					MB;
    i128mem.rbase_g[IDXL_I] = IBMRGB_misc3;				MB;
@@ -922,6 +1027,205 @@
 	/* should delay at least a millisec so we'll wait 50 */
    	usleep(50000);
    }
+
+   switch (i128InfoRec.depth) {
+   	case 24: /* 32 bit */
+   		i128mem.rbase_g[IDXL_I] = IBMRGB_pix_fmt;		MB;
+   		tmp2 = i128mem.rbase_g[DATA_I] & 0xf8;
+   		i128mem.rbase_g[DATA_I] = tmp2 | 0x06;			MB;
+   		i128mem.rbase_g[IDXL_I] = IBMRGB_32bpp;			MB;
+   		i128mem.rbase_g[DATA_I] = 0x03;				MB;
+   		break;
+	case 16:
+   		i128mem.rbase_g[IDXL_I] = IBMRGB_pix_fmt;		MB;
+   		tmp2 = i128mem.rbase_g[DATA_I] & 0xf8;
+   		i128mem.rbase_g[DATA_I] = tmp2 | 0x04;			MB;
+   		i128mem.rbase_g[IDXL_I] = IBMRGB_16bpp;			MB;
+   		i128mem.rbase_g[DATA_I] = 0xC7;				MB;
+   		break;
+	case 15:
+   		i128mem.rbase_g[IDXL_I] = IBMRGB_pix_fmt;		MB;
+   		tmp2 = i128mem.rbase_g[DATA_I] & 0xf8;
+   		i128mem.rbase_g[DATA_I] = tmp2 | 0x04;			MB;
+   		i128mem.rbase_g[IDXL_I] = IBMRGB_16bpp;			MB;
+   		i128mem.rbase_g[DATA_I] = 0xC5;				MB;
+   		break;
+	default: /* 8 bit */
+   		i128mem.rbase_g[IDXL_I] = IBMRGB_pix_fmt;		MB;
+   		tmp2 = i128mem.rbase_g[DATA_I] & 0xf8;
+   		i128mem.rbase_g[DATA_I] = tmp2 | 0x03;			MB;
+   		i128mem.rbase_g[IDXL_I] = IBMRGB_8bpp;			MB;
+   		i128mem.rbase_g[DATA_I] = 0x00;				MB;
+   		break;
+   }
+
+   i128mem.rbase_g[IDXCTL_I] = tmpc;					MB;
+   i128mem.rbase_g[IDXH_I] = tmph;					MB;
+   i128mem.rbase_g[IDXL_I] = tmpl;					MB;
+
+   return(TRUE);
+}
+
+
+Bool
+i128ProgramSilverHammerDAC(freq, flags, skew)
+     int   freq;
+     int   flags;
+     int   skew;
+{
+   /* The SilverHammer DAC is essentially the same as the IBMRGBxxx DACs,
+    * but with fewer options and a different reference frequency.
+    */
+
+   unsigned char tmp, tmp2, m, n, df, best_m, best_n, best_df, max_n;
+   CARD32 tmpl, tmph, tmpc;
+   long f, vrf, outf, best_vrf, best_diff, best_outf, diff;
+   long requested_freq;
+
+#undef  REF_FREQ
+#define REF_FREQ	 37500000
+#undef  MAX_VREF
+#define MAX_VREF	  9000000
+#define MIN_VREF	  1500000
+#undef  MAX_VCO
+#define MAX_VCO		270000000
+#define MIN_VCO		 65000000
+
+   if (freq < 25000) {
+       ErrorF("%s %s: Specified dot clock (%.3f) too low for SilverHammer",
+	      XCONFIG_PROBED, i128InfoRec.name, freq / 1000.0);
+       return(FALSE);
+   } else if (freq > MAX_VCO) {
+       ErrorF("%s %s: Specified dot clock (%.3f) too high for SilverHammer",
+	      XCONFIG_PROBED, i128InfoRec.name, freq / 1000.0);
+       return(FALSE);
+   }
+
+   requested_freq = freq * 1000;
+
+   best_m = best_n = best_df = 0;
+   best_vrf = best_outf = 0;
+   best_diff = requested_freq;  /* worst case */
+
+   for (df=0; df<4; df++) {
+   	max_n = REF_FREQ / MIN_VREF;
+   	if (df < 3)
+   		max_n >>= 1;
+	for (n=2; n<max_n; n++)
+		for (m=65; m<=128; m++) {
+			vrf = REF_FREQ / n;
+			if (df < 3)
+				vrf >>= 1;
+			if ((vrf > MAX_VREF) || (vrf < MIN_VREF))
+				continue;
+
+			f = vrf * m;
+			outf = f;
+			if (df < 2)
+				outf >>= 2 - df;
+			if ((f > MAX_VCO) || (f < MIN_VCO))
+				continue;
+
+			/* outf is a valid freq, pick the closest now */
+
+			if ((diff = (requested_freq - outf)) < 0)
+				diff = -diff;;
+			if (diff < best_diff) {
+				best_diff = diff;
+				best_m = m;
+				best_n = n;
+				best_df = df;
+				best_outf = outf;
+			}
+		}
+   }
+
+   /* do we have an acceptably close frequency? (less than 1% diff) */
+
+   if (best_diff > (requested_freq/100)) {
+       ErrorF("%s %s: Specified dot clock (%.3f) too far (best %.3f) SilverHammer",
+	      XCONFIG_PROBED, i128InfoRec.name, requested_freq / 1000.0,
+	      best_outf / 1000.0);
+       return(FALSE);
+   }
+
+   i128mem.rbase_g[PEL_MASK] = 0xFF;					MB;
+
+   tmpc = i128mem.rbase_g[IDXCTL_I] & 0xFF;
+   tmph = i128mem.rbase_g[IDXH_I] & 0xFF;
+   tmpl = i128mem.rbase_g[IDXL_I] & 0xFF;
+
+   i128mem.rbase_g[IDXH_I] = 0;						MB;
+   i128mem.rbase_g[IDXCTL_I] = 0;					MB;
+
+   i128mem.rbase_g[IDXL_I] = IBMRGB_misc_clock;				MB;
+   tmp2 = i128mem.rbase_g[DATA_I] & 0xFF;
+   i128mem.rbase_g[DATA_I] = tmp2 | 0x81;				MB;
+
+   i128mem.rbase_g[IDXL_I] = IBMRGB_m0+4;				MB;
+   i128mem.rbase_g[DATA_I] = (best_df<<6) | (best_m&0x3f);		MB;
+   i128mem.rbase_g[IDXL_I] = IBMRGB_n0+4;				MB;
+   i128mem.rbase_g[DATA_I] = best_n;					MB;
+
+   i128mem.rbase_g[IDXL_I] = IBMRGB_pll_ctrl1;				MB;
+   tmp2 = i128mem.rbase_g[DATA_I] & 0xFF;
+   i128mem.rbase_g[DATA_I] = (tmp2&0xf8) | 3;  /* 8 M/N pairs in PLL */	MB;
+
+   i128mem.rbase_g[IDXL_I] = IBMRGB_pll_ctrl2;				MB;
+   tmp2 = i128mem.rbase_g[DATA_I] & 0xFF;
+   i128mem.rbase_g[DATA_I] = (tmp2&0xf0) | 2;  /* clock number 2 */	MB;
+
+   i128mem.rbase_g[IDXL_I] = IBMRGB_misc_clock;				MB;
+   tmp2 = i128mem.rbase_g[DATA_I] & 0xf0;
+   i128mem.rbase_g[DATA_I] = tmp2 | ((flags & V_DBLCLK) ? 0x03 : 0x01);	MB;
+
+   i128mem.rbase_g[IDXL_I] = IBMRGB_sync;				MB;
+   i128mem.rbase_g[DATA_I] = ((flags & V_PHSYNC) ? 0x10 : 0x00)
+                           | ((flags & V_PVSYNC) ? 0x20 : 0x00);	MB;
+   i128mem.rbase_g[IDXL_I] = IBMRGB_hsync_pos;				MB;
+   i128mem.rbase_g[DATA_I] = ((flags & V_HSKEW)  ? skew : 0x01);	MB;
+   i128mem.rbase_g[IDXL_I] = IBMRGB_pwr_mgmt;				MB;
+/* Use 0x01 below with digital flat panel to conserve energy and reduce noise */
+   i128mem.rbase_g[DATA_I] = (i128FlatPanel ? 0x01 : 0x00);		MB;
+   i128mem.rbase_g[IDXL_I] = IBMRGB_dac_op;				MB;
+   i128mem.rbase_g[DATA_I] = (i128DACSyncOnGreen ? 0x08 : 0x00);	MB;
+   i128mem.rbase_g[IDXL_I] = IBMRGB_pal_ctrl;				MB;
+   i128mem.rbase_g[DATA_I] = 0x00;					MB;
+   i128mem.rbase_g[IDXL_I] = IBMRGB_sysclk;				MB;
+   i128mem.rbase_g[DATA_I] = 0x01;					MB;
+   i128mem.rbase_g[IDXL_I] = IBMRGB_misc1;				MB;
+   tmp2 = i128mem.rbase_g[DATA_I] & 0xbc;
+   if ((i128MemoryType != I128_MEMORY_DRAM) &&
+       (i128MemoryType != I128_MEMORY_SGRAM))
+   	tmp2 |= (i128RamdacType == IBM528_DAC) ? 3 : 1;
+   i128mem.rbase_g[DATA_I] = tmp2;					MB;
+   i128mem.rbase_g[IDXL_I] = IBMRGB_misc2;				MB;
+   tmp2 = 0x03;
+   if (i128DAC8Bit)
+	tmp2 |= 0x04;
+   if (!((i128MemoryType == I128_MEMORY_DRAM) &&
+	 (i128InfoRec.bitsPerPixel > 16)))
+	tmp2 |= 0x40;
+   if ((i128MemoryType == I128_MEMORY_SGRAM) &&
+	 (i128InfoRec.bitsPerPixel > 16) &&
+         (i128RamdacType != SILVER_HAMMER_DAC) )
+	tmp2 &= 0x3F;
+   i128mem.rbase_g[DATA_I] = tmp2;					MB;
+   i128mem.rbase_g[IDXL_I] = IBMRGB_misc3;				MB;
+   i128mem.rbase_g[DATA_I] = 0x00;					MB;
+   i128mem.rbase_g[IDXL_I] = IBMRGB_misc4;				MB;
+   i128mem.rbase_g[DATA_I] = 0x00;					MB;
+
+   /* ?? There is no write to cursor control register */
+
+   /* Set the memory clock speed to 95 MHz */
+   i128mem.rbase_g[IDXL_I] = IBMRGB_sysclk_ref_div;		MB;
+   i128mem.rbase_g[DATA_I] = 0x08;				MB;
+   i128mem.rbase_g[IDXL_I] = IBMRGB_sysclk_vco_div;		MB;
+   i128mem.rbase_g[DATA_I] = 0x50;				MB;
+
+   /* should delay at least a millisec so we'll wait 50 */
+   usleep(50000);
 
    switch (i128InfoRec.depth) {
    	case 24: /* 32 bit */
Index: xc/programs/Xserver/hw/xfree86/accel/i128/i128.h
diff -u xc/programs/Xserver/hw/xfree86/accel/i128/i128.h:3.5.2.1 xc/programs/Xserver/hw/xfree86/accel/i128/i128.h:3.5.2.2
--- xc/programs/Xserver/hw/xfree86/accel/i128/i128.h:3.5.2.1	Mon Feb 16 10:31:57 1998
+++ xc/programs/Xserver/hw/xfree86/accel/i128/i128.h	Sun Dec 20 02:40:53 1998
@@ -22,7 +22,7 @@
  *
  */
 
-/* $XFree86: xc/programs/Xserver/hw/xfree86/accel/i128/i128.h,v 3.5.2.1 1998/02/15 23:31:57 robin Exp $ */
+/* $XFree86: xc/programs/Xserver/hw/xfree86/accel/i128/i128.h,v 3.5.2.2 1998/12/19 15:40:53 robin Exp $ */
 
 #ifndef _I128_H_
 #define _I128_H_
@@ -70,11 +70,12 @@
 
 extern ScrnInfoRec i128InfoRec;
 
-#define UNKNOWN_DAC -1
-#define TI3025_DAC   0
-#define IBM524_DAC   1
-#define IBM526_DAC   2
-#define IBM528_DAC   3
+#define UNKNOWN_DAC        -1
+#define TI3025_DAC          0
+#define IBM524_DAC          1
+#define IBM526_DAC          2
+#define IBM528_DAC          3
+#define SILVER_HAMMER_DAC   4
 
 #ifndef LINKKIT
 _XFUNCPROTOBEGIN
Index: xc/programs/Xserver/hw/xfree86/accel/i128/i128IBMCurs.c
diff -u xc/programs/Xserver/hw/xfree86/accel/i128/i128IBMCurs.c:3.0.4.3 xc/programs/Xserver/hw/xfree86/accel/i128/i128IBMCurs.c:3.0.4.4
--- xc/programs/Xserver/hw/xfree86/accel/i128/i128IBMCurs.c:3.0.4.3	Mon Jan 12 14:02:12 1998
+++ xc/programs/Xserver/hw/xfree86/accel/i128/i128IBMCurs.c	Sun Dec 20 02:40:52 1998
@@ -21,7 +21,7 @@
  *
  */
 
-/* $XFree86: xc/programs/Xserver/hw/xfree86/accel/i128/i128IBMCurs.c,v 3.0.4.3 1998/01/12 03:02:12 robin Exp $ */
+/* $XFree86: xc/programs/Xserver/hw/xfree86/accel/i128/i128IBMCurs.c,v 3.0.4.4 1998/12/19 15:40:52 robin Exp $ */
 
 #include "servermd.h"
 
@@ -34,6 +34,7 @@
 
 extern volatile struct i128mem i128mem;
 extern Bool i128BlockCursor;
+extern Bool i128Doublescan;
 
 
 /*
@@ -167,6 +168,9 @@
    y -= i128InfoRec.frameY0;
    if (y < 0)
       return;
+
+   if (i128Doublescan)
+      y *= 2;
 
    tmp = i128mem.rbase_g[IDXL_I] & 0xFF;
    i128mem.rbase_g[IDXL_I] = IBMRGB_curs_hot_x;				MB;
Index: xc/programs/Xserver/hw/xfree86/accel/i128/i128init.c
diff -u xc/programs/Xserver/hw/xfree86/accel/i128/i128init.c:3.6.2.8 xc/programs/Xserver/hw/xfree86/accel/i128/i128init.c:3.6.2.9
--- xc/programs/Xserver/hw/xfree86/accel/i128/i128init.c:3.6.2.8	Sat Oct 24 12:12:40 1998
+++ xc/programs/Xserver/hw/xfree86/accel/i128/i128init.c	Sun Dec 20 02:40:51 1998
@@ -1,26 +1,28 @@
-/* $XFree86: xc/programs/Xserver/hw/xfree86/accel/i128/i128init.c,v 3.6.2.8 1998/10/24 02:12:40 robin Exp $ */
+/* $XFree86: xc/programs/Xserver/hw/xfree86/accel/i128/i128init.c,v 3.6.2.9 1998/12/19 15:40:51 robin Exp $ */
 /*
  * Copyright 1995 by Robin Cutshaw <robin@XFree86.Org>
- *
+ * Copyright 1998 by Number Nine Visual Technology, Inc.
+ * 
  * Permission to use, copy, modify, distribute, and sell this software and its
  * documentation for any purpose is hereby granted without fee, provided that
  * the above copyright notice appear in all copies and that both that
  * copyright notice and this permission notice appear in supporting
  * documentation, and that the name of Robin Cutshaw not be used in
  * advertising or publicity pertaining to distribution of the software without
- * specific, written prior permission.  Robin Cutshaw makes no representations
- * about the suitability of this software for any purpose.  It is provided
- * "as is" without express or implied warranty.
+ * specific, written prior permission.  Robin Cutshaw and Number Nine make no
+ * representations about the suitability of this software for any purpose.  It
+ * is provided "as is" without express or implied warranty.
  *
- * ROBIN CUTSHAW DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
- * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
- * EVENT SHALL ROBIN CUTSHAW BE LIABLE FOR ANY SPECIAL, INDIRECT OR
- * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
- * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
- * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
- * PERFORMANCE OF THIS SOFTWARE.
+ * ROBIN CUTSHAW AND NUMBER NINE DISCLAIM ALL WARRANTIES WITH REGARD TO THIS
+ * SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS, IN NO EVENT SHALL ROBIN CUTSHAW OR NUMBER NINE BE LIABLE FOR
+ * ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN
+ * AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING
+ * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
  *
  */
+
 /* $XConsortium: i128init.c /main/5 1996/10/19 17:52:17 kaleb $ */
 
 
@@ -51,6 +53,8 @@
 extern int i128MemoryType;
 extern int i128RamdacType;
 extern int i128DACSyncOnGreen;
+extern int i128FlatPanel;
+extern Bool i128Doublescan;
 
 
 
@@ -77,7 +81,8 @@
 		iR.i128_base_g[DATA_TI]  =
 			i128mem.rbase_g[DATA_TI];  /*  0x001C  */
 	} else if ((i128RamdacType == IBM526_DAC) ||
-		   (i128RamdacType == IBM528_DAC)) {
+		   (i128RamdacType == IBM528_DAC) ||
+		   (i128RamdacType == SILVER_HAMMER_DAC)) {
 		iR.i128_base_g[IDXL_I] =
 			i128mem.rbase_g[IDXL_I];   /*  0x0010  */
 		iR.i128_base_g[IDXH_I] =
@@ -191,7 +196,8 @@
 		i128mem.rbase_g[INDEX_TI] = TI_LOOP_CLOCK_PLL_DATA;	MB;
 		iR.Ti3025[8] = i128mem.rbase_g[DATA_TI];
 	} else if ((i128RamdacType == IBM526_DAC) ||
-		   (i128RamdacType == IBM528_DAC)) {
+		   (i128RamdacType == IBM528_DAC) ||
+		   (i128RamdacType == SILVER_HAMMER_DAC)) {
 		CARD32 i;
 
 		for (i=0; i<0x100; i++) {
@@ -290,7 +296,8 @@
 		i128mem.rbase_g[INDEX_TI] = TI_COLOR_KEY_CONTROL;	MB;
 		i128mem.rbase_g[DATA_TI] = iR.Ti302X[TI_COLOR_KEY_CONTROL]; MB;
 	} else if ((i128RamdacType == IBM526_DAC) ||
-		   (i128RamdacType == IBM528_DAC)) {
+		   (i128RamdacType == IBM528_DAC) ||
+		   (i128RamdacType == SILVER_HAMMER_DAC)) {
 		CARD32 i;
 
 		for (i=0; i<0x100; i++) {
@@ -318,7 +325,8 @@
 	}
 
 	/* iobase is filled in during the device probe (as well as config 1&2)*/
-	if ((i128io.id&0x7) > 0) {
+	if (((i128io.id&0x7) > 0) || (i128DeviceType == I128_DEVICE_ID3)
+			          || (i128DeviceType == I128_DEVICE_ID4)) {
 		int i;
 		unsigned char *vidmem = (unsigned char *)i128mem.mw0_ad;
 
@@ -354,7 +362,8 @@
 		i128mem.rbase_g[DATA_TI]  =
 			iR.i128_base_g[DATA_TI];  /* 0x001C */		MB;
 	} else if ((i128RamdacType == IBM526_DAC) ||
-		   (i128RamdacType == IBM528_DAC)) {
+		   (i128RamdacType == IBM528_DAC) ||
+		   (i128RamdacType == SILVER_HAMMER_DAC)) {
 		i128mem.rbase_g[IDXL_I] =
 			iR.i128_base_g[IDXL_I];   /* 0x0010 */		MB;
 		i128mem.rbase_g[IDXH_I] =
@@ -415,6 +424,10 @@
 	int pitch_multiplier, iclock;
 	Bool ret;
 	CARD32 tmp;
+	int doubled = 1;
+
+	if (mode->Flags & V_DBLSCAN)
+		doubled = 2;
 
 	i128HDisplay = mode->HDisplay;
 
@@ -438,6 +451,8 @@
 		iclock = 4;
 	else if (i128RamdacType == IBM528_DAC)
 		iclock = 128 / i128InfoRec.bitsPerPixel;
+	else if (i128RamdacType == SILVER_HAMMER_DAC)
+		iclock = 64 / i128InfoRec.bitsPerPixel;
 	else if ((i128MemoryType == I128_MEMORY_DRAM) ||
 		 (i128MemoryType == I128_MEMORY_SGRAM))
 		iclock = 32 / i128InfoRec.bitsPerPixel; /* IBM526 DAC 32b bus */
@@ -452,15 +467,17 @@
 	i128mem.rbase_g[CRT_HBL] = (mode->HTotal - mode->HDisplay)/iclock;
 	i128mem.rbase_g[CRT_HFP] = (mode->HSyncStart - mode->HDisplay)/iclock;
 	i128mem.rbase_g[CRT_HS] = (mode->HSyncEnd - mode->HSyncStart)/iclock;
-	i128mem.rbase_g[CRT_VAC] = mode->VDisplay;
-	i128mem.rbase_g[CRT_VBL] = mode->VTotal - mode->VDisplay;
-	i128mem.rbase_g[CRT_VFP] = mode->VSyncStart - mode->VDisplay;
-	i128mem.rbase_g[CRT_VS] = mode->VSyncEnd - mode->VSyncStart;
+	i128mem.rbase_g[CRT_VAC] = mode->VDisplay * doubled;
+	i128mem.rbase_g[CRT_VBL] = (mode->VTotal - mode->VDisplay) * doubled;
+	i128mem.rbase_g[CRT_VFP] = (mode->VSyncStart - mode->VDisplay)* doubled;
+	i128mem.rbase_g[CRT_VS] = (mode->VSyncEnd - mode->VSyncStart) * doubled;
 	i128mem.rbase_g[CRT_BORD] = 0x00;
 	tmp = 0x00000070;
 	if (i128DeviceType == I128_DEVICE_ID3)
 		tmp |= 0x00000100;
-	if (i128DACSyncOnGreen)
+	if ((i128DeviceType == I128_DEVICE_ID4) && i128FlatPanel)
+		tmp |= 0x00000100;	/* Turn on digital flat panel support */
+	if (i128DACSyncOnGreen || (mode->Flags & V_CSYNC))
 		tmp |= 0x00000004;
 	i128mem.rbase_g[CRT_1CON] = tmp;
 	if ((i128MemoryType == I128_MEMORY_DRAM) ||
@@ -477,7 +494,11 @@
 			tmp |= 0x01000000;  /* split transfer */
 	}
 	i128mem.rbase_g[CRT_2CON] = tmp;
-	i128mem.rbase_g[CRT_ZOOM] = 0x00000000;
+        if (mode->Flags & V_DBLSCAN)
+		i128Doublescan = TRUE;
+        else
+		i128Doublescan = FALSE;
+	i128mem.rbase_g[CRT_ZOOM] = (i128Doublescan ? 0x00000001 : 0x00000000);
 
 	i128mem.rbase_w[MW0_CTRL] = 0x00000000;
 	switch (i128InfoRec.videoRam) {
@@ -492,6 +513,15 @@
 		case 16384:
 			i128mem.rbase_w[MW0_SZ]   = 0x0000000C;
 			break;
+		case 16384+4096:
+			/* no break */
+		case 16384+8192:
+			/* no break */
+		case 16384+8192+4096:
+			/* no break */
+		case 32768:
+			i128mem.rbase_w[MW0_SZ]   = 0x0000000D;
+			break;
 		case 4096:
 			/* no break */
 		default:
@@ -506,16 +536,24 @@
 	i128mem.rbase_w[MW0_MASK] = 0xFFFFFFFF;
 									MB;
 
-	if ((i128io.id&0x7) > 0) {
+	if ((i128io.id&0x7) > 0 || i128DeviceType == I128_DEVICE_ID3
+			        || i128DeviceType == I128_DEVICE_ID4) {
 
         	xf86EnableIOPorts(i128InfoRec.scrnIndex);
 
 	   	i128io.vga_ctl &= 0x0000FF00;
    		i128io.vga_ctl |= 0x00000082;
+                if (i128FlatPanel && (mode->Flags & V_DBLSCAN))
+		   i128io.vga_ctl |= 0x00000020;  /* Stretch horizontally */
    		outl(iR.iobase + 0x30, i128io.vga_ctl);
 
-		if (i128MemoryType == I128_MEMORY_SGRAM) {
+                if (i128DeviceType == I128_DEVICE_ID4) {
+                        outl(iR.iobase + 0x24, 0x211BF030);
+			usleep(5000);
+			outl(iR.iobase + 0x24, 0xA11BF030);
+		} else if (i128MemoryType == I128_MEMORY_SGRAM) {
 			outl(iR.iobase + 0x24, 0x21089030);
+			usleep(5000);
 			outl(iR.iobase + 0x24, 0xA1089030);
 		}
 
@@ -534,6 +572,9 @@
 
 	if (i128RamdacType == TI3025_DAC)
 		ret = i128ProgramTi3025(mode->SynthClock);
+	else if (i128RamdacType == SILVER_HAMMER_DAC)
+		ret = i128ProgramSilverHammerDAC(mode->SynthClock,
+				                 mode->Flags, mode->HSkew);
 	else
 		ret = i128ProgramIBMRGB(mode->SynthClock, mode->Flags);
 
Index: xc/programs/Xserver/hw/xfree86/accel/i128/i128reg.h
diff -u xc/programs/Xserver/hw/xfree86/accel/i128/i128reg.h:3.5.2.5 xc/programs/Xserver/hw/xfree86/accel/i128/i128reg.h:3.5.2.6
--- xc/programs/Xserver/hw/xfree86/accel/i128/i128reg.h:3.5.2.5	Sat Oct 24 12:14:51 1998
+++ xc/programs/Xserver/hw/xfree86/accel/i128/i128reg.h	Sun Dec 20 02:40:52 1998
@@ -1,4 +1,4 @@
-/* $XFree86: xc/programs/Xserver/hw/xfree86/accel/i128/i128reg.h,v 3.5.2.5 1998/10/24 02:14:51 robin Exp $ */
+/* $XFree86: xc/programs/Xserver/hw/xfree86/accel/i128/i128reg.h,v 3.5.2.6 1998/12/19 15:40:52 robin Exp $ */
 /*
  * Copyright 1994 by Robin Cutshaw <robin@XFree86.Org>
  *
@@ -108,6 +108,7 @@
 #define I128_DEVICE_ID1		0x2309105D
 #define I128_DEVICE_ID2		0x2339105D
 #define I128_DEVICE_ID3		0x493D105D
+#define I128_DEVICE_ID4		0x5348105D
 
 #define I128_MEMORY_UNKNOWN	0x01
 #define I128_MEMORY_DRAM	0x02
Index: xc/programs/Xserver/hw/xfree86/accel/mach64/mach64cmap.c
diff -u xc/programs/Xserver/hw/xfree86/accel/mach64/mach64cmap.c:3.9 xc/programs/Xserver/hw/xfree86/accel/mach64/mach64cmap.c:3.9.2.1
--- xc/programs/Xserver/hw/xfree86/accel/mach64/mach64cmap.c:3.9	Mon Dec 23 17:39:11 1996
+++ xc/programs/Xserver/hw/xfree86/accel/mach64/mach64cmap.c	Tue Dec 22 18:49:52 1998
@@ -1,4 +1,4 @@
-/* $XFree86: xc/programs/Xserver/hw/xfree86/accel/mach64/mach64cmap.c,v 3.9 1996/12/23 06:39:11 dawes Exp $ */
+/* $XFree86: xc/programs/Xserver/hw/xfree86/accel/mach64/mach64cmap.c,v 3.9.2.1 1998/12/22 07:49:52 hohndel Exp $ */
 /*
  * Copyright 1990,91 by Thomas Roell, Dinkelscherben, Germany.
  * Copyright 1993,1994 by Kevin E. Martin, Chapel Hill, North Carolina.
@@ -82,6 +82,8 @@
     int		i;
     xColorItem	directDefs[256];
     extern LUTENTRY mach64savedLUT[256];
+    extern unsigned char xf86rGammaMap[], xf86gGammaMap[], xf86bGammaMap[];
+    LUTENTRY entry;
 
     if (pmap != InstalledMaps[pmap->pScreen->myNum])
 	return;
@@ -95,15 +97,27 @@
 	/* Return the n most significant bits from a 16-bit value.
 	 * For VGA, n = 6.  For 8-bit DACs, n = 8.
 	 */
-	if (mach64DAC8Bit) {
-	    mach64savedLUT[pdefs[i].pixel].r = pdefs[i].red >> 8;
-	    mach64savedLUT[pdefs[i].pixel].g = pdefs[i].green >> 8;
-	    mach64savedLUT[pdefs[i].pixel].b = pdefs[i].blue >> 8;
-	} else {
-	    mach64savedLUT[pdefs[i].pixel].r = pdefs[i].red >> 10;
-	    mach64savedLUT[pdefs[i].pixel].g = pdefs[i].green >> 10;
-	    mach64savedLUT[pdefs[i].pixel].b = pdefs[i].blue >> 10;
+	entry.r = pdefs[i].red >> 8;
+	entry.g = pdefs[i].green >> 8;
+	entry.b = pdefs[i].blue >> 8;
+
+	/* Include gamma correction if supported */
+	if (mach64IntegratedController) {
+	    entry.r = xf86rGammaMap[entry.r];
+	    entry.g = xf86gGammaMap[entry.g];
+	    entry.b = xf86bGammaMap[entry.b];
 	}
+
+	if (!mach64DAC8Bit) {
+	    entry.r >>= 2;
+	    entry.g >>= 2;
+	    entry.b >>= 2;
+	}
+
+	mach64savedLUT[pdefs[i].pixel].r = entry.r;
+	mach64savedLUT[pdefs[i].pixel].g = entry.g;
+	mach64savedLUT[pdefs[i].pixel].b = entry.b;
+
 	if (xf86VTSema
 #ifdef XFreeXDGA
 	    || ((mach64InfoRec.directMode & XF86DGADirectGraphics)
@@ -113,15 +127,9 @@
 	   ) {
             /* WaitQueue(4); */
             outb(ioDAC_REGS, pdefs[i].pixel);
-	    if (mach64DAC8Bit) {
-                outb(ioDAC_REGS+1, pdefs[i].red >> 8);
-                outb(ioDAC_REGS+1, pdefs[i].green >> 8);
-                outb(ioDAC_REGS+1, pdefs[i].blue >> 8);
-	    } else {
-                outb(ioDAC_REGS+1, pdefs[i].red >> 10);
-                outb(ioDAC_REGS+1, pdefs[i].green >> 10);
-                outb(ioDAC_REGS+1, pdefs[i].blue >> 10);
-	    }
+            outb(ioDAC_REGS+1, entry.r);
+            outb(ioDAC_REGS+1, entry.g);
+            outb(ioDAC_REGS+1, entry.b);
 	}
     }
     checkCursorColor = TRUE;
@@ -205,23 +213,34 @@
 mach64RestoreColor0(pScreen)
      ScreenPtr pScreen;
 {
-  Pixel       pix = 0;
-  xrgb        rgb;
+    Pixel       pix = 0;
+    xrgb        rgb;
+    extern unsigned char xf86rGammaMap[], xf86gGammaMap[], xf86bGammaMap[];
+
+    if (InstalledMaps[pScreen->myNum] == NOMAPYET)
+	return;
 
-  if (InstalledMaps[pScreen->myNum] == NOMAPYET)
-      return;
+    QueryColors(InstalledMaps[pScreen->myNum], 1, &pix, &rgb);
 
-  QueryColors(InstalledMaps[pScreen->myNum], 1, &pix, &rgb);
+    rgb.red   >>= 8;
+    rgb.green >>= 8;
+    rgb.blue  >>= 8;
+
+    /* Include gamma correction if supported */
+    if (mach64IntegratedController) {
+	rgb.red   = xf86rGammaMap[rgb.red];
+	rgb.green = xf86gGammaMap[rgb.green];
+	rgb.blue  = xf86bGammaMap[rgb.blue];
+    }
 
-    /* WaitQueue(4); */
-    outb(ioDAC_REGS, 0);
-    if (mach64DAC8Bit) {
-        outb(ioDAC_REGS+1, rgb.red >> 8);
-        outb(ioDAC_REGS+1, rgb.green >> 8);
-        outb(ioDAC_REGS+1, rgb.blue >> 8);
-    } else {
-        outb(ioDAC_REGS+1, rgb.red >> 10);
-        outb(ioDAC_REGS+1, rgb.green >> 10);
-        outb(ioDAC_REGS+1, rgb.blue >> 10);
+    if (!mach64DAC8Bit) {
+	rgb.red   >>= 2;
+	rgb.green >>= 2;
+	rgb.blue  >>= 2;
     }
+
+    outb(ioDAC_REGS, 0);
+    outb(ioDAC_REGS+1, rgb.red);
+    outb(ioDAC_REGS+1, rgb.green);
+    outb(ioDAC_REGS+1, rgb.blue);
 }
Index: xc/programs/Xserver/hw/xfree86/accel/mach64/mach64init.c
diff -u xc/programs/Xserver/hw/xfree86/accel/mach64/mach64init.c:3.24.2.7 xc/programs/Xserver/hw/xfree86/accel/mach64/mach64init.c:3.24.2.8
--- xc/programs/Xserver/hw/xfree86/accel/mach64/mach64init.c:3.24.2.7	Fri Nov 13 16:14:57 1998
+++ xc/programs/Xserver/hw/xfree86/accel/mach64/mach64init.c	Tue Dec 22 18:49:52 1998
@@ -1,4 +1,4 @@
-/* $XFree86: xc/programs/Xserver/hw/xfree86/accel/mach64/mach64init.c,v 3.24.2.7 1998/11/13 05:14:57 dawes Exp $ */
+/* $XFree86: xc/programs/Xserver/hw/xfree86/accel/mach64/mach64init.c,v 3.24.2.8 1998/12/22 07:49:52 hohndel Exp $ */
 /*
  * Written by Jake Richter
  * Copyright (c) 1989, 1990 Panacea Inc., Londonderry, NH - All Rights Reserved
@@ -2091,6 +2091,7 @@
 {
     int muxMode = FALSE;
     int temp;
+    extern unsigned char xf86rGammaMap[], xf86gGammaMap[], xf86bGammaMap[];
 
     switch (colorDepth) {
     case CRTC_PIX_WIDTH_8BPP:
@@ -2109,9 +2110,9 @@
 	outb(ioDAC_REGS + 2, 0xFF);
         outb(ioDAC_REGS, 0);
 	for (temp = 0; temp < 256; temp++) {
-	    outb(ioDAC_REGS + 1, temp);
-	    outb(ioDAC_REGS + 1, temp);
-	    outb(ioDAC_REGS + 1, temp);
+	    outb(ioDAC_REGS + 1, xf86rGammaMap[temp]);
+	    outb(ioDAC_REGS + 1, xf86gGammaMap[temp]);
+	    outb(ioDAC_REGS + 1, xf86bGammaMap[temp]);
 	}
 	break;
     }
Index: xc/programs/Xserver/hw/xfree86/accel/s3_virge/s3im.c
diff -u xc/programs/Xserver/hw/xfree86/accel/s3_virge/s3im.c:3.12.2.4 xc/programs/Xserver/hw/xfree86/accel/s3_virge/s3im.c:3.12.2.5
--- xc/programs/Xserver/hw/xfree86/accel/s3_virge/s3im.c:3.12.2.4	Wed May 28 23:12:51 1997
+++ xc/programs/Xserver/hw/xfree86/accel/s3_virge/s3im.c	Fri Dec 18 22:56:22 1998
@@ -1,4 +1,4 @@
-/* $XFree86: xc/programs/Xserver/hw/xfree86/accel/s3_virge/s3im.c,v 3.12.2.4 1997/05/28 13:12:51 dawes Exp $ */
+/* $XFree86: xc/programs/Xserver/hw/xfree86/accel/s3_virge/s3im.c,v 3.12.2.5 1998/12/18 11:56:22 dawes Exp $ */
 /*
  * Copyright 1992 by Kevin E. Martin, Chapel Hill, North Carolina.
  *
@@ -820,7 +820,7 @@
    if (opaque) {
       SETB_SRC_BG_CLR(bgPixel);
    }
-   else {
+   else if (alu != ROP_Dn) {
       alu |= MIX_MONO_TRANSP;
    }
 
Index: xc/programs/Xserver/hw/xfree86/common/Imakefile
diff -u xc/programs/Xserver/hw/xfree86/common/Imakefile:3.48.2.9 xc/programs/Xserver/hw/xfree86/common/Imakefile:3.48.2.10
--- xc/programs/Xserver/hw/xfree86/common/Imakefile:3.48.2.9	Sun Nov  1 01:40:54 1998
+++ xc/programs/Xserver/hw/xfree86/common/Imakefile	Tue Dec 22 22:23:19 1998
@@ -4,14 +4,18 @@
 
 
 
-XCOMM $XFree86: xc/programs/Xserver/hw/xfree86/common/Imakefile,v 3.48.2.9 1998/10/31 14:40:54 hohndel Exp $
+XCOMM $XFree86: xc/programs/Xserver/hw/xfree86/common/Imakefile,v 3.48.2.10 1998/12/22 11:23:19 hohndel Exp $
 
 
 
 #include <Server.tmpl>
 
 #ifdef i386MachArchitecture
+#ifdef GNUMachArchitecture
+        KBD = xf86Kbd
+#else
         KBD = xf86KbdMach
+#endif /* GNUMachArchitecture */
 #else
 # ifdef i386BsdArchitecture
         KBD = xf86KbdBSD
Index: xc/programs/Xserver/hw/xfree86/common/atKeynames.h
diff -u xc/programs/Xserver/hw/xfree86/common/atKeynames.h:3.9 xc/programs/Xserver/hw/xfree86/common/atKeynames.h:3.9.2.1
--- xc/programs/Xserver/hw/xfree86/common/atKeynames.h:3.9	Mon Dec 23 17:43:13 1996
+++ xc/programs/Xserver/hw/xfree86/common/atKeynames.h	Sat Dec 26 11:12:36 1998
@@ -1,4 +1,4 @@
-/* $XFree86: xc/programs/Xserver/hw/xfree86/common/atKeynames.h,v 3.9 1996/12/23 06:43:13 dawes Exp $ */
+/* $XFree86: xc/programs/Xserver/hw/xfree86/common/atKeynames.h,v 3.9.2.1 1998/12/26 00:12:36 dawes Exp $ */
 /*
  * Copyright 1990,91 by Thomas Roell, Dinkelscherben, Germany.
  *
@@ -164,7 +164,7 @@
 #define KEY_F12          /* F12                   0x58  */   88
 
 #define KEY_Prefix0      /* special               0x60  */   96
-#define KEY_Prefix1      /* specail               0x61  */   97
+#define KEY_Prefix1      /* special               0x61  */   97
 
 /*
  * The 'scancodes' below are generated by the server, because the MF101/102
Index: xc/programs/Xserver/hw/xfree86/common/xf86.h
diff -u xc/programs/Xserver/hw/xfree86/common/xf86.h:3.47.2.9 xc/programs/Xserver/hw/xfree86/common/xf86.h:3.47.2.10
--- xc/programs/Xserver/hw/xfree86/common/xf86.h:3.47.2.9	Mon Oct 19 06:42:10 1998
+++ xc/programs/Xserver/hw/xfree86/common/xf86.h	Sun Dec 20 12:54:03 1998
@@ -1,4 +1,4 @@
-/* $XFree86: xc/programs/Xserver/hw/xfree86/common/xf86.h,v 3.47.2.9 1998/10/18 20:42:10 hohndel Exp $ */
+/* $XFree86: xc/programs/Xserver/hw/xfree86/common/xf86.h,v 3.47.2.10 1998/12/20 01:54:03 dawes Exp $ */
 /*
  * Copyright 1990,91 by Thomas Roell, Dinkelscherben, Germany.
  *
@@ -374,6 +374,8 @@
 #ifdef XINPUT
     struct _LocalDeviceRec	*local;
 #endif
+  int		pBufP;
+  unsigned char pBuf[8];
 } MouseDevRec, *MouseDevPtr;
 
 #ifdef XINPUT
Index: xc/programs/Xserver/hw/xfree86/common/xf86AceCad.c
diff -u xc/programs/Xserver/hw/xfree86/common/xf86AceCad.c:3.6.2.1 xc/programs/Xserver/hw/xfree86/common/xf86AceCad.c:3.6.2.2
--- xc/programs/Xserver/hw/xfree86/common/xf86AceCad.c:3.6.2.1	Sun Oct 11 22:35:29 1998
+++ xc/programs/Xserver/hw/xfree86/common/xf86AceCad.c	Tue Dec 22 22:23:19 1998
@@ -22,7 +22,7 @@
  * PERFORMANCE OF THIS SOFTWARE.
  */
 
-/* $XFree86: xc/programs/Xserver/hw/xfree86/common/xf86AceCad.c,v 3.6.2.1 1998/10/11 12:35:29 hohndel Exp $ */
+/* $XFree86: xc/programs/Xserver/hw/xfree86/common/xf86AceCad.c,v 3.6.2.2 1998/12/22 11:23:19 hohndel Exp $ */
 
 #include "Xos.h"
 #include <signal.h>
@@ -438,12 +438,6 @@
 	    is_absolute = (priv->flags & ABSOLUTE_FLAG);
 	    is_core_pointer = xf86IsCorePointer(device);
 
-	    if (is_core_pointer) {
-		x = x * screenInfo.screens[0]->width / priv->acecadMaxX;
-		y = y * screenInfo.screens[0]->height / priv->acecadMaxY;
-		DBG(6, ErrorF("Adjusted coords x=%d y=%d\n", x, y));
-	    }
-
 /* coordonates are ready we can send events */
 	    if (prox) {
 		if (!(priv->acecadOldProximity))
@@ -908,6 +902,53 @@
 }
 
 /*
+** xf86AceConvert
+** Convert valuators to X and Y core coordinates.
+*/
+static Bool
+xf86AceConvert(LocalDevicePtr	local,
+	       int		first,
+	       int		num,
+	       int		v0,
+	       int		v1,
+	       int		v2,
+	       int		v3,
+	       int		v4,
+	       int		v5,
+	       int*		x,
+	       int*		y)
+{
+    AceCadDevicePtr	priv = (AceCadDevicePtr)(local->private);
+
+    *x = v0 * screenInfo.screens[0]->width / priv->acecadMaxX;
+    *y = v1 * screenInfo.screens[0]->height / priv->acecadMaxY;
+    DBG(6, ErrorF("xf86AceConvert Adjusted coords x=%d y=%d\n", *x, *y));
+
+    return TRUE;
+}
+
+/*
+** xf86AceReverseConvert
+** Convert X and Y core coordinates to valuators.
+*/
+static Bool
+xf86AceReverseConvert(LocalDevicePtr	local,
+		      int		x,
+		      int		y,
+		      int		*valuators)
+{
+    AceCadDevicePtr	priv = (AceCadDevicePtr)(local->private);
+
+    valuators[0] = x * priv->acecadMaxX / screenInfo.screens[0]->width;
+    valuators[1] = y * priv->acecadMaxY / screenInfo.screens[0]->height;
+
+    DBG(6, ErrorF("xf86AceReverseConvert converted x=%d y=%d to v0=%d v1=%d\n", x, y,
+		  valuators[0], valuators[1]));
+
+    return TRUE;
+}
+
+/*
 ** xf86AceCadAllocate
 ** Allocates the device structures for the AceCad.
 */
@@ -931,6 +972,8 @@
     local->control_proc = xf86AceCadChangeControl;
     local->close_proc = xf86AceCadClose;
     local->switch_mode = xf86AceCadSwitchMode;
+    local->conversion_proc = xf86AceConvert;
+    local->reverse_conversion_proc = xf86AceReverseConvert;
     local->fd = -1;
     local->atom = 0;
     local->dev = NULL;
Index: xc/programs/Xserver/hw/xfree86/common/xf86Config.c
diff -u xc/programs/Xserver/hw/xfree86/common/xf86Config.c:3.113.2.19 xc/programs/Xserver/hw/xfree86/common/xf86Config.c:3.113.2.20
--- xc/programs/Xserver/hw/xfree86/common/xf86Config.c:3.113.2.19	Mon Oct 19 06:42:11 1998
+++ xc/programs/Xserver/hw/xfree86/common/xf86Config.c	Tue Dec 22 22:23:20 1998
@@ -1,5 +1,5 @@
 /*
- * $XFree86: xc/programs/Xserver/hw/xfree86/common/xf86Config.c,v 3.113.2.19 1998/10/18 20:42:11 hohndel Exp $
+ * $XFree86: xc/programs/Xserver/hw/xfree86/common/xf86Config.c,v 3.113.2.20 1998/12/22 11:23:20 hohndel Exp $
  *
  * Copyright 1990,91 by Thomas Roell, Dinkelscherben, Germany.
  *
@@ -964,7 +964,7 @@
 #ifdef MINIX
       setuid(getuid());
 #else
-#if !defined(SVR4) && !defined(__NetBSD__) && !defined(__OpenBSD__) && !defined(__FreeBSD__)
+#if !defined(SVR4) && !defined(__NetBSD__) && !defined(__OpenBSD__) && !defined(__FreeBSD__) && !defined(__GNU__)
       setruid(0);
 #endif
       seteuid(real_uid);
@@ -978,7 +978,7 @@
 #else
     if (real_uid) {
       seteuid(0);
-#if !defined(SVR4) && !defined(__NetBSD__) && !defined(__OpenBSD__) && !defined(__FreeBSD__)
+#if !defined(SVR4) && !defined(__NetBSD__) && !defined(__OpenBSD__) && !defined(__FreeBSD__) && !defined(__GNU__)
       setruid(real_uid);
 #endif
     }
Index: xc/programs/Xserver/hw/xfree86/common/xf86Dial.c
diff -u xc/programs/Xserver/hw/xfree86/common/xf86Dial.c:1.1.2.4 xc/programs/Xserver/hw/xfree86/common/xf86Dial.c:1.1.2.5
--- xc/programs/Xserver/hw/xfree86/common/xf86Dial.c:1.1.2.4	Fri Nov 13 16:14:58 1998
+++ xc/programs/Xserver/hw/xfree86/common/xf86Dial.c	Sun Dec 20 12:54:04 1998
@@ -25,7 +25,7 @@
  *
  */
 
-/* $XFree86: xc/programs/Xserver/hw/xfree86/common/xf86Dial.c,v 1.1.2.4 1998/11/13 05:14:58 dawes Exp $ */
+/* $XFree86: xc/programs/Xserver/hw/xfree86/common/xf86Dial.c,v 1.1.2.5 1998/12/20 01:54:04 dawes Exp $ */
 
 /*
  * This driver handles SGI dial and button boxes protocol.
@@ -1170,7 +1170,7 @@
     char			*dev_name = (char *) getenv("DIAL_DEV");  
 #endif
 
-    local->name = "DialBox";
+    local->name = "dial+buttons";
     local->flags = 0; /*XI86_NO_OPEN_ON_INIT;*/
 #if !defined(sun) || defined(i386)
     local->device_config = xf86DialConfig;
Index: xc/programs/Xserver/hw/xfree86/common/xf86Events.c
diff -u xc/programs/Xserver/hw/xfree86/common/xf86Events.c:3.42.2.6 xc/programs/Xserver/hw/xfree86/common/xf86Events.c:3.42.2.9
--- xc/programs/Xserver/hw/xfree86/common/xf86Events.c:3.42.2.6	Fri Nov  6 20:46:25 1998
+++ xc/programs/Xserver/hw/xfree86/common/xf86Events.c	Sat Dec 26 11:12:37 1998
@@ -1,4 +1,4 @@
-/* $XFree86: xc/programs/Xserver/hw/xfree86/common/xf86Events.c,v 3.42.2.6 1998/11/06 09:46:25 hohndel Exp $ */
+/* $XFree86: xc/programs/Xserver/hw/xfree86/common/xf86Events.c,v 3.42.2.9 1998/12/26 00:12:37 dawes Exp $ */
 /*
  * Copyright 1990,91 by Thomas Roell, Dinkelscherben, Germany.
  *
@@ -438,6 +438,11 @@
 #endif
   miPointerUpdate();
 
+#ifdef XFreeXDGA
+  if (((ScrnInfoPtr)(xf86Info.currentScreen->devPrivates[xf86ScreenIndex].ptr))->directMode&XF86DGADirectGraphics) 
+    return;
+#endif
+
   miPointerPosition(&x, &y);
   xf86SetViewport(xf86Info.currentScreen, x, y);
 }
@@ -978,7 +983,7 @@
    * normal, non-keypad keys
    */
   if (scanCode < KEY_KP_7 || scanCode > KEY_KP_Decimal) {
-#if !defined(CSRG_BASED) && !defined(MACH386) && !defined(MINIX) && !defined(__OSF__)
+#if !defined(CSRG_BASED) && !defined(MACH386) && !defined(MINIX) && !defined(__OSF__) && !defined(__GNU__)
     /*
      * magic ALT_L key on AT84 keyboards for multilingual support
      */
@@ -1138,17 +1143,19 @@
 	      dyremaind = dyremaind - (float)dy;
 	  }
       }
+#endif /* !XINPUT */
 
 #ifdef XFreeXDGA
       if (((ScrnInfoPtr)(xf86Info.currentScreen->devPrivates[xf86ScreenIndex].ptr))->directMode&XF86DGADirectMouse) {
 	XF86DirectVideoMoveMouse(dx, dy, mevent->u.keyButtonPointer.time);
       } else
 #endif
+#ifndef XINPUT
 	{
 	  MOVEPOINTER(dx, dy, mevent->u.keyButtonPointer.time);
 	}
 #else
-      xf86PostMotionEvent(device, 0, 0, 2, dx, dy);
+	xf86PostMotionEvent(device, 0, 0, 2, dx, dy);
 #endif /* XINPUT */
   }
 
Index: xc/programs/Xserver/hw/xfree86/common/xf86Init.c
diff -u xc/programs/Xserver/hw/xfree86/common/xf86Init.c:3.66.2.4 xc/programs/Xserver/hw/xfree86/common/xf86Init.c:3.66.2.5
--- xc/programs/Xserver/hw/xfree86/common/xf86Init.c:3.66.2.4	Sun Oct 11 22:35:37 1998
+++ xc/programs/Xserver/hw/xfree86/common/xf86Init.c	Tue Dec 22 22:23:23 1998
@@ -1,5 +1,5 @@
 /*
- * $XFree86: xc/programs/Xserver/hw/xfree86/common/xf86Init.c,v 3.66.2.4 1998/10/11 12:35:37 hohndel Exp $
+ * $XFree86: xc/programs/Xserver/hw/xfree86/common/xf86Init.c,v 3.66.2.5 1998/12/22 11:23:23 hohndel Exp $
  *
  * Copyright 1990,91 by Thomas Roell, Dinkelscherben, Germany.
  *
@@ -174,7 +174,7 @@
 
     xf86OpenConsole();
 
-#if !defined(AMOEBA) && !defined(MINIX)
+#if !defined(AMOEBA) && !defined(MINIX) && !defined(__GNU__)
     /*
      * If VTInit was set, run that program with consoleFd as stdin and stdout
      */
Index: xc/programs/Xserver/hw/xfree86/common/xf86Kbd.c
diff -u xc/programs/Xserver/hw/xfree86/common/xf86Kbd.c:3.14 xc/programs/Xserver/hw/xfree86/common/xf86Kbd.c:3.14.2.2
--- xc/programs/Xserver/hw/xfree86/common/xf86Kbd.c:3.14	Sun Jan  5 22:58:08 1997
+++ xc/programs/Xserver/hw/xfree86/common/xf86Kbd.c	Tue Dec 22 22:23:23 1998
@@ -1,4 +1,4 @@
-/* $XFree86: xc/programs/Xserver/hw/xfree86/common/xf86Kbd.c,v 3.14 1997/01/05 11:58:08 dawes Exp $ */
+/* $XFree86: xc/programs/Xserver/hw/xfree86/common/xf86Kbd.c,v 3.14.2.2 1998/12/22 11:23:23 hohndel Exp $ */
 /*
  * Copyright 1990,91 by Thomas Roell, Dinkelscherben, Germany.
  *
@@ -238,14 +238,14 @@
      CARD8      *pModMap;
 {
   KeySym        *k;
-#if !defined(Lynx) && !defined(AMOEBA) && !defined(MINIX) && !defined(__OSF__) && !defined(__EMX__) && !defined(__mips__)
+#if !defined(Lynx) && !defined(AMOEBA) && !defined(MINIX) && !defined(__OSF__) && !defined(__EMX__) && !defined(__mips__) && !defined(DGUX) && !defined(__GNU__)
   keymap_t      keymap;
-#endif /* !Lynx && !AMOEBA && !MINIX && !__OSF__ && !__EMX__ */
+#endif /* !Lynx && !AMOEBA && !MINIX && !__OSF__ && !__EMX__ && !__mips__ && !DGUX */
   char          type;
   int           i, j;
   KeySym        *pMap;
   
-#if !defined(Lynx) && !defined(AMOEBA) && !defined(MINIX) && !defined(__OSF__) && !defined(__EMX__) && !defined(__mips__)
+#if !defined(Lynx) && !defined(AMOEBA) && !defined(MINIX) && !defined(__OSF__) && !defined(__EMX__) && !defined(__mips__) && !defined(__GNU__)
   xf86Info.kbdType =
     ioctl(xf86Info.consoleFd, KDGKBTYPE, &type) != -1 ? type : KB_101;
   if (xf86Info.kbdType == KB_84)
@@ -257,7 +257,7 @@
   pMap = map;
 #endif
 
-#if !defined(Lynx) && !defined(AMOEBA) && !defined(MINIX) && !defined(__OSF__) && !defined(__EMX__) && !defined(__mips__)
+#if !defined(Lynx) && !defined(AMOEBA) && !defined(MINIX) && !defined(__OSF__) && !defined(__EMX__) && !defined(__mips__) && !defined(DGUX) && !defined(__GNU__)
   /*
    * use the keymap, which can be gotten from our oringinal vt??.
    * ( ttymap(1) !!!! )
@@ -280,7 +280,7 @@
 	if (k[0] == k[2] && k[1] == k[3]) k[2] = k[3] = NoSymbol;
       }
   }
-#endif /* !Lynx && !AMOEBA && !MINIX && !__OSF__ && !__EMX__ */
+#endif /* !Lynx && !AMOEBA && !MINIX && !__OSF__ && !__EMX__ && !__mips__ && !DGUX */
 
   /*
    * Apply the special key mapping specified in XF86Config 
@@ -386,7 +386,7 @@
 
     }
   
-#if !defined(Lynx) && !defined(AMOEBA) && !defined(MINIX) && !defined(__OSF__) && !defined(__EMX__) && !defined(__mips__)
+#if !defined(Lynx) && !defined(AMOEBA) && !defined(MINIX) && !defined(__OSF__) && !defined(__EMX__) && !defined(__mips__) && !defined(__GNU__)
   xf86Info.kbdType =
     ioctl(xf86Info.consoleFd, KDGKBTYPE, &type) != -1 ? type : KB_101;
 #else
Index: xc/programs/Xserver/hw/xfree86/common/xf86Priv.h
diff -u xc/programs/Xserver/hw/xfree86/common/xf86Priv.h:3.24.2.1 xc/programs/Xserver/hw/xfree86/common/xf86Priv.h:3.24.2.2
--- xc/programs/Xserver/hw/xfree86/common/xf86Priv.h:3.24.2.1	Mon Feb  2 03:04:47 1998
+++ xc/programs/Xserver/hw/xfree86/common/xf86Priv.h	Fri Dec 18 22:56:23 1998
@@ -1,4 +1,4 @@
-/* $XFree86: xc/programs/Xserver/hw/xfree86/common/xf86Priv.h,v 3.24.2.1 1998/02/01 16:04:47 robin Exp $ */
+/* $XFree86: xc/programs/Xserver/hw/xfree86/common/xf86Priv.h,v 3.24.2.2 1998/12/18 11:56:23 dawes Exp $ */
 /*
  * Copyright 1990,91 by Thomas Roell, Dinkelscherben, Germany.
  *
@@ -46,7 +46,7 @@
 #else
   int		kbdFd;
 #endif /* MINIX */
-#if defined(MACH386) || defined(__OSF__)
+#if defined(MACH386) || defined(__OSF__) || defined(DGUX)
   int           kbdFd;
 #endif /* MACH386 || __OSF__ */
   int           vtno;
Index: xc/programs/Xserver/hw/xfree86/common/xf86Summa.c
diff -u xc/programs/Xserver/hw/xfree86/common/xf86Summa.c:3.5.2.4 xc/programs/Xserver/hw/xfree86/common/xf86Summa.c:3.5.2.5
--- xc/programs/Xserver/hw/xfree86/common/xf86Summa.c:3.5.2.4	Thu Nov 12 22:32:05 1998
+++ xc/programs/Xserver/hw/xfree86/common/xf86Summa.c	Tue Dec 22 22:23:24 1998
@@ -20,7 +20,7 @@
  * PERFORMANCE OF THIS SOFTWARE.
  */
 
-/* $XFree86: xc/programs/Xserver/hw/xfree86/common/xf86Summa.c,v 3.5.2.4 1998/11/12 11:32:05 dawes Exp $ */
+/* $XFree86: xc/programs/Xserver/hw/xfree86/common/xf86Summa.c,v 3.5.2.5 1998/12/22 11:23:24 hohndel Exp $ */
 
 #include "Xos.h"
 #include <signal.h>
@@ -1043,6 +1043,7 @@
     local->close_proc = xf86SumClose;
     local->switch_mode = xf86SumSwitchMode;
     local->conversion_proc = xf86SumConvert;
+    local->reverse_conversion_proc = xf86SumReverseConvert;
     local->fd = -1;
     local->atom = 0;
     local->dev = NULL;
Index: xc/programs/Xserver/hw/xfree86/common/xf86Wacom.c
diff -u xc/programs/Xserver/hw/xfree86/common/xf86Wacom.c:3.25.2.8 xc/programs/Xserver/hw/xfree86/common/xf86Wacom.c:3.25.2.9
--- xc/programs/Xserver/hw/xfree86/common/xf86Wacom.c:3.25.2.8	Fri Nov 13 16:14:58 1998
+++ xc/programs/Xserver/hw/xfree86/common/xf86Wacom.c	Sun Dec 20 12:54:05 1998
@@ -22,7 +22,7 @@
  *
  */
 
-/* $XFree86: xc/programs/Xserver/hw/xfree86/common/xf86Wacom.c,v 3.25.2.8 1998/11/13 05:14:58 dawes Exp $ */
+/* $XFree86: xc/programs/Xserver/hw/xfree86/common/xf86Wacom.c,v 3.25.2.9 1998/12/20 01:54:05 dawes Exp $ */
 
 /*
  * This driver is only able to handle the Wacom IV and Wacom V protocols.
@@ -124,6 +124,7 @@
     int		rotation;
     int		wheel;
     int		discard_first;
+    int		proximity;
 } WacomDeviceState;
 
 typedef struct
@@ -234,8 +235,7 @@
 #define MAXTRY 3                /* max number of try to receive magic number */
 #define SYSCALL(call) while(((call) == -1) && (errno == EINTR))
 
-/* RESET_IV should be "\r#", methinks -- RLL */
-#define WC_RESET_IV	"#\r"	/* reset to wacom IV command set */
+#define WC_RESET_IV	"RE\r"	/* reset to wacom IV command set */
 #define WC_CONFIG	"~R\r"	/* request a configuration string */
 #define WC_COORD	"~C\r"	/* request max coordinates */
 /* MODEL should be "~#", methinks -- RLL */
@@ -251,15 +251,20 @@
 #define WC_NO_INCREMENT	"IN0\r"	/* do not enable increment mode */
 #define WC_STREAM_MODE	"SR\r"	/* enable continuous mode */
 #define WC_PRESSURE_MODE "PH1\r" /* enable pressure mode */
+#define WC_STOP		"SP\r"	/* stop sending coordinates */
 #define WC_START	"ST\r"	/* start sending coordinates */
 
 static const char * setup_string = WC_MULTI WC_UPPER_ORIGIN
- WC_ALL_MACRO WC_NO_MACRO1 WC_RATE WC_NO_INCREMENT WC_STREAM_MODE;
+ WC_ALL_MACRO WC_NO_MACRO1 WC_RATE WC_NO_INCREMENT WC_STREAM_MODE WC_START;
 
 static const char * penpartner_setup_string = WC_PRESSURE_MODE WC_START;
 
 #define WC_V_SINGLE	"MT0\r"
 #define WC_V_ID		"ID1\r"
+#define WC_V_BAUD	"BA19\r"
+
+#define WC_RESET_19200	"\r$"	/* reset to 9600 baud */
+#define WC_RESET_19200_IV "\r#"
 
 static const char * intuos_setup_string = WC_V_SINGLE WC_V_ID WC_RATE WC_START;
 
@@ -597,6 +602,78 @@
 /*
  ***************************************************************************
  *
+ * set_serial_speed --
+ *
+ *	Set speed of the serial port.
+ *
+ ***************************************************************************
+ */
+static int
+set_serial_speed(int	fd,
+		 int	speed_code)
+{
+    struct termios	termios_tty;
+    int			err;
+    
+#ifdef POSIX_TTY
+    SYSCALL(err = tcgetattr(fd, &termios_tty));
+
+    if (err == -1) {
+	ErrorF("Wacom tcgetattr error : %s\n", strerror(errno));
+	return !Success;
+    }
+    termios_tty.c_iflag = IXOFF;
+    termios_tty.c_oflag = 0;
+    termios_tty.c_cflag = speed_code|CS8|CREAD|CLOCAL;
+    termios_tty.c_lflag = 0;
+
+    termios_tty.c_cc[VINTR] = 0;
+    termios_tty.c_cc[VQUIT] = 0;
+    termios_tty.c_cc[VERASE] = 0;
+    termios_tty.c_cc[VEOF] = 0;
+#ifdef VWERASE
+    termios_tty.c_cc[VWERASE] = 0;
+#endif
+#ifdef VREPRINT
+    termios_tty.c_cc[VREPRINT] = 0;
+#endif
+    termios_tty.c_cc[VKILL] = 0;
+    termios_tty.c_cc[VEOF] = 0;
+    termios_tty.c_cc[VEOL] = 0;
+#ifdef VEOL2
+    termios_tty.c_cc[VEOL2] = 0;
+#endif
+    termios_tty.c_cc[VSUSP] = 0;
+#ifdef VDSUSP
+    termios_tty.c_cc[VDSUSP] = 0;
+#endif
+#ifdef VDISCARD
+    termios_tty.c_cc[VDISCARD] = 0;
+#endif
+#ifdef VLNEXT
+    termios_tty.c_cc[VLNEXT] = 0; 
+#endif
+	
+    /* minimum 1 character in one read call and timeout to 100 ms */
+    termios_tty.c_cc[VMIN] = 1;
+    termios_tty.c_cc[VTIME] = 10;
+
+    SYSCALL(err = tcsetattr(fd, TCSANOW, &termios_tty));
+    if (err == -1) {
+	ErrorF("Wacom tcsetattr TCSANOW error : %s\n", strerror(errno));
+	return !Success;
+    }
+
+#else
+    Code for OSs without POSIX tty functions
+#endif
+
+    return Success;
+}
+
+/*
+ ***************************************************************************
+ *
  * wait_for_fd --
  *
  *	Wait one second that the file descriptor becomes readable.
@@ -623,6 +700,40 @@
 /*
  ***************************************************************************
  *
+ * flush_input_fd --
+ *
+ *	Flush all input pending on the file descriptor.
+ *
+ ***************************************************************************
+ */
+static int
+flush_input_fd(int	fd)
+{
+    int			err;
+    int			n_bytes;
+    fd_set		readfds;
+    struct timeval	timeout;
+    char		dummy[1];
+    
+    FD_ZERO(&readfds);
+    FD_SET(fd, &readfds);
+
+    do {
+	timeout.tv_sec = 0;
+	timeout.tv_usec = 0;
+	SYSCALL(err = select(FD_SETSIZE, &readfds, NULL, NULL, &timeout));
+
+	if (err > 0) {
+	    SYSCALL(err = read(fd, &dummy, 1));
+	    DBG(10, ErrorF("flush_input_fd: read %d bytes\n", err));
+	}
+    } while (err > 0);
+    return err;
+}
+
+/*
+ ***************************************************************************
+ *
  * send_request --
  *
  ***************************************************************************
@@ -1061,10 +1172,11 @@
 	/* reports button up when the device has been down and becomes out of proximity */
 	if (priv->oldButtons) {
 	    xf86WcmSendButtons (local, 0, rx, ry, rz, rtx, rty);
+	    priv->oldButtons = 0;
 	}
 	if (!is_core_pointer) {
 	    /* macro button management */
-	    if (buttons) {
+	    if (common->wcmProtocolLevel == 4 && buttons) {
 		int	macro = z / 2;
 
 		DBG(6, ErrorF("macro=%d buttons=%d wacom_map[%d]=%x\n",
@@ -1087,6 +1199,34 @@
     }
 }
 
+#define ABS(x) ((x) > 0 ? (x) : -(x))
+
+/*
+ ***************************************************************************
+ *
+ * xf86WcmSuppress --
+ *	Determine whether device state has changed enough - return 1
+ *	if not.
+ *
+ ***************************************************************************
+ */
+static int
+xf86WcmSuppress(int			suppress,
+		WacomDeviceState 	*ds1,
+		WacomDeviceState	*ds2)
+{
+    if (ds1->buttons != ds2->buttons) return 0;
+    if (ds1->proximity != ds2->proximity) return 0;
+    if (ABS(ds1->x - ds2->x) >= suppress) return 0;
+    if (ABS(ds1->y - ds2->y) >= suppress) return 0;
+    if (ABS(ds1->pressure - ds2->pressure) >= suppress) return 0;
+    if ((1800 + ds1->rotation - ds2->rotation) % 1800 >= suppress &&
+    	(1800 + ds2->rotation - ds1->rotation) % 1800 >= suppress) return 0;
+    if (ABS(ds1->wheel - ds2->wheel) >= suppress) return 0;
+    return 1;
+}
+
+
 /*
  ***************************************************************************
  *
@@ -1106,6 +1246,7 @@
     int			*px, *py, *pz, *pbuttons, *pprox;
     unsigned char	buffer[BUFFER_SIZE];
     WacomDeviceState	*ds;
+    WacomDeviceState	old_ds;
     int			have_data;
   
     DBG(7, ErrorF("xf86WcmReadInput BEGIN device=%s fd=%d\n",
@@ -1264,9 +1405,10 @@
 	    common->wcmIndex = 0;
 
 	    ds = &common->wcmDevStat[common->wcmData[0] & 0x01];
+	    old_ds = *ds;
 	    have_data = 0;
 	    if ((common->wcmData[0] & 0xfc) == 0xc0) {
-		is_proximity = 1;
+		ds->proximity = 1;
 		ds->device_id = (((common->wcmData[1] & 0x7f) << 5) |
 				 ((common->wcmData[2] & 0x7c) >> 2));
 		ds->serial_num = (((common->wcmData[2] & 0x03) << 30) |
@@ -1279,7 +1421,7 @@
 		  ds->discard_first = 1;
 	    }
 	    else if ((common->wcmData[0] & 0xfe) == 0x80) {
-		is_proximity = 0;
+		ds->proximity = 0;
 		have_data = 1;
 	    }
 	    else if ((common->wcmData[0] & 0xb8) == 0xa0) {
@@ -1296,7 +1438,7 @@
 			   (ds->pressure >= common->wcmThreshold));
 		if ((ds->device_id & 0x008) == 0x008)
 		  ds->buttons |= 4;
-		is_proximity = (common->wcmData[0] & PROXIMITY_BIT);
+		ds->proximity = (common->wcmData[0] & PROXIMITY_BIT);
 		have_data = 1;
 	    }
 	    else if ((common->wcmData[0] & 0xbe) == 0xa8) {
@@ -1312,9 +1454,9 @@
 		if (common->wcmData[8] & 0x08) ds->wheel = -ds->wheel;
 		ds->buttons = (((common->wcmData[8] & 0x70) >> 1) |
 			   (common->wcmData[8] & 0x07));
-		is_proximity = (common->wcmData[0] & PROXIMITY_BIT);
+		ds->proximity = (common->wcmData[0] & PROXIMITY_BIT);
 		have_data = !ds->discard_first;
-	      }
+	    }
 	    else if ((common->wcmData[0] & 0xbe) == 0xaa) {
 		is_stylus = 0;
 		ds->x = (((common->wcmData[1] & 0x7f) << 9) |
@@ -1325,9 +1467,15 @@
 			 ((common->wcmData[5] & 0x78) >> 3));
 		ds->rotation = (((common->wcmData[6] & 0x0f) << 7) |
 				       (common->wcmData[7] & 0x7f));
-		is_proximity = (common->wcmData[0] & PROXIMITY_BIT);
+		ds->proximity = (common->wcmData[0] & PROXIMITY_BIT);
 		have_data = 1;
-		ds->discard_first == 0;
+		ds->discard_first = 0;
+	    }
+
+	    if (have_data && xf86WcmSuppress (common->wcmSuppress,
+		&old_ds, ds)) {
+		*ds = old_ds;
+		have_data = 0;
 	    }
 
 	    if (have_data) {
@@ -1337,9 +1485,17 @@
 
 		    xf86WcmSendEvents(common->wcmDevices[idx],
 				      is_stylus,
-				      is_button,
-				      is_proximity,
-				      ds->x, ds->y, ds->pressure, ds->buttons);
+				      0,
+				      ds->proximity,
+				      ds->x, ds->y,
+				      (ds->device_id & 0xf06) == 0x004 ?
+/* change to #if 0 to make rotation control 3rd valuator */
+#if 1
+				      (ds->wheel >> 1) : ds->pressure,
+#else
+				      ((900 - ((ds->rotation + 900) % 1800)) >> 1) : ds->pressure,
+#endif
+				      ds->buttons);
 		}
 	    }
 	}
@@ -1391,68 +1547,72 @@
 	return !Success;
     }
 
-#ifdef POSIX_TTY
-    SYSCALL(err = tcgetattr(local->fd, &termios_tty));
 
+    DBG(1, ErrorF("initializing tablet\n"));
+    
+#if 0
+    if (set_serial_speed(local->fd, B19200) == !Success)
+        return !Success;
+
+    /* send reset to the tablet */
+    SYSCALL(err = write(local->fd, WC_RESET_19200, strlen(WC_RESET_19200)));
     if (err == -1) {
-	ErrorF("Wacom tcgetattr error : %s\n", strerror(errno));
+	ErrorF("Wacom write error : %s\n", strerror(errno));
 	return !Success;
     }
-    termios_tty.c_iflag = IXOFF;
-    termios_tty.c_oflag = 0;
-    termios_tty.c_cflag = B9600|CS8|CREAD|CLOCAL;
-    termios_tty.c_lflag = 0;
-
-    termios_tty.c_cc[VINTR] = 0;
-    termios_tty.c_cc[VQUIT] = 0;
-    termios_tty.c_cc[VERASE] = 0;
-    termios_tty.c_cc[VEOF] = 0;
-#ifdef VWERASE
-    termios_tty.c_cc[VWERASE] = 0;
-#endif
-#ifdef VREPRINT
-    termios_tty.c_cc[VREPRINT] = 0;
-#endif
-    termios_tty.c_cc[VKILL] = 0;
-    termios_tty.c_cc[VEOF] = 0;
-    termios_tty.c_cc[VEOL] = 0;
-#ifdef VEOL2
-    termios_tty.c_cc[VEOL2] = 0;
-#endif
-    termios_tty.c_cc[VSUSP] = 0;
-#ifdef VDSUSP
-    termios_tty.c_cc[VDSUSP] = 0;
-#endif
-#ifdef VDISCARD
-    termios_tty.c_cc[VDISCARD] = 0;
-#endif
-#ifdef VLNEXT
-    termios_tty.c_cc[VLNEXT] = 0; 
-#endif
-	
-    /* minimum 1 character in one read call and timeout to 100 ms */
-    termios_tty.c_cc[VMIN] = 1;
-    termios_tty.c_cc[VTIME] = 10;
-
-    SYSCALL(err = tcsetattr(local->fd, TCSANOW, &termios_tty));
+    
+    /* wait 15 mSecs */
+    timeout.tv_sec = 0;
+    timeout.tv_usec = 15000;
+    SYSCALL(err = select(0, NULL, NULL, NULL, &timeout));
     if (err == -1) {
-	ErrorF("Wacom tcsetattr TCSANOW error : %s\n", strerror(errno));
+	ErrorF("Wacom select error : %s\n", strerror(errno));
 	return !Success;
     }
 
-#else
-    Code for OSs without POSIX tty functions
+    /* send reset to the tablet */
+    SYSCALL(err = write(local->fd, WC_RESET_19200_IV, strlen(WC_RESET_19200_IV)));
+    if (err == -1) {
+	ErrorF("Wacom write error : %s\n", strerror(errno));
+	return !Success;
+    }
+    
+    /* wait 100 mSecs */
+    timeout.tv_sec = 0;
+    timeout.tv_usec = 100000;
+    SYSCALL(err = select(0, NULL, NULL, NULL, &timeout));
+    if (err == -1) {
+	ErrorF("Wacom select error : %s\n", strerror(errno));
+	return !Success;
+    }
 #endif
-
-    DBG(1, ErrorF("initializing tablet\n"));
     
     /* send reset to the tablet */
+    if (set_serial_speed(local->fd, B9600) == !Success)
+        return !Success;
+
     SYSCALL(err = write(local->fd, WC_RESET_IV, strlen(WC_RESET_IV)));
     if (err == -1) {
 	ErrorF("Wacom write error : %s\n", strerror(errno));
 	return !Success;
     }
     
+    /* wait 15 mSecs */
+    timeout.tv_sec = 0;
+    timeout.tv_usec = 15000;
+    SYSCALL(err = select(0, NULL, NULL, NULL, &timeout));
+    if (err == -1) {
+	ErrorF("Wacom select error : %s\n", strerror(errno));
+	return !Success;
+    }
+
+#if 0
+    SYSCALL(err = write(local->fd, WC_STOP, strlen(WC_STOP)));
+    if (err == -1) {
+	ErrorF("Wacom write error : %s\n", strerror(errno));
+	return !Success;
+    }
+    
     /* wait 200 mSecs */
     timeout.tv_sec = 0;
     timeout.tv_usec = 200000;
@@ -1461,7 +1621,19 @@
 	ErrorF("Wacom select error : %s\n", strerror(errno));
 	return !Success;
     }
-  
+
+    flush_input_fd(local->fd);
+
+#endif
+    
+    SYSCALL(err = write(local->fd, WC_START, strlen(WC_START)));
+    if (err == -1) {
+	ErrorF("Wacom write error : %s\n", strerror(errno));
+	return !Success;
+    }
+    
+    flush_input_fd(local->fd);
+
     DBG(2, ErrorF("reading model\n"));
     if (!send_request(local->fd, WC_MODEL, buffer)) 
 	return !Success;
@@ -1488,7 +1660,7 @@
 	common->wcmResolY = 2540;	/* Y resolution in points/inch */
 	common->wcmResolZ = 2540;	/* Z resolution in points/inch */
 	common->wcmPktLength = 9;	/* length of a packet */
-	common->wcmThreshold = -448;	/* Threshold for counting pressure as a button */
+	common->wcmThreshold = -480;	/* Threshold for counting pressure as a button */
     }
 	
     /* tilt works on ROM 1.4 and above */
@@ -1533,6 +1705,26 @@
 	SYSCALL(err = write(local->fd, setup_string, strlen(setup_string)));
     }
     else {
+	SYSCALL(err = write(local->fd, WC_V_BAUD,
+			    strlen(WC_V_BAUD)));
+        
+	if (err == -1) {
+	    ErrorF("Wacom write error : %s\n", strerror(errno));
+	    return !Success;
+	}
+
+	/* wait 100 mSecs */
+	timeout.tv_sec = 0;
+	timeout.tv_usec = 100000;
+	SYSCALL(err = select(0, NULL, NULL, NULL, &timeout));
+	if (err == -1) {
+	    ErrorF("Wacom select error : %s\n", strerror(errno));
+	    return !Success;
+	}
+
+	if (set_serial_speed(local->fd, B19200) == !Success)
+	    return !Success;
+
 	SYSCALL(err = write(local->fd, intuos_setup_string,
 			    strlen(intuos_setup_string)));
     }
Index: xc/programs/Xserver/hw/xfree86/common/xf86Xinput.c
diff -u xc/programs/Xserver/hw/xfree86/common/xf86Xinput.c:3.22.2.12 xc/programs/Xserver/hw/xfree86/common/xf86Xinput.c:3.22.2.13
--- xc/programs/Xserver/hw/xfree86/common/xf86Xinput.c:3.22.2.12	Thu Nov 12 22:32:06 1998
+++ xc/programs/Xserver/hw/xfree86/common/xf86Xinput.c	Sun Dec 20 12:54:06 1998
@@ -22,7 +22,7 @@
  *
  */
 
-/* $XFree86: xc/programs/Xserver/hw/xfree86/common/xf86Xinput.c,v 3.22.2.12 1998/11/12 11:32:06 dawes Exp $ */
+/* $XFree86: xc/programs/Xserver/hw/xfree86/common/xf86Xinput.c,v 3.22.2.13 1998/12/20 01:54:06 dawes Exp $ */
 
 #include "Xmd.h"
 #include "XI.h"
@@ -1286,6 +1286,13 @@
     Bool			is_core		= xf86IsCorePointer(device);
     Bool			is_shared       = xf86ShareCorePointer(device);
     
+    DBG(5, ErrorF("xf86PostButtonEvent BEGIN 0x%x(%s) button=%d down=%s is_core=%s is_shared=%s is_absolute=%s\n",
+		  device, device->name, button,
+		  is_down ? "True" : "False",
+		  is_core ? "True" : "False",
+		  is_shared ? "True" : "False",
+		  is_absolute ? "True" : "False"));
+    
     /* Check the core pointer button state not to send an inconsistent
      * event. This can happen with the AlwaysCore feature.
      */
@@ -1368,6 +1375,7 @@
 	xf86Info.lastEventTime = xE->u.keyButtonPointer.time = GetTimeInMillis();
 	xf86eqEnqueue(xE);
     }
+    DBG(5, ErrorF("xf86PostButtonEvent END\n"));
 }
 
 void
Index: xc/programs/Xserver/hw/xfree86/common/xf86_Mouse.c
diff -u xc/programs/Xserver/hw/xfree86/common/xf86_Mouse.c:3.21.2.16 xc/programs/Xserver/hw/xfree86/common/xf86_Mouse.c:3.21.2.17
--- xc/programs/Xserver/hw/xfree86/common/xf86_Mouse.c:3.21.2.16	Thu Nov 12 22:32:07 1998
+++ xc/programs/Xserver/hw/xfree86/common/xf86_Mouse.c	Sun Dec 20 12:54:07 1998
@@ -1,4 +1,4 @@
-/* $XFree86: xc/programs/Xserver/hw/xfree86/common/xf86_Mouse.c,v 3.21.2.16 1998/11/12 11:32:07 dawes Exp $ */
+/* $XFree86: xc/programs/Xserver/hw/xfree86/common/xf86_Mouse.c,v 3.21.2.17 1998/12/20 01:54:07 dawes Exp $ */
 /*
  *
  * Copyright 1990,91 by Thomas Roell, Dinkelscherben, Germany.
@@ -631,8 +631,9 @@
     int nBytes;
 {
   int                  i, buttons, dx, dy, dz;
-  static int           pBufP = 0;
-  static unsigned char pBuf[8];
+/*   static int           pBufP = 0;
+ *   static unsigned char pBuf[8];
+ */
   MouseDevPtr          mouse = MOUSE_DEV(device);
   
 #ifdef EXTMOUSEDEBUG
@@ -663,20 +664,20 @@
      *         that bit is supposed to be always on, but nobody told
      *         Microsoft...)
      */
-    if (pBufP != 0 &&
+    if (mouse->pBufP != 0 &&
 #if !defined(__NetBSD__)
 	mouse->mseType != P_PS2 &&
 #endif
 	((rBuf[i] & mouse->protoPara[2]) != mouse->protoPara[3] 
 	 || rBuf[i] == 0x80))
       {
-	pBufP = 0;          /* skip package */
+	mouse->pBufP = 0;          /* skip package */
       }
 
-    if (pBufP == 0 && (rBuf[i] & mouse->protoPara[0]) != mouse->protoPara[1])
+    if (mouse->pBufP == 0 && (rBuf[i] & mouse->protoPara[0]) != mouse->protoPara[1])
       continue;
 
-    if (pBufP >= mouse->protoPara[4] 
+    if (mouse->pBufP >= mouse->protoPara[4] 
 	&& (rBuf[i] & mouse->protoPara[0]) != mouse->protoPara[1])
       {
 	/*
@@ -707,15 +708,15 @@
         /*
 	 * [KAZU-030897]
 	 * Receive the fourth byte only when preceeding three bytes have
-	 * been detected (pBufP >= mouse->protoPara[4]).  In the previous
-	 * versions, the test was pBufP == 0; we may have mistakingly
+	 * been detected (mouse->pBufP >= mouse->protoPara[4]).  In the previous
+	 * versions, the test was mouse->pBufP == 0; we may have mistakingly
 	 * received a byte even if we didn't see anything preceeding 
 	 * the byte.
 	 */
 
 	if ((rBuf[i] & mouse->protoPara[5]) != mouse->protoPara[6])
 	  {
-	    pBufP = 0;
+	    mouse->pBufP = 0;
 	    continue;
 	  }
 
@@ -749,163 +750,163 @@
 	  buttons |= ((int)(rBuf[i] & 0x20) >> 4) | (mouse->lastButtons & 0x05);
 	  break;
 	}
-        pBufP = 0;
+        mouse->pBufP = 0;
 	goto post_event;
       }
 
-    if (pBufP >= mouse->protoPara[4])
-      pBufP = 0;
-    pBuf[pBufP++] = rBuf[i];
-    if (pBufP != mouse->protoPara[4]) continue;
+    if (mouse->pBufP >= mouse->protoPara[4])
+      mouse->pBufP = 0;
+    mouse->pBuf[mouse->pBufP++] = rBuf[i];
+    if (mouse->pBufP != mouse->protoPara[4]) continue;
 
     /*
      * assembly full package
      */
     dz = 0;
 #ifdef EXTMOUSEDEBUG
-    ErrorF("packet %2x %2x %2x %2x\n",pBuf[0],pBuf[1],pBuf[2],pBuf[3]);
+    ErrorF("packet %2x %2x %2x %2x\n",mouse->pBuf[0],mouse->pBuf[1],mouse->pBuf[2],mouse->pBuf[3]);
 #endif
     switch(mouse->mseType) {
       
     case P_LOGIMAN:	    /* MouseMan / TrackMan   [CHRIS-211092] */
     case P_MS:              /* Microsoft */
       if (mouse->chordMiddle)
-	buttons = (((int) pBuf[0] & 0x30) == 0x30) ? 2 :
-		  ((int)(pBuf[0] & 0x20) >> 3)
-		  | ((int)(pBuf[0] & 0x10) >> 4);
+	buttons = (((int) mouse->pBuf[0] & 0x30) == 0x30) ? 2 :
+		  ((int)(mouse->pBuf[0] & 0x20) >> 3)
+		  | ((int)(mouse->pBuf[0] & 0x10) >> 4);
       else
         buttons = (mouse->lastButtons & 2)
-		  | ((int)(pBuf[0] & 0x20) >> 3)
-		  | ((int)(pBuf[0] & 0x10) >> 4);
-      dx = (char)(((pBuf[0] & 0x03) << 6) | (pBuf[1] & 0x3F));
-      dy = (char)(((pBuf[0] & 0x0C) << 4) | (pBuf[2] & 0x3F));
+		  | ((int)(mouse->pBuf[0] & 0x20) >> 3)
+		  | ((int)(mouse->pBuf[0] & 0x10) >> 4);
+      dx = (char)(((mouse->pBuf[0] & 0x03) << 6) | (mouse->pBuf[1] & 0x3F));
+      dy = (char)(((mouse->pBuf[0] & 0x0C) << 4) | (mouse->pBuf[2] & 0x3F));
       break;
 
     case P_GLIDEPOINT:      /* ALPS GlidePoint */
     case P_THINKING:        /* ThinkingMouse */
     case P_IMSERIAL:        /* IntelliMouse, NetMouse, Mie Mouse, MouseMan+ */
       buttons =  (mouse->lastButtons & (8 + 2))
-		| ((int)(pBuf[0] & 0x20) >> 3)
-		| ((int)(pBuf[0] & 0x10) >> 4);
-      dx = (char)(((pBuf[0] & 0x03) << 6) | (pBuf[1] & 0x3F));
-      dy = (char)(((pBuf[0] & 0x0C) << 4) | (pBuf[2] & 0x3F));
+		| ((int)(mouse->pBuf[0] & 0x20) >> 3)
+		| ((int)(mouse->pBuf[0] & 0x10) >> 4);
+      dx = (char)(((mouse->pBuf[0] & 0x03) << 6) | (mouse->pBuf[1] & 0x3F));
+      dy = (char)(((mouse->pBuf[0] & 0x0C) << 4) | (mouse->pBuf[2] & 0x3F));
       break;
 
     case P_MSC:             /* Mouse Systems Corp */
-      buttons = (~pBuf[0]) & 0x07;
-      dx =    (char)(pBuf[1]) + (char)(pBuf[3]);
-      dy = - ((char)(pBuf[2]) + (char)(pBuf[4]));
+      buttons = (~mouse->pBuf[0]) & 0x07;
+      dx =    (char)(mouse->pBuf[1]) + (char)(mouse->pBuf[3]);
+      dy = - ((char)(mouse->pBuf[2]) + (char)(mouse->pBuf[4]));
       break;
       
     case P_MMHIT:           /* MM_HitTablet */
-      buttons = pBuf[0] & 0x07;
+      buttons = mouse->pBuf[0] & 0x07;
       if (buttons != 0)
         buttons = 1 << (buttons - 1);
-      dx = (pBuf[0] & 0x10) ?   pBuf[1] : - pBuf[1];
-      dy = (pBuf[0] & 0x08) ? - pBuf[2] :   pBuf[2];
+      dx = (mouse->pBuf[0] & 0x10) ?   mouse->pBuf[1] : - mouse->pBuf[1];
+      dy = (mouse->pBuf[0] & 0x08) ? - mouse->pBuf[2] :   mouse->pBuf[2];
       break;
 
     case P_ACECAD:	    /* ACECAD */
 	/* ACECAD is almost exactly like MM but the buttons are different */
-      buttons = (pBuf[0] & 0x02) | ((pBuf[0] & 0x04) >> 2) | ((pBuf[0] & 1) << 2);
-      dx = (pBuf[0] & 0x10) ?   pBuf[1] : - pBuf[1];
-      dy = (pBuf[0] & 0x08) ? - pBuf[2] :   pBuf[2];
+      buttons = (mouse->pBuf[0] & 0x02) | ((mouse->pBuf[0] & 0x04) >> 2) | ((mouse->pBuf[0] & 1) << 2);
+      dx = (mouse->pBuf[0] & 0x10) ?   mouse->pBuf[1] : - mouse->pBuf[1];
+      dy = (mouse->pBuf[0] & 0x08) ? - mouse->pBuf[2] :   mouse->pBuf[2];
       break;
 
     case P_MM:              /* MM Series */
     case P_LOGI:            /* Logitech Mice */
-      buttons = pBuf[0] & 0x07;
-      dx = (pBuf[0] & 0x10) ?   pBuf[1] : - pBuf[1];
-      dy = (pBuf[0] & 0x08) ? - pBuf[2] :   pBuf[2];
+      buttons = mouse->pBuf[0] & 0x07;
+      dx = (mouse->pBuf[0] & 0x10) ?   mouse->pBuf[1] : - mouse->pBuf[1];
+      dy = (mouse->pBuf[0] & 0x08) ? - mouse->pBuf[2] :   mouse->pBuf[2];
       break;
       
     case P_BM:              /* BusMouse */
 #if defined(__NetBSD__)
     case P_PS2:
 #endif
-      buttons = (~pBuf[0]) & 0x07;
-      dx =   (char)pBuf[1];
-      dy = - (char)pBuf[2];
+      buttons = (~mouse->pBuf[0]) & 0x07;
+      dx =   (char)mouse->pBuf[1];
+      dy = - (char)mouse->pBuf[2];
       break;
 
 #if !defined(__NetBSD__)
     case P_PS2:             /* PS/2 mouse */
-      buttons = (pBuf[0] & 0x04) >> 1 |       /* Middle */
-	        (pBuf[0] & 0x02) >> 1 |       /* Right */
-		(pBuf[0] & 0x01) << 2;        /* Left */
-      dx = (pBuf[0] & 0x10) ?    pBuf[1]-256  :  pBuf[1];
-      dy = (pBuf[0] & 0x20) ?  -(pBuf[2]-256) : -pBuf[2];
+      buttons = (mouse->pBuf[0] & 0x04) >> 1 |       /* Middle */
+	        (mouse->pBuf[0] & 0x02) >> 1 |       /* Right */
+		(mouse->pBuf[0] & 0x01) << 2;        /* Left */
+      dx = (mouse->pBuf[0] & 0x10) ?    mouse->pBuf[1]-256  :  mouse->pBuf[1];
+      dy = (mouse->pBuf[0] & 0x20) ?  -(mouse->pBuf[2]-256) : -mouse->pBuf[2];
       break;
 
     /* PS/2 mouse variants */
     case P_IMPS2:           /* IntelliMouse PS/2 */
     case P_NETPS2:          /* NetMouse PS/2 */
-      buttons = (pBuf[0] & 0x04) >> 1 |       /* Middle */
-	        (pBuf[0] & 0x02) >> 1 |       /* Right */
-		(pBuf[0] & 0x01) << 2;        /* Left */
-      dx = (pBuf[0] & 0x10) ?    pBuf[1]-256  :  pBuf[1];
-      dy = (pBuf[0] & 0x20) ?  -(pBuf[2]-256) : -pBuf[2];
-      dz = (char)pBuf[3];
+      buttons = (mouse->pBuf[0] & 0x04) >> 1 |       /* Middle */
+	        (mouse->pBuf[0] & 0x02) >> 1 |       /* Right */
+		(mouse->pBuf[0] & 0x01) << 2;        /* Left */
+      dx = (mouse->pBuf[0] & 0x10) ?    mouse->pBuf[1]-256  :  mouse->pBuf[1];
+      dy = (mouse->pBuf[0] & 0x20) ?  -(mouse->pBuf[2]-256) : -mouse->pBuf[2];
+      dz = (char)mouse->pBuf[3];
       break;
 
     case P_MMANPLUSPS2:     /* MouseMan+ PS/2 */
-      if ((pBuf[0] & ~0x07) == 0xc8) {
+      if ((mouse->pBuf[0] & ~0x07) == 0xc8) {
 	/* extended data packet */
-        buttons = (pBuf[0] & 0x04) >> 1 |       /* Middle */
-	          (pBuf[0] & 0x02) >> 1 |       /* Right */
-		  (pBuf[0] & 0x01) << 2 |       /* Left */
-		  ((pBuf[2] & 0x10) ? 0x08 : 0);/* fourth button */
+        buttons = (mouse->pBuf[0] & 0x04) >> 1 |       /* Middle */
+	          (mouse->pBuf[0] & 0x02) >> 1 |       /* Right */
+		  (mouse->pBuf[0] & 0x01) << 2 |       /* Left */
+		  ((mouse->pBuf[2] & 0x10) ? 0x08 : 0);/* fourth button */
 	dx = dy = 0;
-	dz = (pBuf[1] & 0x08) ? (pBuf[2] & 0x0f) - 16 : (pBuf[2] & 0x0f);
+	dz = (mouse->pBuf[1] & 0x08) ? (mouse->pBuf[2] & 0x0f) - 16 : (mouse->pBuf[2] & 0x0f);
       } else {
-        buttons = (pBuf[0] & 0x04) >> 1 |     /* Middle */
-	          (pBuf[0] & 0x02) >> 1 |     /* Right */
-		  (pBuf[0] & 0x01) << 2 |     /* Left */
+        buttons = (mouse->pBuf[0] & 0x04) >> 1 |     /* Middle */
+	          (mouse->pBuf[0] & 0x02) >> 1 |     /* Right */
+		  (mouse->pBuf[0] & 0x01) << 2 |     /* Left */
 		  (mouse->lastButtons & ~0x07);
-        dx = (pBuf[0] & 0x10) ?    pBuf[1]-256  :  pBuf[1];
-        dy = (pBuf[0] & 0x20) ?  -(pBuf[2]-256) : -pBuf[2];
+        dx = (mouse->pBuf[0] & 0x10) ?    mouse->pBuf[1]-256  :  mouse->pBuf[1];
+        dy = (mouse->pBuf[0] & 0x20) ?  -(mouse->pBuf[2]-256) : -mouse->pBuf[2];
       }
       break;
 
     case P_GLIDEPOINTPS2:   /* GlidePoint PS/2 */
-      buttons = (pBuf[0] & 0x04) >> 1 |       /* Middle */
-	        (pBuf[0] & 0x02) >> 1 |       /* Right */
-		(pBuf[0] & 0x01) << 2 |       /* Left */
-		((pBuf[0] & 0x08) ? 0 : 0x08);/* fourth button */
-      dx = (pBuf[0] & 0x10) ?    pBuf[1]-256  :  pBuf[1];
-      dy = (pBuf[0] & 0x20) ?  -(pBuf[2]-256) : -pBuf[2];
+      buttons = (mouse->pBuf[0] & 0x04) >> 1 |       /* Middle */
+	        (mouse->pBuf[0] & 0x02) >> 1 |       /* Right */
+		(mouse->pBuf[0] & 0x01) << 2 |       /* Left */
+		((mouse->pBuf[0] & 0x08) ? 0 : 0x08);/* fourth button */
+      dx = (mouse->pBuf[0] & 0x10) ?    mouse->pBuf[1]-256  :  mouse->pBuf[1];
+      dy = (mouse->pBuf[0] & 0x20) ?  -(mouse->pBuf[2]-256) : -mouse->pBuf[2];
       break;
 
     case P_NETSCROLLPS2:    /* NetScroll PS/2 */
-      buttons = (pBuf[0] & 0x04) >> 1 |       /* Middle */
-	        (pBuf[0] & 0x02) >> 1 |       /* Right */
-		(pBuf[0] & 0x01) << 2 |       /* Left */
-		((pBuf[3] & 0x02) ? 0x08 : 0);/* fourth button */
-      dx = (pBuf[0] & 0x10) ?    pBuf[1]-256  :  pBuf[1];
-      dy = (pBuf[0] & 0x20) ?  -(pBuf[2]-256) : -pBuf[2];
-      dz = (pBuf[3] & 0x10) ? pBuf[4] - 256 : pBuf[4];
+      buttons = (mouse->pBuf[0] & 0x04) >> 1 |       /* Middle */
+	        (mouse->pBuf[0] & 0x02) >> 1 |       /* Right */
+		(mouse->pBuf[0] & 0x01) << 2 |       /* Left */
+		((mouse->pBuf[3] & 0x02) ? 0x08 : 0);/* fourth button */
+      dx = (mouse->pBuf[0] & 0x10) ?    mouse->pBuf[1]-256  :  mouse->pBuf[1];
+      dy = (mouse->pBuf[0] & 0x20) ?  -(mouse->pBuf[2]-256) : -mouse->pBuf[2];
+      dz = (mouse->pBuf[3] & 0x10) ? mouse->pBuf[4] - 256 : mouse->pBuf[4];
       break;
 
     case P_THINKINGPS2:     /* ThinkingMouse PS/2 */
-      buttons = (pBuf[0] & 0x04) >> 1 |       /* Middle */
-	        (pBuf[0] & 0x02) >> 1 |       /* Right */
-		(pBuf[0] & 0x01) << 2 |       /* Left */
-		((pBuf[0] & 0x08) ? 0x08 : 0);/* fourth button */
-      dx = (pBuf[0] & 0x10) ?    pBuf[1]-256  :  pBuf[1];
-      dy = (pBuf[0] & 0x20) ?  -(pBuf[2]-256) : -pBuf[2];
+      buttons = (mouse->pBuf[0] & 0x04) >> 1 |       /* Middle */
+	        (mouse->pBuf[0] & 0x02) >> 1 |       /* Right */
+		(mouse->pBuf[0] & 0x01) << 2 |       /* Left */
+		((mouse->pBuf[0] & 0x08) ? 0x08 : 0);/* fourth button */
+      dx = (mouse->pBuf[0] & 0x10) ?    mouse->pBuf[1]-256  :  mouse->pBuf[1];
+      dy = (mouse->pBuf[0] & 0x20) ?  -(mouse->pBuf[2]-256) : -mouse->pBuf[2];
       break;
 
 #endif /* !__NetBSD__ */
 
     case P_SYSMOUSE:        /* sysmouse */
-      buttons = (~pBuf[0]) & 0x07;
-      dx =    (char)(pBuf[1]) + (char)(pBuf[3]);
-      dy = - ((char)(pBuf[2]) + (char)(pBuf[4]));
+      buttons = (~mouse->pBuf[0]) & 0x07;
+      dx =    (char)(mouse->pBuf[1]) + (char)(mouse->pBuf[3]);
+      dy = - ((char)(mouse->pBuf[2]) + (char)(mouse->pBuf[4]));
       /* FreeBSD sysmouse sends additional data bytes */
       if (mouse->protoPara[4] >= 8)
 	{
-          dz = ((char)(pBuf[5] << 1) + (char)(pBuf[6] << 1))/2;
-          buttons |= (int)(~pBuf[7] & 0x07) << 3;
+          dz = ((char)(mouse->pBuf[5] << 1) + (char)(mouse->pBuf[6] << 1))/2;
+          buttons |= (int)(~mouse->pBuf[7] & 0x07) << 3;
 	}
       break;
 
@@ -957,7 +958,7 @@
       }
 
     /* 
-     * We don't reset pBufP here yet, as there may be an additional data
+     * We don't reset mouse->pBufP here yet, as there may be an additional data
      * byte in some protocols. See above.
      */
   }
@@ -1152,7 +1153,7 @@
     mouse->local = local;
     
 #ifdef EXTMOUSEDEBUG
-    ErrorF("xf86MouseAllocate mouse=0x%x\n", local->private);
+    ErrorF("xf86MouseAllocate mouse=0x%x local=0x%x\n", local->private, local);
 #endif
     
     return local;
@@ -1171,4 +1172,4 @@
   xf86MouseAllocate			/* device_allocate */
 };
 
-#endif
+#endif /* XINPUT */
Index: xc/programs/Xserver/hw/xfree86/common/xf86_Option.h
diff -u xc/programs/Xserver/hw/xfree86/common/xf86_Option.h:3.65.2.16 xc/programs/Xserver/hw/xfree86/common/xf86_Option.h:3.65.2.18
--- xc/programs/Xserver/hw/xfree86/common/xf86_Option.h:3.65.2.16	Sun Sep 27 22:58:54 1998
+++ xc/programs/Xserver/hw/xfree86/common/xf86_Option.h	Tue Dec 29 21:57:45 1998
@@ -1,4 +1,4 @@
-/* $XFree86: xc/programs/Xserver/hw/xfree86/common/xf86_Option.h,v 3.65.2.16 1998/09/27 12:58:54 hohndel Exp $ */
+/* $XFree86: xc/programs/Xserver/hw/xfree86/common/xf86_Option.h,v 3.65.2.18 1998/12/29 10:57:45 dawes Exp $ */
 /*
  * Copyright 1993 by David Wexelblat <dwex@goblin.org>
  *
@@ -106,6 +106,8 @@
 #define OPTION_NO_PIXMAP_CACHE	67 /* Don't enable the pixmap cache */
 #define OPTION_TRIO32_FC_BUG	68 /* Workaround Trio32 font cache bug */
 #define OPTION_S3_968_DASH_BUG	69 /* Workaround S3 968 dashed line bug */
+#define OPTION_CURSOR_BUG	70 /* Workaround HW cursor bug */
+#define OPTION_ACCEL		71 /* Enable accel support */
 
 /* RAMDAC options */
 #define OPTION_BT485_CURS	80 /* Override Bt485 RAMDAC probe */
@@ -349,6 +351,8 @@
   { "no_pixmap_cache",	OPTION_NO_PIXMAP_CACHE },
   { "trio32_fc_bug",	OPTION_TRIO32_FC_BUG },
   { "s3_968_dash_bug",	OPTION_S3_968_DASH_BUG },
+  { "cursor_bug",	OPTION_CURSOR_BUG },
+  { "accel",		OPTION_ACCEL },
 
   { "xaa_benchmark",	OPTION_XAA_BENCHMARK },
   { "xaa_no_color_exp", OPTION_XAA_NO_COL_EXP },
Index: xc/programs/Xserver/hw/xfree86/common_hw/xf86_ClkPr.c
diff -u xc/programs/Xserver/hw/xfree86/common_hw/xf86_ClkPr.c:3.8 xc/programs/Xserver/hw/xfree86/common_hw/xf86_ClkPr.c:3.8.2.1
--- xc/programs/Xserver/hw/xfree86/common_hw/xf86_ClkPr.c:3.8	Mon Dec 23 17:44:24 1996
+++ xc/programs/Xserver/hw/xfree86/common_hw/xf86_ClkPr.c	Tue Dec 22 22:23:26 1998
@@ -1,4 +1,4 @@
-/* $XFree86: xc/programs/Xserver/hw/xfree86/common_hw/xf86_ClkPr.c,v 3.8 1996/12/23 06:44:24 dawes Exp $ */
+/* $XFree86: xc/programs/Xserver/hw/xfree86/common_hw/xf86_ClkPr.c,v 3.8.2.1 1998/12/22 11:23:26 hohndel Exp $ */
 /*
  * Copyright 1990,91 by Thomas Roell, Dinkelscherben, Germany.
  *
@@ -43,7 +43,7 @@
 #include "xf86_OSlib.h"
 #include "xf86_HWlib.h"
 
-#if defined(CSRG_BASED) || defined(MACH386)
+#if defined(CSRG_BASED) || defined(MACH386) || defined(__GNU__)
 #include <sys/resource.h>
 #endif
 
@@ -74,7 +74,7 @@
     /* First save registers that get written on */
     (*ClockFunc)(CLK_REG_SAVE);
 
-#if defined(CSRG_BASED) || defined(MACH386)
+#if defined(CSRG_BASED) || defined(MACH386) || defined(__GNU__)
     saved_nice = getpriority(PRIO_PROCESS, 0);
     setpriority(PRIO_PROCESS, 0, -20);
 #endif
@@ -133,7 +133,7 @@
         (*SaveScreen)(NULL, TRUE);
     }
 
-#if defined(CSRG_BASED) || defined(MACH386)
+#if defined(CSRG_BASED) || defined(MACH386) || defined(__GNU__)
     setpriority(PRIO_PROCESS, 0, saved_nice);
 #endif
 #if defined(SYSV) || defined(SVR4) || defined(linux)
Index: xc/programs/Xserver/hw/xfree86/common_hw/xf86_PCI.c
diff -u xc/programs/Xserver/hw/xfree86/common_hw/xf86_PCI.c:3.16.2.9 xc/programs/Xserver/hw/xfree86/common_hw/xf86_PCI.c:3.16.2.10
--- xc/programs/Xserver/hw/xfree86/common_hw/xf86_PCI.c:3.16.2.9	Tue Nov 10 22:55:38 1998
+++ xc/programs/Xserver/hw/xfree86/common_hw/xf86_PCI.c	Mon Nov 30 23:16:54 1998
@@ -1,4 +1,4 @@
-/* $XFree86: xc/programs/Xserver/hw/xfree86/common_hw/xf86_PCI.c,v 3.16.2.9 1998/11/10 11:55:38 dawes Exp $ */
+/* $XFree86: xc/programs/Xserver/hw/xfree86/common_hw/xf86_PCI.c,v 3.16.2.10 1998/11/30 12:16:54 dawes Exp $ */
 /*
  * Copyright 1995 by Robin Cutshaw <robin@XFree86.Org>
  *
@@ -1128,15 +1128,15 @@
 
 	    pcr._bus = pcibuses[pcibusidx];
 
-	    if (pciMfDev(pcr._bus, pcr._cardnum))
-		maxfunc = 7;
-
 	    tag = pcibusTag(pcr._bus, pcr._cardnum, 0);
 	    for (pcr._func = 0; pcr._func <= maxfunc; pcr._func++) {
 		tag = pcibusFTag(tag, pcr._func);
 		pcr._device_vendor = pcibusRead(tag, PCI_ID_REG);
 		if (pcr._device_vendor == 0xffffffff)	/* nothing there */
 		    continue;
+
+		if (pciMfDev(pcr._bus, pcr._cardnum))
+		    maxfunc = 7;
 
 		pcr._status_command = pcibusRead(tag, PCI_CMD_STAT_REG);
 		pcr._class_revision = pcibusRead(tag, PCI_CLASS_REG);
Index: xc/programs/Xserver/hw/xfree86/doc/Imakefile
diff -u xc/programs/Xserver/hw/xfree86/doc/Imakefile:3.44.2.9 xc/programs/Xserver/hw/xfree86/doc/Imakefile:3.44.2.10
--- xc/programs/Xserver/hw/xfree86/doc/Imakefile:3.44.2.9	Sat Nov 14 00:02:43 1998
+++ xc/programs/Xserver/hw/xfree86/doc/Imakefile	Fri Dec  4 12:39:16 1998
@@ -4,7 +4,7 @@
 
 
 
-XCOMM $XFree86: xc/programs/Xserver/hw/xfree86/doc/Imakefile,v 3.44.2.9 1998/11/13 13:02:43 dawes Exp $
+XCOMM $XFree86: xc/programs/Xserver/hw/xfree86/doc/Imakefile,v 3.44.2.10 1998/12/04 01:39:16 dawes Exp $
 
 #include <Server.tmpl>
 #include <lnxdoc.rules>
@@ -84,7 +84,7 @@
             README.DECtga  README.apm README.rendition README.epson \
             README.chips README.cirrus README.Video7 README.P9000 README.agx \
             README.S3 README.S3V README.SiS README.W32 README.Oak \
-            README.Mach32 \
+            README.I128 README.Mach32 \
             README.Mach64 README.ark README.MGA README.NVIDIA README.mouse \
 	    README.neo README.rendition README.3DLabs README.cyrix
 
Index: xc/programs/Xserver/hw/xfree86/doc/README
diff -u xc/programs/Xserver/hw/xfree86/doc/README:3.76.2.38 xc/programs/Xserver/hw/xfree86/doc/README:3.76.2.44
--- xc/programs/Xserver/hw/xfree86/doc/README:3.76.2.38	Thu Nov 19 23:01:00 1998
+++ xc/programs/Xserver/hw/xfree86/doc/README	Tue Jan  5 23:06:33 1999
@@ -7,11 +7,11 @@
 
 
 
-                         README for XFree86[tm] 3.3.3
+                        README for XFree86[tm] 3.3.3.1
 
                            The XFree86 Project, Inc
 
-                               19 November 1998
+                               20 December 1998
 
 
 
@@ -19,15 +19,15 @@
 
      XFree86 is a port of X11R6.3 that supports several Unix and Unix-like
      operating systems on Intel and other platforms.  This release is a
-     full release, fixing a number of bugs and adding support for lots of
-     new cards compared to XFree86-3.3.2.  The release is available as
-     source patches against the X Consortium X11R6.3 code and the XFree86
-     3.3.2 release.  Binary distributions for many architectures are also
-     available, including a binary upgrade for XFree86 3.3.2.
+     quick update to XFree86 3.3.3, fixing a number of bugs that were
+     found after releasing it.  The release is available as source patches
+     against the X Consortium X11R6.3 code and the XFree86 3.3.3 release.
+     Binary distributions for many architectures are also available,
+     including a binary upgrade for XFree86 3.3.3.
 
 
 
-1.  What's new in XFree86 3.3.3
+1.  What's new in XFree86 3.3.3.1
 
 For a summary of new features in this release, please refer to the RELNOTES
 file.  For a detailed list of changes, refer to the CHANGELOG file in the
@@ -61,13 +61,13 @@
 
 
 
-README for XFree86[tm] 3.3.3                                                  1
+README for XFree86[tm] 3.3.3.1                                                1
 
 
 
 
 
-README for XFree86[tm] 3.3.3                                                  2
+README for XFree86[tm] 3.3.3.1                                                2
 
 
 
@@ -90,12 +90,12 @@
 
       Others:
 
-               o NetBSD 1.0, 1.1, 1.2, 1.2.1, 1.3, 1.3.1, 1.3.2
+               o NetBSD 1.0, 1.1, 1.2, 1.2.1, 1.3, 1.3.1, 1.3.2, 1.3.3
 
-               o OpenBSD 2.0, 2.1
+               o OpenBSD 2.0, 2.1, 2.2, 2.3, 2.4
 
                o FreeBSD 2.0.5, 2.1, 2.1.5, 2.1.6, 2.1.7, 2.1.7.1, 2.2, 2.2.1,
-                 2.2.2, 2.2.5, 2.2.6, 2,2,7, 3.0
+                 2.2.2, 2.2.5, 2.2.6, 2,2,7, 2.2.8, 3.0
 
                o Linux (Intel x86, DEC Alpha/AXP and m68k)
 
@@ -111,7 +111,7 @@
       PC98:
 
                o FreeBSD(98) 2.0.5, 2.1, 2.1.5, 2.1.7.1, 2.2, 2.2.1, 2.2.2,
-                 2.2.5, 2.2.6, 2,2,7
+                 2.2.5, 2.2.6, 2,2,7, 2.2.8, 3.0
 
                o NetBSD/pc98 (based on NetBSD 1.2, 1.2.1, 1.3, 1.3.1, 1.3.2)
 
@@ -122,7 +122,7 @@
 
 3.  Supported video-card chip-sets
 
-At this time, XFree86 3.3.3 supports the following chipsets:
+At this time, XFree86 3.3.3.1 supports the following chipsets:
 
 
 
@@ -133,7 +133,7 @@
 
 
 
-README for XFree86[tm] 3.3.3                                                  3
+README for XFree86[tm] 3.3.3.1                                                3
 
 
 
@@ -199,7 +199,7 @@
 
 
 
-README for XFree86[tm] 3.3.3                                                  4
+README for XFree86[tm] 3.3.3.1                                                4
 
 
 
@@ -210,7 +210,7 @@
             2200, 2160, 2097, 2093, 2090, 2070
 
       Number Nine
-            I128 (series I and II), Revolution 3D (T2R)
+            I128 (series I, II and IV), Revolution 3D (T2R)
 
       NVidia/SGS Thomson
             NV1, STG2000, RIVA128, Riva TNT
@@ -265,7 +265,7 @@
 
 
 
-README for XFree86[tm] 3.3.3                                                  5
+README for XFree86[tm] 3.3.3.1                                                5
 
 
 
@@ -331,7 +331,7 @@
 
 
 
-README for XFree86[tm] 3.3.3                                                  6
+README for XFree86[tm] 3.3.3.1                                                6
 
 
 
@@ -397,7 +397,7 @@
 
 
 
-README for XFree86[tm] 3.3.3                                                  7
+README for XFree86[tm] 3.3.3.1                                                7
 
 
 
@@ -463,7 +463,7 @@
 
 
 
-README for XFree86[tm] 3.3.3                                                  8
+README for XFree86[tm] 3.3.3.1                                                8
 
 
 
@@ -529,7 +529,7 @@
 
 
 
-README for XFree86[tm] 3.3.3                                                  9
+README for XFree86[tm] 3.3.3.1                                                9
 
 
 
@@ -595,7 +595,7 @@
 
 
 
-README for XFree86[tm] 3.3.3                                                 10
+README for XFree86[tm] 3.3.3.1                                               10
 
 
 
@@ -661,7 +661,7 @@
 
 
 
-README for XFree86[tm] 3.3.3                                                 11
+README for XFree86[tm] 3.3.3.1                                               11
 
 
 
@@ -727,7 +727,7 @@
 
 
 
-README for XFree86[tm] 3.3.3                                                 12
+README for XFree86[tm] 3.3.3.1                                               12
 
 
 
@@ -793,7 +793,7 @@
 
 
 
-README for XFree86[tm] 3.3.3                                                 13
+README for XFree86[tm] 3.3.3.1                                               13
 
 
 
@@ -859,7 +859,7 @@
 
 
 
-README for XFree86[tm] 3.3.3                                                 14
+README for XFree86[tm] 3.3.3.1                                               14
 
 
 
@@ -925,7 +925,7 @@
 
 
 
-README for XFree86[tm] 3.3.3                                                 15
+README for XFree86[tm] 3.3.3.1                                               15
 
 
 
@@ -991,7 +991,7 @@
 
 
 
-README for XFree86[tm] 3.3.3                                                 16
+README for XFree86[tm] 3.3.3.1                                               16
 
 
 
@@ -1029,7 +1029,7 @@
                o Joerg Wunsch <joerg_wunsch@uriah.sax.de> (ET3000 banked mono),
 
                o Thomas Dickey <dickey@clark.net> (xterm "new" model ANSI col-
-                 ors and VT220, VT520 emulation).
+                 ors and VT220, VT52 emulation).
 
                o Eric Raymond <esr@snark.thyrsus.com> (new video mode documen-
                  tation),
@@ -1057,7 +1057,7 @@
 
 
 
-README for XFree86[tm] 3.3.3                                                 17
+README for XFree86[tm] 3.3.3.1                                               17
 
 
 
@@ -1069,6 +1069,8 @@
 
    o Rich Murphey <rich@XFree86.org>
 
+   o Takaaki Nomura <nomura@XFree86.org>
+
    o Jon Tombs <tombs@XFree86.org>
 
    o David Wexelblat <dwex@XFree86.org>
@@ -1113,7 +1115,6 @@
 
    o David Dawes, President and Secretary
 
-   o Dirk Hohndel, Vice-President
 
 
 
@@ -1122,10 +1123,11 @@
 
 
 
+README for XFree86[tm] 3.3.3.1                                               18
 
-README for XFree86[tm] 3.3.3                                                 18
 
 
+   o Dirk Hohndel, Vice-President
 
    o Glenn Lai, Director
 
@@ -1179,7 +1181,6 @@
           must be acknowledged in any accompanying documentation).  Binary
           packages for the OSs we support which are simply compiled from our
           internal source without significant added value are explicitly NOT
-          allowed.
 
 
 
@@ -1188,10 +1189,11 @@
 
 
 
+README for XFree86[tm] 3.3.3.1                                               19
 
-README for XFree86[tm] 3.3.3                                                 19
 
 
+          allowed.
 
 Here is a list of the organizations and individuals who have provided sponsor-
 ship to The XFree86 Project, Inc, either by financial contribution or by the
@@ -1245,7 +1247,6 @@
 
    o Hercules Computer Technology, Inc. <URL:http://www.hercules.com/>
 
-   o Ralf Hockens
 
 
 
@@ -1254,10 +1255,11 @@
 
 
 
+README for XFree86[tm] 3.3.3.1                                               20
 
-README for XFree86[tm] 3.3.3                                                 20
 
 
+   o Ralf Hockens
 
    o Dirk Hohndel
 
@@ -1311,7 +1313,6 @@
 
    o Tekelec Airtronic GmbH <URL:http://www.tekelec.com>, Muenchen, Germany
 
-   o Jim Tsillas
 
 
 
@@ -1320,10 +1321,11 @@
 
 
 
+README for XFree86[tm] 3.3.3.1                                               21
 
-README for XFree86[tm] 3.3.3                                                 21
 
 
+   o Jim Tsillas
 
    o Trans-Ameritech Enterprises, Inc., Santa Clara, CA
 
@@ -1344,7 +1346,7 @@
 8.  Source and binary archive sites
 
 Source patches are available to upgrade X11R6.3 PL2 from the X Consortium (now
-The Open Group) to XFree86 3.3.3.  Binaries for many OSs are also available.
+The Open Group) to XFree86 3.3.3.1.  Binaries for many OSs are also available.
 The distribution is available from:
 
    o ftp://ftp.XFree86.org/pub/XFree86
@@ -1377,7 +1379,6 @@
 
         o ftp://ftp.fee.vutbr.cz/pub/XFree86 (source patches and binaries)
 
-        o ftp://ftp.gwdg.de/pub/xfree86/XFree86 (source and binaries)
 
 
 
@@ -1386,10 +1387,11 @@
 
 
 
+README for XFree86[tm] 3.3.3.1                                               22
 
-README for XFree86[tm] 3.3.3                                                 22
 
 
+        o ftp://ftp.gwdg.de/pub/xfree86/XFree86 (source and binaries)
 
         o ftp://ftp.mpi-sb.mpg.de/pub/X/mirror/ftp.xfree86.org (source and
           binaries)
@@ -1425,11 +1427,11 @@
         o ftp://ftp.kreonet.re.kr/pub/Linux/xfree86 (source and binaries)
 
 
-Ensure that you are getting XFree86 3.3.3 - some of these sites may archive
+Ensure that you are getting XFree86 3.3.3.1 - some of these sites may archive
 older releases as well.  Check the RELNOTES to find which files you need to
 take from the archive.
 
-     Generated from XFree86: xc/programs/Xserver/hw/xfree86/doc/sgml/README.sgml,v 3.75.2.41 1998/11/19 10:08:14 dawes Exp $
+     Generated from XFree86: xc/programs/Xserver/hw/xfree86/doc/sgml/README.sgml,v 3.75.2.46 1999/01/05 07:15:48 hohndel Exp $
 
 
 
@@ -1451,9 +1453,7 @@
 
 
 
-
-
-README for XFree86[tm] 3.3.3                                                 23
+README for XFree86[tm] 3.3.3.1                                               23
 
 
 
@@ -1527,7 +1527,7 @@
 
 
 
-1. What's new in XFree86 3.3.3 .............................................. 1
+1. What's new in XFree86 3.3.3.1 ............................................ 1
 
 2. Systems XFree86 has been tested on ....................................... 1
 
@@ -1583,4 +1583,4 @@
 
 
 
-$XFree86: xc/programs/Xserver/hw/xfree86/doc/README,v 3.76.2.38 1998/11/19 12:01:00 dawes Exp $
+$XFree86: xc/programs/Xserver/hw/xfree86/doc/README,v 3.76.2.44 1999/01/05 12:06:33 dawes Exp $
Index: xc/programs/Xserver/hw/xfree86/doc/README.I128
diff -u /dev/null xc/programs/Xserver/hw/xfree86/doc/README.I128:1.1.2.5
--- /dev/null	Wed Jan  6 00:31:12 1999
+++ xc/programs/Xserver/hw/xfree86/doc/README.I128	Tue Jan  5 23:06:34 1999
@@ -0,0 +1,266 @@
+
+
+
+
+
+
+
+
+
+                    Information for Number Nine I128 Users
+
+                           The XFree86 Project Inc.
+
+                                24 October 1998
+
+
+
+1.  Supported hardware
+
+The current accelerated I128 server supports
+
+   o Imagine 128 (I128 with Texas Instruments TVP3025 or IBM528 RAMDAC). It has
+     been tested with with 4MB of VRAM.
+
+   o Imagine 128 Ticket 2 Ride (I128-T2R with IBM526 or 528 RAMDAC). It has
+     been tested with 4 MB and 8 MB of VRAM and DRAM.
+
+   o Imagine 128 Revolution 3D (I128-R3D with IBM526 RAMDAC).  It has been
+     tested with 4 MB, 8 MB, and 16 MB of WRAM or SGRAM.
+
+   o Imagine 128 Revolution IV (I128-R4 with SILVERHAMMER RAMDAC).  It has been
+     tested with 32 MB.
+
+
+2.  Features:
+
+   o uses linear frame buffer
+
+   o Resolutions up to the maximum supported by the card should be possible.
+
+   o 8 bpp, 16 bpp (depth 15 and 16), and 32 bpp (depth 24, sparse) are sup-
+     ported.
+
+   o supports RGB Sync-on-Green
+
+   o Makes use of the graphics accelerator.
+
+
+3.  Configuration:
+
+The I128 driver should auto-detect all supported hardware so you needn't have
+anything other than the Identifier in the Section "Device" of the XF86Config
+file.  When running the XF86Setup or xf86config programs one merely needs to
+select an I128 card so that the correct server will be used.  One need not and
+should not specify a RAMDAC, clockchip or allow the setup program to probe for
+clocks. The driver will auto-detect the amount of video ram present.
+
+The following Section "Device" options are supported by the MGA driver:
+
+   o Option "dac_8_bit"
+
+
+
+Information for Number Nine I128 Users                                        1
+
+
+
+
+
+Information for Number Nine I128 Users                                        2
+
+
+
+     Will enable 8-bit DAC support.
+
+   o Option "no_accel"
+
+     Will disable all hardware acceleration.
+
+   o Option "sync_on_green"
+
+     Will enable syncing on green for sync-on-green monitors (these are typi-
+     cally fixed frequency workstation monitors).
+
+
+4.  Mode lines for the SiliconGraphics flat panel display:
+
+   o These mode lines are required for use with the T2R4 (Rev 4) and the Sili-
+     conGraphics Flat Panel display.
+
+   o Modeline "1600x1024d32" 103.125  1600 1600 1656 1664 1024 1024 1029 1030
+     HSkew 7 +Hsync +Vsync
+
+   o Modeline "1600x1024d16" 103.125  1600 1600 1656 1664 1024 1024 1029 1030
+     HSkew 5 +Hsync +Vsync
+
+   o Modeline "1600x1024d08" 103.125  1600 1600 1656 1664 1024 1024 1029 1030
+     HSkew 1 +Hsync +Vsync
+
+   o Modeline "800x512d32"   54.375   800 800 840 848 512 512 514 515 HSkew 7
+     DoubleScan +Hsync +Vsync
+
+   o Modeline "800x512d16"   54.375   800 800 840 848 512 512 514 515 HSkew 5
+     DoubleScan +Hsync +Vsync
+
+   o Modeline "800x512d08"   54.375   800 800 840 848 512 512 514 515 HSkew 1
+     DoubleScan +Hsync +Vsync
+
+
+5.  Author(s)
+
+Robin Cutshaw, robin@XFree86.Org
+
+and special help from:
+
+   o Galen Brooks, galen@nine.com
+
+     Generated from XFree86: xc/programs/Xserver/hw/xfree86/doc/sgml/I128.sgml,v 1.1.2.3 1999/01/02 02:32:16 robin Exp $
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+Information for Number Nine I128 Users                                        3
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+                                   CONTENTS
+
+
+
+1. Supported hardware ....................................................... 1
+
+2. Features: ................................................................ 1
+
+3. Configuration: ........................................................... 1
+
+4. Mode lines for the SiliconGraphics flat panel display: ................... 2
+
+5. Author(s) ................................................................ 2
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+                                       i
+
+
+
+$XFree86: xc/programs/Xserver/hw/xfree86/doc/README.I128,v 1.1.2.5 1999/01/05 12:06:34 dawes Exp $
Index: xc/programs/Xserver/hw/xfree86/doc/README.Linux
diff -u xc/programs/Xserver/hw/xfree86/doc/README.Linux:3.21.2.8 xc/programs/Xserver/hw/xfree86/doc/README.Linux:3.21.2.10
--- xc/programs/Xserver/hw/xfree86/doc/README.Linux:3.21.2.8	Sat Nov 14 17:46:45 1998
+++ xc/programs/Xserver/hw/xfree86/doc/README.Linux	Tue Dec 29 18:54:23 1998
@@ -11,20 +11,17 @@
 
                          Orest Zborowski, Dirk Hohndel
 
-                               November 7, 1998
+                               December 23, 1998
 
 
 
 1.  Linux versions on which XFree86 has been tested
 
-XFree86 has been tested with Linux version 2.0.32 and several 2.1.x kernels.
-It is known not to compile with kernel sources newer then somewhere around
-2.1.70, due to incompatibilities in the joystick driver. Except for the joy-
-stick driver, it works just fine with all 2.1.x kernels tested (including
-2.1.88). It should work with any version since 1.0 without change. The binaries
-and libraries are based on the 5.3.12 Elf C libraries, and the 1.7.14 dynamic
-linker ld.so. You will at least need the 5.2.x Elf C libraries to successfully
-use the servers.
+XFree86 has been tested with Linux version 2.0.36 and several 2.1.x kernels.
+It works just fine with all 2.1.x kernels tested (including 2.1.131). It should
+work with any version since 1.0 without change. The binaries and libraries are
+based on the 5.3.12 Elf C libraries, and the 1.7.14 dynamic linker ld.so. You
+will at least need the 5.2.x Elf C libraries to successfully use the servers.
 
 
 2.  Backwards Compatibility
@@ -59,6 +56,9 @@
 
 XFree86 requires about 4mb of virtual memory to run, although having 8mb of RAM
 is probably the minimum comfortable configuration. A 387 coprocessor is helpful
+for 386 machines, although greater gains in interactive performance are
+obtained with an increase in physical memory.  Also, a faster graphics card,
+bus or RAM, will improve server performance.
 
 
 Information for Linux Users                                                   1
@@ -71,10 +71,6 @@
 
 
 
-for 386 machines, although greater gains in interactive performance are
-obtained with an increase in physical memory.  Also, a faster graphics card,
-bus or RAM, will improve server performance.
-
 After unpacking the tar files, you need to include /usr/X11R6/lib in
 /etc/ld.so.conf (where it should already be by default) or in your
 LD_LIBRARY_PATH environment variable. Also, the configuration file
@@ -133,6 +129,10 @@
 
 
 
+
+
+
+
 Information for Linux Users                                                   3
 
 
@@ -160,121 +160,7 @@
 The xdm binary provided should run with both shadow- and non-shadow password
 systems.
 
-
-6.  xterm
-
-The XFree86-3.3.3 binary release contains an xterm binary that has been linked
-statically against libtermcap. This was done to make sure that it will cor-
-rectly work with all distributions, regardless whether they rely on libtermcap
-or libncurses. Contrary to the xterm binaries in some beta version following
-XFree86-3.1.2, this binary does not rely on a recent libncurses being installed
-on your system.
-
-
-7.  Input devices
-
-XFree86 now support the dynamic loading of drivers for external input devices
-using the XInput extension. Currently supported devices are:
-
-   o Joystick (xf86Jstk.so)
-
-   o Wacom tablets (Wacom IV protocol only, xf86Wacom.so)
-
-   o SummaSketch tablets (xf86Summa.so)
-
-   o Elographics touchscreen (xf86Elo.so)
-
-   o AceCad ADVANCEDigitizer (xf86AceCad.so)
-
-   o MicroTouch TouchPen (xf86MuTouch.so)
-
-   o SGI dial box (xf86Dial.so)
-
-To use a specific device, add the line
-
-
-
-
-
-
-
-
-Information for Linux Users                                                   4
-
-
-
-     load "module"
-
-
-in the Module section of XF86Config, where module is the name of the .so file
-corresponding to your device.  You also need to set up a XInput section in
-XF86Config.  Refer to the XF86Config(5) man page for detailed configuration
-instructions.
-
-You can then change the device used to drive the X pointer with the xset-
-pointer(1) command.
-
-For joystick support, you'll need to install the joystick device driver in the
-kernel.
-
-7.1  Configuring PEX, XIE and GLX extensions
-
-The PEX, XIE and GLX extensions are now supported as external modules.  If you
-want to have access to these extensions, add the following lines to the Module
-section of XF86Config:
-
-        load    "pex5.so"
-        load    "xie.so"
-
-
-For GLX you need to get the appropriate GLX modules, first. They are, at this
-time, not part of the XFree86 distribution.
-
-
-8.  Compiling XFree86
-
-There are no special instructions required for compiling XFree86.  This version
-was compiled with gcc-2.7.2.1, the 5.3.12 Elf libraries and the 1.7.14 shared,
-dynamic linker ld.so.  The server has been compiled with -m486, which optimizes
-it for the 486 processor, but the binary will run on the 386 processor (there
-is a slight increase in binary size over using -m386, but no loss of perfor-
-mance).
-
-All extensions and clients have been ported and tested. By default, the servers
-are compiled without any extra extensions (PEX, XIE, etc), but libraries for
-those extensions are always generated. They can be loaded at runtime, see the
-XFree86 man page for details. By modifying site.def, extra extensions can be
-compiled into the server.  Alternately, the link kit can be used to craft modi-
-fied servers.
-
-If an aout version of XFree86 is to be built and patches are applied which sig-
-nificantly change the libraries, modified jump_xxx files will be needed. Those
-can be generated according to instructions given in the DLL tools package, and
-will be made available as XFree86 patches.
-
-The JUMP_xxx defines used to compile the X libraries can also be used to com-
-pile external X shared libraries, like Xaw3d. Detailed instructions are pro-
-vided in /usr/X11R6/lib/X11/config/lnxLib.rules, where the X library defini-
-tions are provided, as an example.
-
-
-
-
-
-
-
-
-
-Information for Linux Users                                                   5
-
-
-
-9.  Bug Notification
-
-Bug reports should be sent to XFree86@XFree86.org or posted to the comp.win-
-dows.x.i386unix newsgroup.
-
-     Generated from XFree86: xc/programs/Xserver/hw/xfree86/doc/sgml/Linux.sgml,v 3.13.2.6 1998/11/08 09:06:39 dawes Exp $
+     Generated from XFree86: xc/programs/Xserver/hw/xfree86/doc/sgml/Linux.sgml,v 3.13.2.7 1998/12/23 13:36:26 hohndel Exp $
 
 
 
@@ -313,25 +199,7 @@
 
 
 
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-Information for Linux Users                                                   6
+Information for Linux Users                                                   4
 
 
 
@@ -415,14 +283,14 @@
 
 5. Installing Xdm, the display manager ...................................... 3
 
-6. xterm .................................................................... 3
 
-7. Input devices ............................................................ 3
-   7.1 Configuring PEX, XIE and GLX extensions .............................. 4
 
-8. Compiling XFree86  ....................................................... 4
 
-9. Bug Notification  ........................................................ 5
+
+
+
+
+
 
 
 
@@ -461,4 +329,4 @@
 
 
 
-$XFree86: xc/programs/Xserver/hw/xfree86/doc/README.Linux,v 3.21.2.8 1998/11/14 06:46:45 dawes Exp $
+$XFree86: xc/programs/Xserver/hw/xfree86/doc/README.Linux,v 3.21.2.10 1998/12/29 07:54:23 hohndel Exp $
Index: xc/programs/Xserver/hw/xfree86/doc/README.LynxOS
diff -u xc/programs/Xserver/hw/xfree86/doc/README.LynxOS:3.18.2.9 xc/programs/Xserver/hw/xfree86/doc/README.LynxOS:3.18.2.10
--- xc/programs/Xserver/hw/xfree86/doc/README.LynxOS:3.18.2.9	Sat Nov 14 17:46:45 1998
+++ xc/programs/Xserver/hw/xfree86/doc/README.LynxOS	Tue Dec 29 19:00:07 1998
@@ -7,11 +7,11 @@
 
 
 
-                      README for XFree86 3.3.3 on LynxOS
+                         README for XFree86 on LynxOS
 
                                 Thomas Mueller
 
-                       Last modified on: 10 October 1998
+                      Last modified on: 29 December 1998
 
 
 
@@ -30,7 +30,7 @@
 
 ftp://ftp.XFree86.org/pub/XFree86/current
 
-Binaries of the 3.3.3 release for LynxOS AT are available from:
+Binaries of XFree86 for LynxOS AT are available from:
 
 ftp://ftp.XFree86.org/pub/XFree86/current/binaries/LynxOS
 
@@ -55,19 +55,19 @@
 
 2.  Installing the Binaries
 
-Please refer to section "Installing the XFree86 3.3.3 Release" of the Release
+Please refer to section "Installing the XFree86 3.3.3.1 Release" of the Release
 Notes for detailed installation instructions.
 
 If you plan to install XF86Setup you'll have to install X333prog as well since
 
 
-README for XFree86 3.3.3 on LynxOS                                            1
+README for XFree86 on LynxOS                                                  1
 
 
 
 
 
-README for XFree86 3.3.3 on LynxOS                                            2
+README for XFree86 on LynxOS                                                  2
 
 
 
@@ -133,7 +133,7 @@
 
 
 
-README for XFree86 3.3.3 on LynxOS                                            3
+README for XFree86 on LynxOS                                                  3
 
 
 
@@ -153,12 +153,12 @@
           # reboot -N
 
 
-3.3  Mouse support in 3.3.3
+3.3  Mouse support in XFree86
 
-XFree86 3.3.3 includes support for PnP mice (see also Mouse Support in
-XFree86). The current LynxOS TTY device driver doesn't allow the necessary
-manipulation of the RTS line and therefore the support for PnP mice has been
-disabled for LynxOS.
+XFree86 includes support for PnP mice (see also Mouse Support in XFree86). The
+current LynxOS TTY device driver doesn't allow the necessary manipulation of
+the RTS line and therefore the support for PnP mice has been disabled for
+LynxOS.
 
 3.4  Bus mouse drivers
 
@@ -199,7 +199,7 @@
 
 
 
-README for XFree86 3.3.3 on LynxOS                                            4
+README for XFree86 on LynxOS                                                  4
 
 
 
@@ -265,7 +265,7 @@
 
 
 
-README for XFree86 3.3.3 on LynxOS                                            5
+README for XFree86 on LynxOS                                                  5
 
 
 
@@ -331,7 +331,7 @@
 
 
 
-README for XFree86 3.3.3 on LynxOS                                            6
+README for XFree86 on LynxOS                                                  6
 
 
 
@@ -397,7 +397,7 @@
 
 
 
-README for XFree86 3.3.3 on LynxOS                                            7
+README for XFree86 on LynxOS                                                  7
 
 
 
@@ -463,7 +463,7 @@
 
 
 
-README for XFree86 3.3.3 on LynxOS                                            8
+README for XFree86 on LynxOS                                                  8
 
 
 
@@ -529,7 +529,7 @@
 
 
 
-README for XFree86 3.3.3 on LynxOS                                            9
+README for XFree86 on LynxOS                                                  9
 
 
 
@@ -595,7 +595,7 @@
 
 
 
-README for XFree86 3.3.3 on LynxOS                                           10
+README for XFree86 on LynxOS                                                 10
 
 
 
@@ -661,11 +661,11 @@
 
 
 
-README for XFree86 3.3.3 on LynxOS                                           11
+README for XFree86 on LynxOS                                                 11
 
 
 
-     Generated from XFree86: xc/programs/Xserver/hw/xfree86/doc/sgml/LynxOS.sgml,v 3.14.2.8 1998/11/07 13:52:41 dawes Exp $
+     Generated from XFree86: xc/programs/Xserver/hw/xfree86/doc/sgml/LynxOS.sgml,v 3.14.2.9 1998/12/29 07:54:27 hohndel Exp $
 
 
 
@@ -727,7 +727,7 @@
 
 
 
-README for XFree86 3.3.3 on LynxOS                                           12
+README for XFree86 on LynxOS                                                 12
 
 
 
@@ -808,7 +808,7 @@
 3. Running XFree86 .......................................................... 2
    3.1 System requirements .................................................. 2
    3.2 System tuning ........................................................ 2
-   3.3 Mouse support in 3.3.3 ............................................... 3
+   3.3 Mouse support in XFree86 ............................................. 3
    3.4 Bus mouse drivers .................................................... 3
    3.5 ATC console driver and VT switching .................................. 3
    3.6 X Server debug diagnostics output and other VT peculiarities ......... 4
@@ -857,4 +857,4 @@
 
 
 
-$XFree86: xc/programs/Xserver/hw/xfree86/doc/README.LynxOS,v 3.18.2.9 1998/11/14 06:46:45 dawes Exp $
+$XFree86: xc/programs/Xserver/hw/xfree86/doc/README.LynxOS,v 3.18.2.10 1998/12/29 08:00:07 hohndel Exp $
Index: xc/programs/Xserver/hw/xfree86/doc/README.MGA
diff -u xc/programs/Xserver/hw/xfree86/doc/README.MGA:3.6.2.14 xc/programs/Xserver/hw/xfree86/doc/README.MGA:3.6.2.16
--- xc/programs/Xserver/hw/xfree86/doc/README.MGA:3.6.2.14	Thu Nov 19 23:01:01 1998
+++ xc/programs/Xserver/hw/xfree86/doc/README.MGA	Wed Dec 30 21:09:42 1998
@@ -11,7 +11,7 @@
 
                            The XFree86 Project Inc.
 
-                                24 October 1998
+                               30 December 1998
 
 
 
@@ -74,7 +74,7 @@
    o supports the XF86_DGA extension
 
    o Makes extensive use of the graphics accelerator.  This server is very well
-     accelerated, and is one of the fastest XFree86 3.3.3 Xservers.
+     accelerated, and is one of the fastest XFree86 X servers.
 
 
 3.  Configuration:
@@ -145,8 +145,8 @@
 
    o Temporary loss of monitor sync when the cursor shape changes on Millennium
      and Millennium II.  The hardware cursor has been enabled by default in
-     3.3.3. This seems to cause some problems on a minority of systems.  If you
-     experience problems with this on your system, please put:
+     3.3.3.1. This seems to cause some problems on a minority of systems.  If
+     you experience problems with this on your system, please put:
 
                Option "sw_cursor"
 
@@ -163,7 +163,8 @@
 
 
      in the Section "Device" of the XF86Config file to disable the hardware
-     cursor.
+     cursor. This should be fixed in XFree86 3.3.3.1 as in cases like this the
+     software cursor should be used automatically.
 
    o the driver doesn't support some values of HTotal parameter in Modelines in
      the XF86Config file. If you get flickering vertical stripes on the screen,
@@ -198,11 +199,21 @@
 
 
 
-
 Information for Matrox Users                                                  4
 
 
 
+   o With virtual screens that use 8MB of memory or more (e.g., 2048x2048 at
+     16bpp) there can be cursor distortions when panning the screen vertically.
+     If that occurs, please put
+
+               Option "sw_cursor"
+
+
+     in the Section "Device" of the XF86Config file to disable the hardware
+     cursor.
+
+
 5.  Authors
 
 Radoslaw Kapitan, kapitan@student.uci.agh.edu.pl
@@ -233,18 +244,7 @@
 
    o Doug Merritt, doug@netcom.com
 
-     Generated from XFree86: xc/programs/Xserver/hw/xfree86/doc/sgml/MGA.sgml,v 3.4.2.14 1998/11/19 10:08:14 dawes Exp $
-
-
-
-
-
-
-
-
-
-
-
+     Generated from XFree86: xc/programs/Xserver/hw/xfree86/doc/sgml/MGA.sgml,v 3.4.2.15 1998/12/30 09:14:45 hohndel Exp $
 
 
 
@@ -395,4 +395,4 @@
 
 
 
-$XFree86: xc/programs/Xserver/hw/xfree86/doc/README.MGA,v 3.6.2.14 1998/11/19 12:01:01 dawes Exp $
+$XFree86: xc/programs/Xserver/hw/xfree86/doc/README.MGA,v 3.6.2.16 1998/12/30 10:09:42 dawes Exp $
Index: xc/programs/Xserver/hw/xfree86/doc/README.NVIDIA
diff -u xc/programs/Xserver/hw/xfree86/doc/README.NVIDIA:1.1.2.2 xc/programs/Xserver/hw/xfree86/doc/README.NVIDIA:1.1.2.4
--- xc/programs/Xserver/hw/xfree86/doc/README.NVIDIA:1.1.2.2	Sat Nov 14 17:46:49 1998
+++ xc/programs/Xserver/hw/xfree86/doc/README.NVIDIA	Tue Dec 29 18:54:24 1998
@@ -263,4 +263,4 @@
 
 
 
-$XFree86: xc/programs/Xserver/hw/xfree86/doc/README.NVIDIA,v 1.1.2.2 1998/11/14 06:46:49 dawes Exp $
+$XFree86: xc/programs/Xserver/hw/xfree86/doc/README.NVIDIA,v 1.1.2.4 1998/12/29 07:54:24 hohndel Exp $
Index: xc/programs/Xserver/hw/xfree86/doc/README.NetBSD
diff -u xc/programs/Xserver/hw/xfree86/doc/README.NetBSD:3.57.2.11 xc/programs/Xserver/hw/xfree86/doc/README.NetBSD:3.57.2.12
--- xc/programs/Xserver/hw/xfree86/doc/README.NetBSD:3.57.2.11	Sat Nov 14 17:46:49 1998
+++ xc/programs/Xserver/hw/xfree86/doc/README.NetBSD	Tue Dec 29 19:00:07 1998
@@ -7,22 +7,22 @@
 
 
 
-                      README for XFree86 3.3.3 on NetBSD
+                         README for XFree86 on NetBSD
 
  Rich  Murphey, David Dawes, Marc  Wandschneider, Mark  Weaver, Matthieu Herrb
 
-                       Last modified on: 17 October 1998
+                      Last modified on: 29 December 1998
 
 
 
 1.  What and Where is XFree86?
 
-XFree86 3.3.3 is a port of X11R6.3 that supports several versions of Intel-
-based Unix.  It is derived from X386 1.2, which was the X server distributed
-with X11R5.  This release consists of many new features and performance
-improvements as well as many bug fixes.  The release is available as source
-patches against the X Consortium X11R6.3 code, as well as binary distributions
-for many architectures.
+XFree86 is a port of X11R6.3 that supports several versions of Intel-based
+Unix.  It is derived from X386 1.2, which was the X server distributed with
+X11R5.  This release consists of many new features and performance improvements
+as well as many bug fixes.  The release is available as source patches against
+the X Consortium X11R6.3 code, as well as binary distributions for many archi-
+tectures.
 
 See the Copyright Notice.
 
@@ -45,29 +45,29 @@
 version of NetBSD first.
 
 If you don't upgrade, you'll have to build XFree86 from the sources.  XFree86
-3.3.3 should compile cleanly under earlier versions of NetBSD, although this
-has not been tested.
+should compile cleanly under earlier versions of NetBSD, although this has not
+been tested.
 
-XFree86 3.3.3 also builds on NetBSD/sparc. See section Building on other archi-
-tectures (section 8.5, page 8) for details.
+XFree86 also builds on NetBSD/sparc. See section Building on other architec-
+tures (section 8.5, page 8) for details.
 
 The client side of XFree86 also builds on NetBSD/alpha and many other architec-
 ture supported by NetBSD.
 
-XFree86 3.3.3 also supports NetBSD on PC98 machines.
+XFree86 also supports NetBSD on PC98 machines.
 
 
 
 
 
 
-README for XFree86 3.3.3 on NetBSD                                            1
+README for XFree86 on NetBSD                                                  1
 
 
 
 
 
-README for XFree86 3.3.3 on NetBSD                                            2
+README for XFree86 on NetBSD                                                  2
 
 
 
@@ -79,7 +79,7 @@
 
 3.  New features in this release
 
-See the Release Notes for non-OS dependent new features in XFree86 3.3.3.
+See the Release Notes for non-OS dependent new features in XFree86 3.3.3.1.
 
 
 4.  Installing the Binaries
@@ -133,7 +133,7 @@
 
 
 
-README for XFree86 3.3.3 on NetBSD                                            3
+README for XFree86 on NetBSD                                                  3
 
 
 
@@ -199,7 +199,7 @@
 
 
 
-README for XFree86 3.3.3 on NetBSD                                            4
+README for XFree86 on NetBSD                                                  4
 
 
 
@@ -265,7 +265,7 @@
 
 
 
-README for XFree86 3.3.3 on NetBSD                                            5
+README for XFree86 on NetBSD                                                  5
 
 
 
@@ -331,7 +331,7 @@
 
 
 
-README for XFree86 3.3.3 on NetBSD                                            6
+README for XFree86 on NetBSD                                                  6
 
 
 
@@ -381,8 +381,8 @@
 
 8.1  Console drivers
 
-XFree86 3.3.3 has a configuration option to select the console drivers to use
-in xf86site.def:
+XFree86 has a configuration option to select the console drivers to use in
+xf86site.def:
 
    o  if you're using pccons put:
 
@@ -397,7 +397,7 @@
 
 
 
-README for XFree86 3.3.3 on NetBSD                                            7
+README for XFree86 on NetBSD                                                  7
 
 
 
@@ -463,7 +463,7 @@
 
 
 
-README for XFree86 3.3.3 on NetBSD                                            8
+README for XFree86 on NetBSD                                                  8
 
 
 
@@ -472,8 +472,8 @@
 
 8.5  Building on other architectures
 
-XFree86 3.3.3 also compiles on NetBSD/sparc. The Sun server patches from Dennis
-Ferguson and Matthew Green have been integrated in xc/programs/Xserver/hw/sun.
+XFree86 also compiles on NetBSD/sparc. The Sun server patches from Dennis Fer-
+guson and Matthew Green have been integrated in xc/programs/Xserver/hw/sun.
 Small modifications to xf86site.def are needed:
 
    o Set all variables defining the servers to build to NO. (The variables con-
@@ -529,7 +529,7 @@
 
 
 
-README for XFree86 3.3.3 on NetBSD                                            9
+README for XFree86 on NetBSD                                                  9
 
 
 
@@ -564,7 +564,7 @@
    o Rod Grimes and Jack Velte of Walnut Creek Cdrom for use of their machines
      in preparing the FreeBSD binary release.
 
-     Generated from XFree86: xc/programs/Xserver/hw/xfree86/doc/sgml/NetBSD.sgml,v 3.45.2.9 1998/11/07 13:52:42 dawes Exp $
+     Generated from XFree86: xc/programs/Xserver/hw/xfree86/doc/sgml/NetBSD.sgml,v 3.45.2.10 1998/12/29 07:54:28 hohndel Exp $
 
 
 
@@ -595,7 +595,7 @@
 
 
 
-README for XFree86 3.3.3 on NetBSD                                           10
+README for XFree86 on NetBSD                                                 10
 
 
 
@@ -725,4 +725,4 @@
 
 
 
-$XFree86: xc/programs/Xserver/hw/xfree86/doc/README.NetBSD,v 3.57.2.11 1998/11/14 06:46:49 dawes Exp $
+$XFree86: xc/programs/Xserver/hw/xfree86/doc/README.NetBSD,v 3.57.2.12 1998/12/29 08:00:07 hohndel Exp $
Index: xc/programs/Xserver/hw/xfree86/doc/README.OS2
diff -u xc/programs/Xserver/hw/xfree86/doc/README.OS2:3.13.2.8 xc/programs/Xserver/hw/xfree86/doc/README.OS2:3.13.2.9
--- xc/programs/Xserver/hw/xfree86/doc/README.OS2:3.13.2.8	Sat Nov 14 17:46:50 1998
+++ xc/programs/Xserver/hw/xfree86/doc/README.OS2	Tue Dec 29 19:00:08 1998
@@ -7,11 +7,11 @@
 
 
 
-                       README for XFree86 3.3.3 on OS/2
+                          README for XFree86 on OS/2
 
                                   Holger Veit
 
-                       Last modified on: 04 October 1998
+                      Last modified on: December 29, 1998
 
 
 
@@ -61,13 +61,13 @@
      ranty that certain code works correctly or works at all
 
 
-README for XFree86 3.3.3 on OS/2                                              1
+README for XFree86 on OS/2                                                    1
 
 
 
 
 
-README for XFree86 3.3.3 on OS/2                                              2
+README for XFree86 on OS/2                                                    2
 
 
 
@@ -133,7 +133,7 @@
 
 
 
-README for XFree86 3.3.3 on OS/2                                              3
+README for XFree86 on OS/2                                                    3
 
 
 
@@ -199,7 +199,7 @@
 
 
 
-README for XFree86 3.3.3 on OS/2                                              4
+README for XFree86 on OS/2                                                    4
 
 
 
@@ -265,7 +265,7 @@
 
 
 
-README for XFree86 3.3.3 on OS/2                                              5
+README for XFree86 on OS/2                                                    5
 
 
 
@@ -331,7 +331,7 @@
 
 
 
-README for XFree86 3.3.3 on OS/2                                              6
+README for XFree86 on OS/2                                                    6
 
 
 
@@ -397,7 +397,7 @@
 
 
 
-README for XFree86 3.3.3 on OS/2                                              7
+README for XFree86 on OS/2                                                    7
 
 
 
@@ -463,7 +463,7 @@
 
 
 
-README for XFree86 3.3.3 on OS/2                                              8
+README for XFree86 on OS/2                                                    8
 
 
 
@@ -529,7 +529,7 @@
 
 
 
-README for XFree86 3.3.3 on OS/2                                              9
+README for XFree86 on OS/2                                                    9
 
 
 
@@ -595,7 +595,7 @@
 
 
 
-README for XFree86 3.3.3 on OS/2                                             10
+README for XFree86 on OS/2                                                   10
 
 
 
@@ -661,7 +661,7 @@
 
 
 
-README for XFree86 3.3.3 on OS/2                                             11
+README for XFree86 on OS/2                                                   11
 
 
 
@@ -727,7 +727,7 @@
 
 
 
-README for XFree86 3.3.3 on OS/2                                             12
+README for XFree86 on OS/2                                                   12
 
 
 
@@ -793,7 +793,7 @@
 
 
 
-README for XFree86 3.3.3 on OS/2                                             13
+README for XFree86 on OS/2                                                   13
 
 
 
@@ -859,7 +859,7 @@
 
 
 
-README for XFree86 3.3.3 on OS/2                                             14
+README for XFree86 on OS/2                                                   14
 
 
 
@@ -870,7 +870,7 @@
 
    o ME - no, no, forget this: I won't praise myself :-)
 
-     Generated from XFree86: xc/programs/Xserver/hw/xfree86/doc/sgml/OS2.sgml,v 3.9.2.7 1998/11/04 08:01:53 hohndel Exp $
+     Generated from XFree86: xc/programs/Xserver/hw/xfree86/doc/sgml/OS2.sgml,v 3.9.2.8 1998/12/29 07:54:29 hohndel Exp $
 
 
 
@@ -925,7 +925,7 @@
 
 
 
-README for XFree86 3.3.3 on OS/2                                             15
+README for XFree86 on OS/2                                                   15
 
 
 
@@ -1055,4 +1055,4 @@
 
 
 
-$XFree86: xc/programs/Xserver/hw/xfree86/doc/README.OS2,v 3.13.2.8 1998/11/14 06:46:50 dawes Exp $
+$XFree86: xc/programs/Xserver/hw/xfree86/doc/README.OS2,v 3.13.2.9 1998/12/29 08:00:08 hohndel Exp $
Index: xc/programs/Xserver/hw/xfree86/doc/README.OpenBSD
diff -u xc/programs/Xserver/hw/xfree86/doc/README.OpenBSD:1.1.2.9 xc/programs/Xserver/hw/xfree86/doc/README.OpenBSD:1.1.2.11
--- xc/programs/Xserver/hw/xfree86/doc/README.OpenBSD:1.1.2.9	Sat Nov 14 17:46:51 1998
+++ xc/programs/Xserver/hw/xfree86/doc/README.OpenBSD	Tue Jan  5 23:06:34 1999
@@ -7,22 +7,22 @@
 
 
 
-                      README for XFree86 3.3.3 on OpenBSD
+                         README for XFree86 on OpenBSD
 
                                 Matthieu Herrb
 
-                       Last modified on: 17 October 1998
+                      Last modified on: 29 December 1998
 
 
 
 1.  What and Where is XFree86?
 
-XFree86 3.3.3 is a port of X11R6.3 that supports several versions of Intel-
-based Unix.  It is derived from X386 1.2, which was the X server distributed
-with X11R5.  This release consists of many new features and performance
-improvements as well as many bug fixes.  The release is available as source
-patches against the X Consortium X11R6.3 code, as well as binary distributions
-for many architectures.
+XFree86 is a port of X11R6.3 that supports several versions of Intel-based
+Unix.  It is derived from X386 1.2, which was the X server distributed with
+X11R5.  This release consists of many new features and performance improvements
+as well as many bug fixes.  The release is available as source patches against
+the X Consortium X11R6.3 code, as well as binary distributions for many archi-
+tectures.
 
 See the Copyright Notice.
 
@@ -30,14 +30,14 @@
 
 ftp://ftp.XFree86.org/pub/XFree86/current
 
-Binaries for OpenBSD 2.3 and later are available from:
+Binaries for OpenBSD 2.4 and later are available from:
 
 ftp://ftp.XFree86.org/pub/XFree86/current/binaries/OpenBSD
 
 A list of mirror sites is provided by ftp://ftp.XFree86.org/pub/XFree86/MIRRORS
 
-XFree86 3.3.3 also builds on other OpenBSD architectures. See section Building
-on other architectures (section 8.2, page 6) for details.
+XFree86 also builds on other OpenBSD architectures. See section Building on
+other architectures (section 8.2, page 6) for details.
 
 
 2.  Bug Reports for This Document
@@ -48,7 +48,7 @@
 
 3.  New features in this release
 
-See the Release Notes for new features in XFree86 3.3.3.
+See the Release Notes for new features in XFree86.
 
 
 4.  Installing the Binaries
@@ -61,13 +61,13 @@
 
 
 
-README for XFree86 3.3.3 on OpenBSD                                           1
+README for XFree86 on OpenBSD                                                 1
 
 
 
 
 
-README for XFree86 3.3.3 on OpenBSD                                           2
+README for XFree86 on OpenBSD                                                 2
 
 
 
@@ -133,7 +133,7 @@
 
 
 
-README for XFree86 3.3.3 on OpenBSD                                           3
+README for XFree86 on OpenBSD                                                 3
 
 
 
@@ -199,7 +199,7 @@
 
 
 
-README for XFree86 3.3.3 on OpenBSD                                           4
+README for XFree86 on OpenBSD                                                 4
 
 
 
@@ -265,7 +265,7 @@
 
 
 
-README for XFree86 3.3.3 on OpenBSD                                           5
+README for XFree86 on OpenBSD                                                 5
 
 
 
@@ -281,14 +281,14 @@
 
      Uncomment the lines loading the aperture driver from /etc/rc.securelevel
 
-   o  OpenBSD-2.3
+   o  OpenBSD 2.3
 
      The aperture driver is part of the kernel.  Add 'option APERTURE' to your
      kernel configuration file, build and install the new kernel and run
      ./MAKEDEV std in /dev. Edit /etc/sysctl.conf to set the variable
      machdep.allowaperture to 1.
 
-   o  OpenBSD-current and the upcoming OpenBSD 2.4
+   o  OpenBSD 2.4 and later
 
      OpenBSD now requires the aperture driver to be enabled for all X servers,
      because the aperture driver also controls access to the I/O ports of the
@@ -331,7 +331,7 @@
 
 
 
-README for XFree86 3.3.3 on OpenBSD                                           6
+README for XFree86 on OpenBSD                                                 6
 
 
 
@@ -353,8 +353,8 @@
 
 8.1  Console drivers
 
-XFree86 3.3.3 has a configuration option to select the console drivers to use
-in xf86site.def:
+XFree86 has a configuration option to select the console drivers to use in
+xf86site.def:
 
    o  if you're using pccons only put:
 
@@ -370,7 +370,7 @@
 
 8.2  Building on other architectures
 
-XFree86 3.3.3 also compiles on other OpenBSD architectures.
+XFree86 also compiles on other OpenBSD architectures.
 
 The XFree86 servers can also been built on OpenBSD/mips. The S3 server has been
 tested on an Acer Mips system with a S3/928 board. Contact Per Fogelstrom
@@ -397,7 +397,7 @@
 
 
 
-README for XFree86 3.3.3 on OpenBSD                                           7
+README for XFree86 on OpenBSD                                                 7
 
 
 
@@ -414,7 +414,7 @@
 install additional man pages you should update whatis.db by running ``make-
 whatis /usr/X11R6/man''.
 
-     Generated from XFree86: xc/programs/Xserver/hw/xfree86/doc/sgml/OpenBSD.sgml,v 1.1.2.7 1998/11/07 13:52:43 dawes Exp $
+     Generated from XFree86: xc/programs/Xserver/hw/xfree86/doc/sgml/OpenBSD.sgml,v 1.1.2.9 1999/01/05 07:15:47 hohndel Exp $
 
 
 
@@ -463,7 +463,7 @@
 
 
 
-README for XFree86 3.3.3 on OpenBSD                                           8
+README for XFree86 on OpenBSD                                                 8
 
 
 
@@ -593,4 +593,4 @@
 
 
 
-$XFree86: xc/programs/Xserver/hw/xfree86/doc/README.OpenBSD,v 1.1.2.9 1998/11/14 06:46:51 dawes Exp $
+$XFree86: xc/programs/Xserver/hw/xfree86/doc/README.OpenBSD,v 1.1.2.11 1999/01/05 12:06:34 dawes Exp $
Index: xc/programs/Xserver/hw/xfree86/doc/README.P9000
diff -u xc/programs/Xserver/hw/xfree86/doc/README.P9000:3.33.2.7 xc/programs/Xserver/hw/xfree86/doc/README.P9000:3.33.2.8
--- xc/programs/Xserver/hw/xfree86/doc/README.P9000:3.33.2.7	Sat Nov 14 17:46:52 1998
+++ xc/programs/Xserver/hw/xfree86/doc/README.P9000	Tue Dec 29 19:00:10 1998
@@ -7,11 +7,11 @@
 
 
 
-                   XFree86 3.3.3 P9000 Server Release Notes
+                      XFree86 P9000 Server Release Notes
 
                          Erik Nygren (nygren@mit.edu)
 
-                                1998 October 13
+                               1998 December 29
 
 
 
@@ -26,9 +26,9 @@
       1997.01.30:
 
                o Added probing for MemBase and IOBase on Diamond Viper PCI
-                 cards (Karl Anders ygard)
+                 cards (Karl Anders ygard)
 
-               o Added support for DPMI screen saving (Karl Anders ygard)
+               o Added support for DPMI screen saving (Karl Anders ygard)
 
       1996.03.31:
 
@@ -61,13 +61,13 @@
                  slow :( (Chris Mason)
 
 
-XFree86 3.3.3 P9000 Server Release Notes                                      1
+XFree86 P9000 Server Release Notes                                            1
 
 
 
 
 
-XFree86 3.3.3 P9000 Server Release Notes                                      2
+XFree86 P9000 Server Release Notes                                            2
 
 
 
@@ -133,7 +133,7 @@
 
 
 
-XFree86 3.3.3 P9000 Server Release Notes                                      3
+XFree86 P9000 Server Release Notes                                            3
 
 
 
@@ -199,7 +199,7 @@
 
 
 
-XFree86 3.3.3 P9000 Server Release Notes                                      4
+XFree86 P9000 Server Release Notes                                            4
 
 
 
@@ -265,7 +265,7 @@
 
 
 
-XFree86 3.3.3 P9000 Server Release Notes                                      5
+XFree86 P9000 Server Release Notes                                            5
 
 
 
@@ -331,7 +331,7 @@
 
 
 
-XFree86 3.3.3 P9000 Server Release Notes                                      6
+XFree86 P9000 Server Release Notes                                            6
 
 
 
@@ -397,7 +397,7 @@
 
 
 
-XFree86 3.3.3 P9000 Server Release Notes                                      7
+XFree86 P9000 Server Release Notes                                            7
 
 
 
@@ -463,7 +463,7 @@
 
 
 
-XFree86 3.3.3 P9000 Server Release Notes                                      8
+XFree86 P9000 Server Release Notes                                            8
 
 
 
@@ -529,7 +529,7 @@
 
 
 
-XFree86 3.3.3 P9000 Server Release Notes                                      9
+XFree86 P9000 Server Release Notes                                            9
 
 
 
@@ -595,7 +595,7 @@
 
 
 
-XFree86 3.3.3 P9000 Server Release Notes                                     10
+XFree86 P9000 Server Release Notes                                           10
 
 
 
@@ -604,7 +604,7 @@
 During the course of the next few months, people will be working on accelera-
 tion, etc.  Please send any patches to me (nygren@mit.edu).
 
-     Generated from XFree86: xc/programs/Xserver/hw/xfree86/doc/sgml/P9000.sgml,v 3.18.2.6 1998/11/07 13:37:48 dawes Exp $
+     Generated from XFree86: xc/programs/Xserver/hw/xfree86/doc/sgml/P9000.sgml,v 3.18.2.7 1998/12/29 07:54:30 hohndel Exp $
 
 
 
@@ -661,7 +661,7 @@
 
 
 
-XFree86 3.3.3 P9000 Server Release Notes                                     11
+XFree86 P9000 Server Release Notes                                           11
 
 
 
@@ -791,4 +791,4 @@
 
 
 
-$XFree86: xc/programs/Xserver/hw/xfree86/doc/README.P9000,v 3.33.2.7 1998/11/14 06:46:52 dawes Exp $
+$XFree86: xc/programs/Xserver/hw/xfree86/doc/README.P9000,v 3.33.2.8 1998/12/29 08:00:10 hohndel Exp $
Index: xc/programs/Xserver/hw/xfree86/doc/README.S3V
diff -u xc/programs/Xserver/hw/xfree86/doc/README.S3V:3.5.2.9 xc/programs/Xserver/hw/xfree86/doc/README.S3V:3.5.2.11
--- xc/programs/Xserver/hw/xfree86/doc/README.S3V:3.5.2.9	Sat Nov 14 17:46:53 1998
+++ xc/programs/Xserver/hw/xfree86/doc/README.S3V	Tue Dec 29 18:54:24 1998
@@ -302,7 +302,7 @@
 
 4.1  XF86_S3V server
 
-Harald Koenig <koenig@tat.physik.uni-tuebingen.de>"
+Harald Koenig <koenig@tat.physik.uni-tuebingen.de>
 
 and:
 
@@ -339,7 +339,7 @@
 
    o Kevin Brosius Cobra@compuserve.com
 
-     Generated from XFree86: xc/programs/Xserver/hw/xfree86/doc/sgml/S3V.sgml,v 3.3.2.8 1998/02/27 04:53:51 dawes Exp $
+     Generated from XFree86: xc/programs/Xserver/hw/xfree86/doc/sgml/S3V.sgml,v 3.3.2.9 1998/12/04 01:36:48 dawes Exp $
 
 
 
@@ -527,4 +527,4 @@
 
 
 
-$XFree86: xc/programs/Xserver/hw/xfree86/doc/README.S3V,v 3.5.2.9 1998/11/14 06:46:53 dawes Exp $
+$XFree86: xc/programs/Xserver/hw/xfree86/doc/README.S3V,v 3.5.2.11 1998/12/29 07:54:24 hohndel Exp $
Index: xc/programs/Xserver/hw/xfree86/doc/README.SiS
diff -u xc/programs/Xserver/hw/xfree86/doc/README.SiS:3.5.2.6 xc/programs/Xserver/hw/xfree86/doc/README.SiS:3.5.2.7
--- xc/programs/Xserver/hw/xfree86/doc/README.SiS:3.5.2.6	Sat Nov 14 17:46:56 1998
+++ xc/programs/Xserver/hw/xfree86/doc/README.SiS	Tue Dec 29 19:00:10 1998
@@ -19,9 +19,9 @@
 
 This driver was primarily written for the SiS86c201.  It also works on the 202
 , 205 and 5597/5598 chips. Support for 6326 is currently enabled, but tested
-only on few cards. Also we added for 3.3.3 version some support for SiS86c215
-and 225. This support consist simply in identify it as 205, so probably 86c215
-won't work with acceleration (is a cheap 205 without some features).
+only on few cards.  Some support for SiS86c215 and 225 was added as well. This
+support consists simply in identify it as 205, so probably 86c215 won't work
+with acceleration (is a cheap 205 without some features).
 
 The driver supports many advanced features.  These include:
 
@@ -224,7 +224,7 @@
      Updated October 12, 1998 by Juanjo Santamarta, covering changes for 5597 and 6326.
      Updated November 6, 1998 by Juanjo Santamarta, covering changes for 5597, 86c2x5 and 6326.
 
-     Generated from XFree86: xc/programs/Xserver/hw/xfree86/doc/sgml/SiS.sgml,v 3.3.2.5 1998/11/08 10:03:43 hohndel Exp $
+     Generated from XFree86: xc/programs/Xserver/hw/xfree86/doc/sgml/SiS.sgml,v 3.3.2.6 1998/12/29 07:54:30 hohndel Exp $
 
 
 
@@ -395,4 +395,4 @@
 
 
 
-$XFree86: xc/programs/Xserver/hw/xfree86/doc/README.SiS,v 3.5.2.6 1998/11/14 06:46:56 dawes Exp $
+$XFree86: xc/programs/Xserver/hw/xfree86/doc/README.SiS,v 3.5.2.7 1998/12/29 08:00:10 hohndel Exp $
Index: xc/programs/Xserver/hw/xfree86/doc/README.trident
diff -u xc/programs/Xserver/hw/xfree86/doc/README.trident:3.32.2.8 xc/programs/Xserver/hw/xfree86/doc/README.trident:3.32.2.10
--- xc/programs/Xserver/hw/xfree86/doc/README.trident:3.32.2.8	Sat Nov 14 17:47:04 1998
+++ xc/programs/Xserver/hw/xfree86/doc/README.trident	Tue Dec 29 23:48:17 1998
@@ -11,7 +11,7 @@
 
                            The XFree86 Project, Inc.
 
-                               25th October 1998
+                                December 29 1998
 
 
 
@@ -40,7 +40,10 @@
      i.e. Chipset 'tgui9685' will set a ProVidia9685 chip.
 
    o  The Cyber9388/9397, 3DImage975 and 3DImage985 cards are fixed in XFree86
-     v3.3.3, these chipsets have some acceleration now too.
+     v3.3.3, these chipsets have some acceleration now too. This acceleration
+     has been disabled by default for the Cyber9388/9397 because there have
+     been problems, but it can be re-enabled with the "accel" option (see
+     below).
 
    o  24bpp is all drivers remains unaccelerated, this will change in a future
      version, although 32bpp acceleration is supported for all TGUI based
@@ -57,9 +60,6 @@
                  16MB of memory, so be sure you have less than this or it could
                  cause a system hang.
 
-           MemBase 0x???????
-                 This option may be used to specify the start address of the
-
 
  Information for Trident Chipset Users                                        1
 
@@ -71,6 +71,8 @@
 
 
 
+           MemBase 0x???????
+                 This option may be used to specify the start address of the
                  linear frame buffer. By default for VLBus/EISA cards it is at
                  60MB.  For the 8900CL/D, it is at 15MB.
 
@@ -83,11 +85,18 @@
                  Turn on PCI burst read mode.
 
            Option "tgui_pci_write_on"
-                 Turn on PCI burst write mode.  NOTE: PCI Burst modes are now
-                 OFF by default. The reason for this is the Graphics Accelera-
-                 tor gets upset, but we allow you to turn it back on it may
-                 improve performance, or lock up the chip with Timeouts dis-
-                 played.
+                 Turn on PCI burst write mode.
+
+           Option "pci_burst_on"
+                 Turn on PCI burst (read and write)
+
+           Option "pci_burst_off"
+                 Turn off PCI burst (read and write)
+
+                 NOTE: PCI burst modes are now OFF by default for TGUI9440
+                 cards because it often upsets its Graphics Accelerator.  It
+                 can be turned it back on as may improve performance.  PCI
+                 burst modes are ON by default for all other PCI/AGP cards.
 
            ClockChip "tgui"
                  Turn on programmable clocks.  This is the default for TGUIs.
@@ -100,6 +109,9 @@
            Option "noaccel"
                  Turn off XAA acceleration.
 
+           Option "accel"
+                 Enable acceleration for the Cyber9388/9397.
+
            Option "xaa_no_color_exp"
                  Disable color expansion.
 
@@ -113,15 +125,6 @@
                  Enable Shadow registers, might be needed for some Cyber
                  chipsets. (laptop machines)
 
-           Option "tgui_mclk_66"
-                 Pushes the Memory Clock from its default value to 66MHz.
-                 Increases graphics speed dramatically, but use entirely at
-                 your own risk, as it may damage the video card.  If snow
-                 appears, disable. Only tested on the 9440.
-
-The original Trident chipset, 8800BR, cannot be supported as an SVGA chipset by
-either the color or monochrome servers.  The chip is supported, however, by the
-``generic'' driver for the monochrome server.
 
 
 
@@ -130,11 +133,19 @@
 
 
 
+ Information for Trident Chipset Users                                        3
 
 
 
- Information for Trident Chipset Users                                        3
+           Option "tgui_mclk_66"
+                 Pushes the Memory Clock from its default value to 66MHz.
+                 Increases graphics speed dramatically, but use entirely at
+                 your own risk, as it may damage the video card.  If snow
+                 appears, disable. Only tested on the 9440.
 
+The original Trident chipset, 8800BR, cannot be supported as an SVGA chipset by
+either the color or monochrome servers.  The chip is supported, however, by the
+``generic'' driver for the monochrome server.
 
 
 2.  Special considerations for 512k boards
@@ -180,17 +191,6 @@
 
 
 This will cause the same clock selection code as is used for the 8900CL to be
-used for the board.
-
-While developing the Trident driver, an interesting and perturbing hardware
-phenomenon was discovered.  When using the default board jumper configuration,
-dot-clocks above 57Mhz would frequently lock up the machine.  There appear to
-be jumpers on all of the Trident boards that determine whether the board will
-operate in zero-wait-state mode on the ISA bus.  Disabling the zero-wait-state
-mode via jumpers cured the lockups, but at the expense of performance.  Whether
-or not a given system will experience this problem is likely a combination of
-(a) bus speed, (b) video memory speed, and (c) dot clock speed.  So be prepared
-for this phenomenon to occur, and have the board documentation handy.
 
 
 
@@ -203,11 +203,23 @@
 
 
 
+used for the board.
+
+While developing the Trident driver, an interesting and perturbing hardware
+phenomenon was discovered.  When using the default board jumper configuration,
+dot-clocks above 57Mhz would frequently lock up the machine.  There appear to
+be jumpers on all of the Trident boards that determine whether the board will
+operate in zero-wait-state mode on the ISA bus.  Disabling the zero-wait-state
+mode via jumpers cured the lockups, but at the expense of performance.  Whether
+or not a given system will experience this problem is likely a combination of
+(a) bus speed, (b) video memory speed, and (c) dot clock speed.  So be prepared
+for this phenomenon to occur, and have the board documentation handy.
+
 NOTE: VLBus cards are also subject to the above. By specifying the Clocks in
 the XF86Config file, these lockups are overcome. But it may be worth checking
 wait states etc. on the card and in the BIOS setup.
 
-     Generated from XFree86: xc/programs/Xserver/hw/xfree86/doc/sgml/trident.sgml,v 3.22.2.6 1998/11/07 13:37:52 dawes Exp $
+     Generated from XFree86: xc/programs/Xserver/hw/xfree86/doc/sgml/trident.sgml,v 3.22.2.8 1998/12/29 12:26:23 dawes Exp $
 
 
 
@@ -253,18 +265,6 @@
 
 
 
-
-
-
-
-
-
-
-
-
-
-
-
  Information for Trident Chipset Users                                        5
 
 
@@ -395,4 +395,4 @@
 
 
 
-$XFree86: xc/programs/Xserver/hw/xfree86/doc/README.trident,v 3.32.2.8 1998/11/14 06:47:04 dawes Exp $
+$XFree86: xc/programs/Xserver/hw/xfree86/doc/README.trident,v 3.32.2.10 1998/12/29 12:48:17 dawes Exp $
Index: xc/programs/Xserver/hw/xfree86/doc/RELNOTES
diff -u xc/programs/Xserver/hw/xfree86/doc/RELNOTES:3.52.2.37 xc/programs/Xserver/hw/xfree86/doc/RELNOTES:3.52.2.44
--- xc/programs/Xserver/hw/xfree86/doc/RELNOTES:3.52.2.37	Thu Nov 19 23:01:02 1998
+++ xc/programs/Xserver/hw/xfree86/doc/RELNOTES	Thu Dec 31 12:44:22 1998
@@ -7,21 +7,21 @@
 
 
 
-                      Release Notes for XFree86[tm] 3.3.3
+                     Release Notes for XFree86[tm] 3.3.3.1
 
                            The XFree86 Project, Inc
 
-                               19 November 1998
+                               30 December 1998
 
 
 
                                    Abstract
 
      This document describes the bugs fixed and the features added in
-     XFree86 3.3.3 compared with the 3.3.2 release, It also includes
-     installation instructions for the binary distributions.  It is
-     strongly recommended that anyone using XFree86 update to version
-     3.3.3.
+     XFree86 3.3.3.1 compared with the 3.3.2 and 3.3.3 release, It also
+     includes installation instructions for the binary distributions.  It
+     is strongly recommended that anyone using XFree86 update to version
+     3.3.3.1.
 
 
 
@@ -53,21 +53,21 @@
 Consortium style copyright.  Given the fact that our main development focus is
 on XFree86-4.0 and that the 3.3.3 release was intended mostly to fix some bugs
 and get out new drivers to the public, we opted not to include X11R6.4 in
-XFree86-3.3.3.
+XFree86-3.3.3.  Since XFree86-3.3.3.1 is merely a quick bug fix release to
+XFree86-3.3.3, the same applies here as well.
 
 XFree86-4.0 will be X11R6.4 based.
 
 
 
 
+Release Notes for XFree86[tm] 3.3.3.1                                         1
 
-Release Notes for XFree86[tm] 3.3.3                                           1
 
 
 
 
-
-Release Notes for XFree86[tm] 3.3.3                                           2
+Release Notes for XFree86[tm] 3.3.3.1                                         2
 
 
 
@@ -86,9 +86,63 @@
 
 
 
-4.  What's new in 3.3.3?
+4.  What's new in 3.3.3.1?
+
+   o A system clock slowdown caused by 3Dlabs driver has been fixed.
+
+   o Drawing bugs with C&T HiQV chips have been fixed.
+
+   o Drawing problems in the Cyrix driver have been fixed.
+
+   o The Matrox G100/G200 PCI versions should now be fully supported.
+
+   o The Mach64 server now supports gamma correction.
+
+   o Open Source NVIDIA driver has been provided.
+
+   o I128 Rev IV support has been added.
+
+   o Another S3V lockup has been fixed.
+
+   o A drawing bug in cfb24 has been fixed.
+
+   o A problem causing lockups with some Trident cards has been fixed.
+
+   o Updates for SCO, FreeBSD, Linux glibc OS support.
+
+   o DG/ux support has been added.
+
+   o GNU/Hurd support has been added.
+
+   o Several XINPUT problems have been addressed.
+
+   o DGA relative mouse movement events when XINPUT is defined have been fixed,
+     as have DGA-related problems with the NVIDIA and S3V drivers.
+
+   o The X server now reads Xauthority files using the real user id.
+
+   o Several small fixes to core clients.
+
+   o A bug in Xlib's handling of KOI8-R has been fixed.
+
+
+
+
+
 
-4.1  Security fixes
+
+
+
+Release Notes for XFree86[tm] 3.3.3.1                                         3
+
+
+
+   o PC98 cards database, sample config file and XKB handling have been fixed.
+
+
+5.  What's new in 3.3.3?
+
+5.1  Security fixes
 
    o Several buffer overrun problem discovered since the release of
      XFree86-3.3.2 have been fixed
@@ -99,7 +153,7 @@
      Note that this is only a short-term partial solution, and it is doesn't
      help at all for some SYSV based OSs (like Solaris 2.x).
 
-4.2  Bug fixes
+5.2  Bug fixes
 
    o Fix a serious LBX bug using uninitialized variables.
 
@@ -124,30 +178,30 @@
 
    o Fix some lockups with ViRGE chips.
 
+   o Improved timing calculations for video FIFO in the Mach64 X server.
 
+   o Fixed bug in font rendering code in the Mach64 X server.
 
+   o Fixed VGA font restoration bug when exiting the Mach64 X server.
 
+   o Several XF68_FBDev fixes.
 
+   o Fix wrong clock limits for S3 Trio64V+.
 
+   o Fix some generic rendering errors in cfb and vga code.
 
 
 
 
-Release Notes for XFree86[tm] 3.3.3                                           3
 
 
 
-   o Improved timing calculations for video FIFO in the Mach64 X server.
 
-   o Fixed bug in font rendering code in the Mach64 X server.
 
-   o Fixed VGA font restoration bug when exiting the Mach64 X server.
 
-   o Several XF68_FBDev fixes.
+Release Notes for XFree86[tm] 3.3.3.1                                         4
 
-   o Fix wrong clock limits for S3 Trio64V+.
 
-   o Fix some generic rendering errors in cfb and vga code.
 
    o Fix text restore problems and improve high res 32bpp modes in MGA driver;
      fix 24bpp and 32bpp display problems; disable probing for memory on some
@@ -180,7 +234,7 @@
 
    o Fix VT switch problem with MGA server on Linux/98.
 
-4.3  New Features
+5.3  New Features
 
    o New driver for Cyrix MediaGX based motherboards.
 
@@ -190,31 +244,30 @@
 
    o New driver for SiS 5597/98 and SiS 6326; treat SiS 6215 and 6225 as 6205.
 
+   o New server for 3Dlabs based cards using GLINT 500TX and MX (with IBM RAM-
+     DAC), Permedia (with IBM RAMDAC), Permedia 2 and Permedia 2v.
 
+   o Support for the Matrox G100 and G200 based cards to the MGA driver.
 
+   o Support for C&T 69000 and 32bpp on 65550 and later.
 
+   o Support for NeoMagic notebook chipsets.
 
+   o Support for EPSON SPC8110.
 
+   o Support for NVidia Riva TNT.
 
 
 
 
-Release Notes for XFree86[tm] 3.3.3                                           4
-
 
 
-   o New server for 3Dlabs based cards using GLINT 500TX and MX (with IBM RAM-
-     DAC), Permedia (with IBM RAMDAC), Permedia 2 and Permedia 2v.
 
-   o Support for the Matrox G100 and G200 based cards to the MGA driver.
 
-   o Support for C&T 69000 and 32bpp on 65550 and later.
 
-   o Support for NeoMagic notebook chipsets.
+Release Notes for XFree86[tm] 3.3.3.1                                         5
 
-   o Support for EPSON SPC8110.
 
-   o Support for NVidia Riva TNT.
 
    o Acceleration for Trident Image975, Image985, Cyber9397, Cyber9388.
 
@@ -238,7 +291,10 @@
 
    o Add local font directory.
 
-4.4  Known Problems
+5.4  Known Problems
+
+The problems listed here are those known at the time of the release.  See the
+XFree86 FAQ for more up to date information.
 
    o There are problems with some Cirrus laptop chipsets (75xx).  The driver
      seems to work for some people, but not others.  Until someone with the
@@ -256,65 +312,35 @@
    o SuperProbe command fails to detect some newly supported chips.  Currently,
      the probing result with Xserver itself with appropriate setting in
      XF86Config (and maybe option "-probeonly") can be more relied on than the
-     result from SuperProbe for newer chips.  If you are interested in
-
-
-
-
-
-
-
-
-Release Notes for XFree86[tm] 3.3.3                                           5
-
-
-
-     improving the design of SuperProbe's code, let's come and join as the mem-
-     ber of the XFree86 ``developer team''.
+     result from SuperProbe for newer chips.  If you are interested in improv-
+     ing the design of SuperProbe's code, let's come and join as the member of
+     the XFree86 ``developer team''.
 
 
-5.  XFree86 and Open Source Software
+6.  XFree86 and Open Source Software
 
 XFree86 public releases in general follow the Open Source Software definition
 as set forth at http://www.opensource.org/osd.html.  This definition is actu-
 ally a subset of our requirements.
 
-After we had finalized XFree86 3.3.3, and within hours of our planned release,
-NVIDIA insisted that we withdraw two source files from the driver that they had
-supplied to us and replace some other source files with versions that were
-partly run through the C preprocessor.  NVIDIA's stated reason for this was to
-remove some of the names that they thought might reveal intellectual property
-from NVIDIA. This resulted in somewhat unreadable and unmaintainable code.
 
 
-The XFree86 Project is strongly opposed to such obfuscated code.  Among other
-things, such code does not satisfy the Open Source definition of "Source Code",
-which states that
 
-     The source code must be the preferred form in which a programmer
-     would modify the program. Deliberately obfuscated source code is not
-     allowed.  Intermediate forms such as the output of a preprocessor or
-     translator are not allowed.
 
 
-Due to the extremely late date of this decision by NVIDIA, we decided to
-include the code as offered by NVIDIA.  All other options would have signifi-
-cantly delayed the release of XFree86-3.3.3.  Unless another solution can be
-found with NVIDIA, we will remove this code from future releases.
 
-The code affected by this is located in the directory:
 
-     xc/programs/Xserver/hw/xfree86/vga256/drivers/nv
 
+Release Notes for XFree86[tm] 3.3.3.1                                         6
 
-Specifically, the files: nv3arb.c, nv3cursor.c, nv3driver.c, nv3setup.c,
-nv4arb.c, nv4cursor.c, nv4driver.c, nv4setup.c.  All other code in XFree86
-3.3.3 satisfies the Open Source Software definition.
 
 
-6.  Installing the XFree86 3.3.3 Release
+All code in XFree86 3.3.3.1 satisfies the Open Source Software definition.
 
-The XFree86 3.3.3 binaries are distributed as a full release.
+
+7.  Installing the XFree86 3.3.3.1 Release
+
+The XFree86 3.3.3.1 binaries are distributed as a full release.
 
 NOTE: the X servers are no longer installed setuid root.  If you are starting
 your X servers with startx/xinit, or something similar, you will need a copy of
@@ -323,18 +349,6 @@
 What follows is a list of the XFree86 3.3.3 components.  There may be some
 variations in this for some OSs.
 
-
-
-
-
-
-
-
-
-Release Notes for XFree86[tm] 3.3.3                                           6
-
-
-
 The following are required for all new installations, or when upgrading from a
 version older than 3.3:
 
@@ -374,36 +388,38 @@
 need:
 
 
-          Xfnts.tgz       75dpi, misc and PEX fonts
 
 
-NOTE: Be very careful about installing Xcfg.tgz over an existing installation
-if you have customised your xinit and/or xdm config files.  Installing Xcfg.tgz
-will overwrite any existing files.  If you do have customised files, there is
-no need to install Xcfg.tgz.
 
-NOTE: The bitmap fonts distributed with this release are compressed using gzip
-rather than compress.  This means that you will probably want to remove the old
-versions (after backing them up).  The Xservers and font server in releases
-prior to 3.2A cannot read gzipped fonts, so keep a copy of the old fonts if you
-wish to run older servers.
 
-The following X servers are for PC/AT based hardware (i.e., typical Intel ix86
 
 
 
 
 
+Release Notes for XFree86[tm] 3.3.3.1                                         7
 
 
 
-Release Notes for XFree86[tm] 3.3.3                                           7
+          Xfnts.tgz       75dpi, misc and PEX fonts
+
 
+NOTE: Be very careful about installing Xcfg.tgz over an existing installation
+if you have customised your xinit and/or xdm config files.  Installing Xcfg.tgz
+will overwrite any existing files.  If you do have customised files, there is
+no need to install Xcfg.tgz.
 
+NOTE: The bitmap fonts distributed with this release are compressed using gzip
+rather than compress.  This means that you will probably want to remove the old
+versions (after backing them up).  The Xservers and font server in releases
+prior to 3.2A cannot read gzipped fonts, so keep a copy of the old fonts if you
+wish to run older servers.
 
+The following X servers are for PC/AT based hardware (i.e., typical Intel ix86
 based PCs).  Choose at least one which matches your hardware, as well as the
 VGA16 server.  The VGA16 server is required by the new configuration utility
-(XF86Setup).
+(XF86Setup).  A list showing which X server is required for a range of video
+cards can be found at http://www.xfree86.org/cardlist.html.
 
 
           X3DL.tgz        3Dlabs server
@@ -439,19 +455,6 @@
 The following X servers are for PC98 hardware. Note that PC98 is a Japanese
 computer standard and has nothing to do with Win98, or the Intel and Microsoft
 PC98 specification. If you have a PC98 machine, choose one which suits your
-hardware.  If you don't know what a PC98 machine is, you don't need any of
-these.  These servers will not run on "normal" PCs, so don't even try them if
-you don't have a Japanese PC98 machine.
-
-
-
-
-
-
-
-
-
-
 
 
 
@@ -460,11 +463,15 @@
 
 
 
+Release Notes for XFree86[tm] 3.3.3.1                                         8
 
 
 
-Release Notes for XFree86[tm] 3.3.3                                           8
-
+hardware.  If you don't know what a PC98 machine is, you don't need any of
+these.  These servers will not run on "normal" PCs, so don't even try them if
+you don't have a Japanese PC98 machine.  A list showing which X server is
+required for a range of PC98 video cards and computers can be found at
+http://www.xfree86.org/cardlist98.html.
 
 
           X9NS3.tgz       PC98 NEC(S3) server
@@ -514,13 +521,7 @@
 this, create a directory elsewhere and create a symbolic link to it.  E.g., if
 you create a directory in /home:
 
-          mkdir /home/X11R6
-          ln -s /home/X11R6 /usr
 
-The next step is to run the pre-installation script.  This script makes some
-preliminary checks of your system.  For some OSs, it may tell you to install
-new versions of some system components before proceeding with the installation.
-This script may also remove some outdated files and symbolic links from a
 
 
 
@@ -528,12 +529,18 @@
 
 
 
+Release Notes for XFree86[tm] 3.3.3.1                                         9
 
-Release Notes for XFree86[tm] 3.3.3                                           9
 
 
+          mkdir /home/X11R6
+          ln -s /home/X11R6 /usr
 
-previous installation that could cause problems.
+The next step is to run the pre-installation script.  This script makes some
+preliminary checks of your system.  For some OSs, it may tell you to install
+new versions of some system components before proceeding with the installation.
+This script may also remove some outdated files and symbolic links from a pre-
+vious installation that could cause problems.
 
 For the purposes of these installation instructions, it is assumed that you
 have downloaded all the files to the /var/tmp directory.  If you've put them in
@@ -581,12 +588,24 @@
 if you are using Linux, FreeBSD, NetBSD or OpenBSD.  For other OSs that use
 ldconfig, check how it normally gets run at boot time.
 
+
+
+
+
+
+
+
+Release Notes for XFree86[tm] 3.3.3.1                                        10
+
+
+
 Once the installation is complete, you should run the one of the configuration
 utilities (XF86Setup or xf86config) to configure the X server.  This is essen-
 tial for a new installation but optional for an existing installation.  Refer
 to the QuickStart document for configuration information.
 
-     Generated from XFree86: xc/programs/Xserver/hw/xfree86/doc/sgml/RELNOTE.sgml,v 3.59.2.61 1998/11/19 11:27:57 dawes Exp $
+     Generated from XFree86: xc/programs/Xserver/hw/xfree86/doc/sgml/RELNOTE.sgml,v 3.59.2.68 1998/12/30 10:22:34 hohndel Exp $
+
 
 
 
@@ -595,7 +614,54 @@
 
 
 
-Release Notes for XFree86[tm] 3.3.3                                          10
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+Release Notes for XFree86[tm] 3.3.3.1                                        11
 
 
 
@@ -675,17 +741,17 @@
 
 3. OS issues ................................................................ 2
 
-4. What's new in 3.3.3? ..................................................... 2
-   4.1 Security fixes ....................................................... 2
-   4.2 Bug fixes ............................................................ 2
-   4.3 New Features ......................................................... 3
-   4.4 Known Problems ....................................................... 4
-
-5. XFree86 and Open Source Software ......................................... 5
+4. What's new in 3.3.3.1? ................................................... 2
 
-6. Installing the XFree86 3.3.3 Release ..................................... 5
+5. What's new in 3.3.3? ..................................................... 3
+   5.1 Security fixes ....................................................... 3
+   5.2 Bug fixes ............................................................ 3
+   5.3 New Features ......................................................... 4
+   5.4 Known Problems ....................................................... 5
 
+6. XFree86 and Open Source Software ......................................... 5
 
+7. Installing the XFree86 3.3.3.1 Release ................................... 6
 
 
 
@@ -725,4 +791,4 @@
 
 
 
-$XFree86: xc/programs/Xserver/hw/xfree86/doc/RELNOTES,v 3.52.2.37 1998/11/19 12:01:02 dawes Exp $
+$XFree86: xc/programs/Xserver/hw/xfree86/doc/RELNOTES,v 3.52.2.44 1998/12/31 01:44:22 dawes Exp $
Index: xc/programs/Xserver/hw/xfree86/doc/sgml/DocIndex.sgml
diff -u xc/programs/Xserver/hw/xfree86/doc/sgml/DocIndex.sgml:3.24.2.15 xc/programs/Xserver/hw/xfree86/doc/sgml/DocIndex.sgml:3.24.2.17
--- xc/programs/Xserver/hw/xfree86/doc/sgml/DocIndex.sgml:3.24.2.15	Sat Nov 14 00:00:43 1998
+++ xc/programs/Xserver/hw/xfree86/doc/sgml/DocIndex.sgml	Thu Dec 24 00:36:26 1998
@@ -5,14 +5,14 @@
 <!-- Title information -->
 <title>List of XFree86 documentation
 <author>The XFree86 Project, Inc
-<date>5 November 1998
+<date>23 December 1998
 
 <sect> Available Documentation <p>
 
 <itemize>
-<item><htmlurl name="Release Notes for XFree86&trade; 3.3.3"
+<item><htmlurl name="Release Notes for XFree86&trade; 3.3.3.1"
 	url="RELNOTES.html">
-<item><htmlurl name="README for XFree86&trade; 3.3.3"
+<item><htmlurl name="README for XFree86&trade; 3.3.3.1"
 	url="README.html">
 <item><htmlurl name="Copyright"
 	url="COPYRIGHT.html">
@@ -23,7 +23,7 @@
 <item><htmlurl name="The XInput extension in XFree86"
 	url="xinput.html">
 <!--
-<item><htmlurl name="README for XFree86 3.1.2 on BSD/OS 2.0"
+<item><htmlurl name="README for XFree86 on BSD/OS 2.0"
 	url="Bsdi.html">
 -->
 <item><htmlurl name="README for XFree86 on FreeBSD"
@@ -32,17 +32,17 @@
 	url="isc.html">
 <item><htmlurl name="Information for Linux Users"
 	url="Linux.html">
-<item><htmlurl name="README for XFree86 3.3.3 on LynxOS"
+<item><htmlurl name="README for XFree86 on LynxOS"
 	url="LynxOS.html">
 <!--
-<item><htmlurl name="README for XFree86 3.1 on Mach"
+<item><htmlurl name="README for XFree86 on Mach"
 	url="Mach.html">
 -->
-<item><htmlurl name="README for XFree86 3.3.3 on NetBSD"
+<item><htmlurl name="README for XFree86 on NetBSD"
 	url="NetBSD.html">
-<item><htmlurl name="README for XFree86 3.3.3 on OpenBSD"
+<item><htmlurl name="README for XFree86 on OpenBSD"
 	url="OpenBSD.html">
-<item><htmlurl name="README for XFree86 3.3.3 on OS/2"
+<item><htmlurl name="README for XFree86 on OS/2"
 	url="OS2.html">
 <item><htmlurl name="Notes on Rebuilding XFree86/OS2 from Scratch"
 	url="OS2Notes.html">
@@ -58,7 +58,7 @@
 	url="BUILD.html">
 <item><htmlurl name="XFree86 Video Timings HOWTO"
 	url="VideoModes.html">
-<item><htmlurl name="Readme for the XFree86 3.3.3 LinkKit"
+<item><htmlurl name="Readme for the XFree86 LinkKit"
 	url="LinkKit.html">
 <item><htmlurl name="How to add an (S)VGA driver to XFree86"
 	url="VGADriver.html">
@@ -84,11 +84,13 @@
 	url="Mach64.html">
 <item><htmlurl name="Information for Matrox Millennium Users"
 	url="MGA.html">
+<item><htmlurl name="Information for Number Nine I128 Users"
+	url="I128.html">
 <item><htmlurl name="Information for NVidia / SGS-Thomson NV1, Riva 128 and Riva TNT Users"
 	url="NVIDIA.html">
 <item><htmlurl name="Information for Oak Technologies Inc. Chipset Users"
 	url="Oak.html">
-<item><htmlurl name="XFree86 3.3.3 P9000 Server Release Notes"
+<item><htmlurl name="XFree86 P9000 Server Release Notes"
 	url="P9000.html">
 <item><htmlurl name="Information for S3 Chipset Users"
 	url="S3.html">
@@ -121,7 +123,7 @@
 </itemize>
 
 <verb>
-$XFree86: xc/programs/Xserver/hw/xfree86/doc/sgml/DocIndex.sgml,v 3.24.2.15 1998/11/13 13:00:43 dawes Exp $ 
+$XFree86: xc/programs/Xserver/hw/xfree86/doc/sgml/DocIndex.sgml,v 3.24.2.17 1998/12/23 13:36:26 hohndel Exp $ 
 
 
 
Index: xc/programs/Xserver/hw/xfree86/doc/sgml/I128.sgml
diff -u /dev/null xc/programs/Xserver/hw/xfree86/doc/sgml/I128.sgml:1.1.2.3
--- /dev/null	Wed Jan  6 00:31:22 1999
+++ xc/programs/Xserver/hw/xfree86/doc/sgml/I128.sgml	Sat Jan  2 13:32:16 1999
@@ -0,0 +1,90 @@
+<!DOCTYPE linuxdoc PUBLIC "-//XFree86//DTD linuxdoc//EN">
+
+<article>
+<title>Information for Number Nine I128 Users
+<author>The XFree86 Project Inc.
+<date>24 October 1998
+<toc>
+
+<sect>Supported hardware
+<p>
+The current accelerated I128 server supports
+<p>
+<itemize>
+<item>Imagine 128
+(I128 with Texas Instruments TVP3025 or IBM528 RAMDAC). It has been tested with 
+with 4MB of VRAM. 
+<item>Imagine 128 Ticket 2 Ride
+(I128-T2R with IBM526 or 528 RAMDAC). It has been tested with 4 MB and 8 MB of
+VRAM and DRAM.
+<item>Imagine 128 Revolution 3D
+(I128-R3D with IBM526 RAMDAC).  It has been tested with 4 MB, 8 MB, and 16 MB
+of WRAM or SGRAM.
+<item>Imagine 128 Revolution IV
+(I128-R4 with SILVERHAMMER RAMDAC).  It has been tested with 32 MB.
+</itemize>
+
+<sect>Features:
+<p>
+<itemize>
+<item>uses linear frame buffer
+<item>Resolutions up to the maximum supported by the card should be possible.
+<item>8 bpp, 16 bpp (depth 15 and 16), and 32 bpp (depth 24, sparse) are
+supported.
+<item>supports RGB Sync-on-Green 
+<item>Makes use of the graphics accelerator.
+</itemize>
+
+<sect>Configuration:
+<p>
+The I128 driver should auto-detect all supported hardware so you needn't 
+have anything other than the Identifier in the Section "Device" of the
+XF86Config file.  When running the XF86Setup or xf86config programs one    
+merely needs to select an I128 card so that the correct server will be  
+used.  One need not and should not specify a RAMDAC, clockchip or allow 
+the setup program to probe for clocks. The driver will auto-detect the   
+amount of video ram present.
+
+The following Section "Device" options are supported by the MGA driver:
+<itemize>
+<item>Option "dac_8_bit"
+<p>
+Will enable 8-bit DAC support.
+<item>Option "no_accel"
+<p>
+Will disable all hardware acceleration.
+<item>Option "sync_on_green"
+<p>
+Will enable syncing on green for sync-on-green monitors (these are typically
+fixed frequency workstation monitors).
+</itemize>
+
+<sect>Mode lines for the SiliconGraphics flat panel display:
+<p>
+<itemize>
+<item>These mode lines are required for use with the T2R4 (Rev 4) and the
+SiliconGraphics Flat Panel display.
+<item>Modeline "1600x1024d32" 103.125  1600 1600 1656 1664 1024 1024 1029 1030 HSkew 7 +Hsync +Vsync
+<item>Modeline "1600x1024d16" 103.125  1600 1600 1656 1664 1024 1024 1029 1030 HSkew 5 +Hsync +Vsync
+<item>Modeline "1600x1024d08" 103.125  1600 1600 1656 1664 1024 1024 1029 1030 HSkew 1 +Hsync +Vsync
+<item>Modeline "800x512d32"   54.375   800 800 840 848 512 512 514 515 HSkew 7 DoubleScan +Hsync +Vsync
+<item>Modeline "800x512d16"   54.375   800 800 840 848 512 512 514 515 HSkew 5 DoubleScan +Hsync +Vsync
+<item>Modeline "800x512d08"   54.375   800 800 840 848 512 512 514 515 HSkew 1 DoubleScan +Hsync +Vsync
+</itemize>
+
+<sect>Author(s)
+<p>
+
+Robin Cutshaw, <it>robin@XFree86.Org</it>
+
+and special help from:
+
+<itemize>
+<item>Galen Brooks, <it>galen@nine.com</it>
+</itemize>
+
+<verb>
+$XFree86: xc/programs/Xserver/hw/xfree86/doc/sgml/I128.sgml,v 1.1.2.3 1999/01/02 02:32:16 robin Exp $
+</verb>
+
+</article>
Index: xc/programs/Xserver/hw/xfree86/doc/sgml/Imakefile
diff -u xc/programs/Xserver/hw/xfree86/doc/sgml/Imakefile:3.25.2.15 xc/programs/Xserver/hw/xfree86/doc/sgml/Imakefile:3.25.2.16
--- xc/programs/Xserver/hw/xfree86/doc/sgml/Imakefile:3.25.2.15	Sat Nov 14 00:00:44 1998
+++ xc/programs/Xserver/hw/xfree86/doc/sgml/Imakefile	Fri Dec  4 12:36:46 1998
@@ -3,7 +3,7 @@
 
 
 
-XCOMM $XFree86: xc/programs/Xserver/hw/xfree86/doc/sgml/Imakefile,v 3.25.2.15 1998/11/13 13:00:44 dawes Exp $
+XCOMM $XFree86: xc/programs/Xserver/hw/xfree86/doc/sgml/Imakefile,v 3.25.2.16 1998/12/04 01:36:46 dawes Exp $
 
 #include <Server.tmpl>
 #include <lnxdoc.rules>
@@ -61,6 +61,7 @@
 
 /* Hardware docs */
 LinuxDocReadmeTarget(DECtga)
+LinuxDocReadmeTarget(I128)
 LinuxDocReadmeTarget(Mach32)
 LinuxDocReadmeTarget(Mach64)
 LinuxDocReadmeTarget(MGA)
Index: xc/programs/Xserver/hw/xfree86/doc/sgml/Linux.sgml
diff -u xc/programs/Xserver/hw/xfree86/doc/sgml/Linux.sgml:3.13.2.6 xc/programs/Xserver/hw/xfree86/doc/sgml/Linux.sgml:3.13.2.7
--- xc/programs/Xserver/hw/xfree86/doc/sgml/Linux.sgml:3.13.2.6	Sun Nov  8 20:06:39 1998
+++ xc/programs/Xserver/hw/xfree86/doc/sgml/Linux.sgml	Thu Dec 24 00:36:26 1998
@@ -4,15 +4,13 @@
  
 <title>Information for Linux Users
 <author>Orest Zborowski, Dirk Hohndel
-<date>November 7, 1998
+<date>December 23, 1998
 <toc>
 
 <sect>Linux versions on which XFree86 has been tested <p>
-XFree86 has been tested with Linux version 2.0.32 and several 2.1.x kernels.
-It is known not to compile with kernel sources newer then somewhere around
-2.1.70, due to incompatibilities in the joystick driver. Except for the
-joystick driver, it works just fine with all 2.1.x kernels tested (including
-2.1.88). It should work with any version since 1.0 without change. The 
+XFree86 has been tested with Linux version 2.0.36 and several 2.1.x kernels.
+It works just fine with all 2.1.x kernels tested (including
+2.1.131). It should work with any version since 1.0 without change. The 
 binaries and libraries are based on the 5.3.12 Elf C libraries, and the 
 1.7.14 dynamic linker <tt>ld.so</tt>. You will at least need the 5.2.x Elf 
 C libraries to successfully use the servers.
@@ -140,91 +138,8 @@
 The xdm binary provided should run with both shadow- and non-shadow password
 systems.
 
-<sect>xterm
-<p>
-The XFree86-3.3.3 binary release contains an xterm binary that has been linked
-statically against libtermcap. This was done to make sure that it will
-correctly work with all distributions, regardless whether they rely on
-libtermcap or libncurses. Contrary to the xterm binaries in some beta version
-following XFree86-3.1.2, this binary does not rely on a recent libncurses
-being installed on your system.
-
-<sect>Input devices
-<p>
-XFree86 now support the dynamic loading of drivers for external
-input devices using the <tt/XInput/ extension. Currently supported
-devices are:
-<itemize>
-<item>Joystick (<tt/xf86Jstk.so/)
-<item>Wacom tablets (Wacom IV protocol only, <tt/xf86Wacom.so/)
-<item>SummaSketch tablets (<tt/xf86Summa.so/)
-<item>Elographics touchscreen (<tt/xf86Elo.so/)
-<item>AceCad ADVANCEDigitizer (<tt/xf86AceCad.so/)
-<item>MicroTouch TouchPen (<tt/xf86MuTouch.so/)
-<item>SGI dial box (<tt/xf86Dial.so/)
-</itemize>
-
-To use a specific device, add the line
-<tscreen>
-<tt/load/ <tt/"/<em/module/<tt/"/
-</tscreen>
-in the <bf/Module/ section of <tt/XF86Config/, where <em/module/ is
-the name of the <tt/.so/ file corresponding to your device.
-You also need to set up a <bf/XInput/ section in <tt/XF86Config/. 
-Refer to the <em>XF86Config(5)</em> man page for detailed
-configuration instructions.
-<p>
-You can then change the device used to drive the X pointer with the
-<em/xsetpointer(1)/ command.
-<p>
-For joystick support, you'll need to install the joystick device
-driver in the kernel. 
-
-<sect1>Configuring PEX, XIE and GLX extensions
-<p>
-The PEX, XIE and GLX extensions are now supported as external modules.
-If you want to have access to these extensions, add the following
-lines to the <bf/Module/ section of <tt/XF86Config/:
-<tscreen><verb>
-   load    "pex5.so"
-   load    "xie.so"
-</verb></tscreen>
-For GLX you need to get the appropriate GLX modules, first. They are, at this
-time, not part of the XFree86 distribution.
-
-<sect> Compiling XFree86 <p>
-There are no special instructions required for compiling XFree86.
-This version was compiled with gcc-2.7.2.1, the 5.3.12 Elf libraries and the
-1.7.14 shared, dynamic linker ld.so. 
-The server has been
-compiled with <tt>-m486</tt>, which optimizes it for the 486 processor, but
-the binary will run on the 386 processor (there is a slight increase in
-binary size over using <tt>-m386</tt>, but no loss of performance).
-
-All extensions and clients have been ported and tested. By default,
-the servers are compiled without any extra extensions (PEX, XIE, etc),
-but libraries for those extensions are always generated. They can be loaded 
-at runtime, see the XFree86 man page for details. By modifying
-<tt>site.def</tt>, extra extensions can be compiled into the server.
-Alternately, the link kit can be used to craft modified servers.
-
-If an aout version of XFree86 is to be built and patches are applied which 
-significantly change the libraries,
-modified jump_xxx files will be needed. Those can be generated according to
-instructions given in the DLL tools package, and will be made available as
-XFree86 patches.
-
-The JUMP_xxx defines used to compile the X libraries can also be
-used to compile external X shared libraries, like Xaw3d. Detailed
-instructions are provided in <tt>/usr/X11R6/lib/X11/config/lnxLib.rules</tt>,
-where the X library definitions are provided, as an example.
-
-<sect>Bug Notification <p>
-Bug reports should be sent to <it>XFree86@XFree86.org</it> or posted
-to the <it>comp.windows.x.i386unix</it> newsgroup.
-
 <verb>
-$XFree86: xc/programs/Xserver/hw/xfree86/doc/sgml/Linux.sgml,v 3.13.2.6 1998/11/08 09:06:39 dawes Exp $
+$XFree86: xc/programs/Xserver/hw/xfree86/doc/sgml/Linux.sgml,v 3.13.2.7 1998/12/23 13:36:26 hohndel Exp $
 
 
 
Index: xc/programs/Xserver/hw/xfree86/doc/sgml/LynxOS.sgml
diff -u xc/programs/Xserver/hw/xfree86/doc/sgml/LynxOS.sgml:3.14.2.8 xc/programs/Xserver/hw/xfree86/doc/sgml/LynxOS.sgml:3.14.2.9
--- xc/programs/Xserver/hw/xfree86/doc/sgml/LynxOS.sgml:3.14.2.8	Sun Nov  8 00:52:41 1998
+++ xc/programs/Xserver/hw/xfree86/doc/sgml/LynxOS.sgml	Tue Dec 29 18:54:27 1998
@@ -2,9 +2,9 @@
 
 <article>
 
-<title>README for XFree86 3.3.3 on LynxOS
+<title>README for XFree86 on LynxOS
 <author>Thomas Mueller
-<date>Last modified on: 10 October 1998
+<date>Last modified on: 29 December 1998
 <toc>
 
 <sect>What and Where is XFree86?<p>
@@ -23,7 +23,7 @@
 <htmlurl name="ftp://ftp.XFree86.org/pub/XFree86/current"
 url="ftp://ftp.XFree86.org/pub/XFree86/current">
 
-Binaries of the 3.3.3 release for LynxOS AT are available from:
+Binaries of XFree86 for LynxOS AT are available from:
 
 <htmlurl name="ftp://ftp.XFree86.org/pub/XFree86/current/binaries/LynxOS"
 url="ftp://ftp.XFree86.org/pub/XFree86/current/binaries/LynxOS">
@@ -51,7 +51,7 @@
 
 <sect>Installing the Binaries
 <p>
-Please refer to section "Installing the XFree86 3.3.3 Release" of the 
+Please refer to section "Installing the XFree86 3.3.3.1 Release" of the 
 <htmlurl url="RELNOTES.html" name="Release Notes"> for detailed 
 installation instructions.
 
@@ -128,9 +128,9 @@
      # reboot -N
   </verb></tscreen>
 
-<sect1>Mouse support in 3.3.3<p>
+<sect1>Mouse support in XFree86<p>
 
-  XFree86 3.3.3 includes support for PnP mice (see also
+  XFree86 includes support for PnP mice (see also
   <htmlurl url="mouse.html" name="Mouse Support in XFree86">). The
   current LynxOS TTY device driver doesn't allow the necessary
   manipulation of the RTS line and therefore the support for
@@ -535,7 +535,7 @@
   <tt>lynx.cf</tt> but it has never been tested (reports are welcome).
 
 <verb>
-$XFree86: xc/programs/Xserver/hw/xfree86/doc/sgml/LynxOS.sgml,v 3.14.2.8 1998/11/07 13:52:41 dawes Exp $
+$XFree86: xc/programs/Xserver/hw/xfree86/doc/sgml/LynxOS.sgml,v 3.14.2.9 1998/12/29 07:54:27 hohndel Exp $
 
 
 
Index: xc/programs/Xserver/hw/xfree86/doc/sgml/MGA.sgml
diff -u xc/programs/Xserver/hw/xfree86/doc/sgml/MGA.sgml:3.4.2.14 xc/programs/Xserver/hw/xfree86/doc/sgml/MGA.sgml:3.4.2.15
--- xc/programs/Xserver/hw/xfree86/doc/sgml/MGA.sgml:3.4.2.14	Thu Nov 19 21:08:14 1998
+++ xc/programs/Xserver/hw/xfree86/doc/sgml/MGA.sgml	Wed Dec 30 20:14:45 1998
@@ -3,7 +3,7 @@
 <article>
 <title>Information for Matrox Users
 <author>The XFree86 Project Inc.
-<date>24 October 1998
+<date>30 December 1998
 <toc>
 
 <sect>Supported hardware
@@ -46,7 +46,7 @@
 <item>supports RGB Sync-on-Green 
 <item>supports the XF86_DGA extension
 <item>Makes extensive use of the graphics accelerator.  This server is very 
-well accelerated, and is one of the fastest XFree86 3.3.3 Xservers.
+well accelerated, and is one of the fastest XFree86 X servers.
 </itemize>
 
 <sect>Configuration:
@@ -105,7 +105,7 @@
 <itemize>
 <item>Temporary loss of monitor sync when the cursor shape changes on 
 Millennium and Millennium II.  The hardware cursor has been enabled by 
-default in 3.3.3. This seems to cause some problems on a minority of
+default in 3.3.3.1. This seems to cause some problems on a minority of
 systems.  If you experience problems with this on your system, 
 please put:
 <verb>
@@ -121,7 +121,8 @@
 	Option "sw_cursor"
 </verb>
 in the Section "Device" of the XF86Config file to disable the hardware
-cursor.
+cursor. This should be fixed in XFree86 3.3.3.1 as in cases like this the
+software cursor should be used automatically.
 <item>the driver doesn't support some values of HTotal parameter in
 Modelines in the XF86Config file. If you get flickering vertical stripes on
 the screen, try to change this parameter +/- 8.
@@ -143,6 +144,14 @@
 text console, make sure that the amount of memory that the server reports 
 is correct.
 See item above for details.
+<item>With virtual screens that use 8MB of memory or more (e.g.,
+2048x2048 at 16bpp) there can be cursor distortions when panning the screen
+vertically. If that occurs, please put
+<verb>
+	Option "sw_cursor"
+</verb>
+in the Section "Device" of the XF86Config file to disable the hardware
+cursor.
 </itemize>
 
 <sect>Authors
@@ -169,7 +178,7 @@
 </itemize>
 
 <verb>
-$XFree86: xc/programs/Xserver/hw/xfree86/doc/sgml/MGA.sgml,v 3.4.2.14 1998/11/19 10:08:14 dawes Exp $
+$XFree86: xc/programs/Xserver/hw/xfree86/doc/sgml/MGA.sgml,v 3.4.2.15 1998/12/30 09:14:45 hohndel Exp $
 </verb>
 
 </article>
Index: xc/programs/Xserver/hw/xfree86/doc/sgml/NetBSD.sgml
diff -u xc/programs/Xserver/hw/xfree86/doc/sgml/NetBSD.sgml:3.45.2.9 xc/programs/Xserver/hw/xfree86/doc/sgml/NetBSD.sgml:3.45.2.10
--- xc/programs/Xserver/hw/xfree86/doc/sgml/NetBSD.sgml:3.45.2.9	Sun Nov  8 00:52:42 1998
+++ xc/programs/Xserver/hw/xfree86/doc/sgml/NetBSD.sgml	Tue Dec 29 18:54:28 1998
@@ -1,13 +1,13 @@
 <!DOCTYPE linuxdoc PUBLIC "-//XFree86//DTD linuxdoc//EN">
 
 <article>
-<title>README for XFree86 3.3.3 on NetBSD
+<title>README for XFree86 on NetBSD
 <author>Rich  Murphey,
 David Dawes,
 Marc  Wandschneider,
 Mark  Weaver,
 Matthieu Herrb
-<Date>Last modified on: 17 October 1998
+<Date>Last modified on: 29 December 1998
 
 <toc>
 
@@ -15,7 +15,7 @@
 <sect>What and Where is XFree86?
 
 <p>
-XFree86 3.3.3 is a port of X11R6.3 that supports several versions of
+XFree86 is a port of X11R6.3 that supports several versions of
 Intel-based Unix.  It is derived from X386 1.2, which was the X server
 distributed with X11R5.  This release consists of many new features
 and performance improvements as well as many bug fixes.  The release
@@ -49,16 +49,16 @@
 upgrading to a newer version of NetBSD first.
 
 If you don't upgrade, you'll have to build XFree86 from the sources.
-XFree86 3.3.3 should compile cleanly under earlier versions of
+XFree86 should compile cleanly under earlier versions of
 NetBSD, although this has not been tested.
 
-XFree86 3.3.3 also builds on NetBSD/sparc. See section
+XFree86 also builds on NetBSD/sparc. See section
 <ref id="sparc" name="Building on other architectures"> for details.
 
 The client side of XFree86 also builds on NetBSD/alpha and many other 
 architecture supported by NetBSD. 
 
-XFree86 3.3.3 also supports NetBSD on PC98 machines. 
+XFree86 also supports NetBSD on PC98 machines. 
 
 
 <sect>Bug Reports for This Document
@@ -72,7 +72,7 @@
 
 <p>
 See the <htmlurl url="RELNOTES.html" name="Release Notes"> for
-non-OS dependent new features in XFree86 3.3.3.
+non-OS dependent new features in XFree86 3.3.3.1.
 
 <sect>Installing the Binaries
 
@@ -374,7 +374,7 @@
 
 
 <p>
-XFree86 3.3.3 has a configuration option to select the console
+XFree86 has a configuration option to select the console
 drivers to use in <tt/xf86site.def/:
 <itemize>
 <item> if you're using pccons put:
@@ -453,7 +453,7 @@
 <sect1>Building on other architectures<label id="sparc">
 
 <p>
-XFree86 3.3.3 also compiles on NetBSD/sparc. The Sun server
+XFree86 also compiles on NetBSD/sparc. The Sun server
 patches from Dennis Ferguson and Matthew Green have been integrated in
 <tt>xc/programs/Xserver/hw/sun</tt>.  Small
 modifications to <tt/xf86site.def/ are needed:
@@ -544,7 +544,7 @@
 </itemize>
 
 <verb>
-$XFree86: xc/programs/Xserver/hw/xfree86/doc/sgml/NetBSD.sgml,v 3.45.2.9 1998/11/07 13:52:42 dawes Exp $
+$XFree86: xc/programs/Xserver/hw/xfree86/doc/sgml/NetBSD.sgml,v 3.45.2.10 1998/12/29 07:54:28 hohndel Exp $
 
 
 
Index: xc/programs/Xserver/hw/xfree86/doc/sgml/OS2.sgml
diff -u xc/programs/Xserver/hw/xfree86/doc/sgml/OS2.sgml:3.9.2.7 xc/programs/Xserver/hw/xfree86/doc/sgml/OS2.sgml:3.9.2.8
--- xc/programs/Xserver/hw/xfree86/doc/sgml/OS2.sgml:3.9.2.7	Wed Nov  4 19:01:53 1998
+++ xc/programs/Xserver/hw/xfree86/doc/sgml/OS2.sgml	Tue Dec 29 18:54:29 1998
@@ -1,9 +1,9 @@
 <!DOCTYPE linuxdoc PUBLIC "-//XFree86//DTD linuxdoc//EN">
 
 <article>
-<title>README for XFree86 3.3.3 on OS/2
+<title>README for XFree86 on OS/2
 <author>Holger Veit
-<Date>Last modified on: 04 October 1998
+<Date>Last modified on: December 29, 1998
 
 <toc>
 
@@ -643,7 +643,7 @@
 </itemize>
 
 <verb>
-$XFree86: xc/programs/Xserver/hw/xfree86/doc/sgml/OS2.sgml,v 3.9.2.7 1998/11/04 08:01:53 hohndel Exp $
+$XFree86: xc/programs/Xserver/hw/xfree86/doc/sgml/OS2.sgml,v 3.9.2.8 1998/12/29 07:54:29 hohndel Exp $
 
 
 
Index: xc/programs/Xserver/hw/xfree86/doc/sgml/OpenBSD.sgml
diff -u xc/programs/Xserver/hw/xfree86/doc/sgml/OpenBSD.sgml:1.1.2.7 xc/programs/Xserver/hw/xfree86/doc/sgml/OpenBSD.sgml:1.1.2.9
--- xc/programs/Xserver/hw/xfree86/doc/sgml/OpenBSD.sgml:1.1.2.7	Sun Nov  8 00:52:43 1998
+++ xc/programs/Xserver/hw/xfree86/doc/sgml/OpenBSD.sgml	Tue Jan  5 18:15:47 1999
@@ -1,10 +1,10 @@
 <!DOCTYPE linuxdoc PUBLIC "-//XFree86//DTD linuxdoc//EN">
 
 <article>
-<title>README for XFree86 3.3.3 on OpenBSD
+<title>README for XFree86 on OpenBSD
 <author>
 Matthieu Herrb
-<Date>Last modified on: 17 October 1998
+<Date>Last modified on: 29 December 1998
 
 <toc>
 
@@ -12,7 +12,7 @@
 <sect>What and Where is XFree86?
 
 <p>
-XFree86 3.3.3 is a port of X11R6.3 that supports several versions of
+XFree86 is a port of X11R6.3 that supports several versions of
 Intel-based Unix.  It is derived from X386 1.2, which was the X server
 distributed with X11R5.  This release consists of many new features
 and performance improvements as well as many bug fixes.  The release
@@ -26,7 +26,7 @@
 <htmlurl name="ftp://ftp.XFree86.org/pub/XFree86/current"
 url="ftp://ftp.XFree86.org/pub/XFree86/current">
 
-Binaries for OpenBSD 2.3 and later are available from:
+Binaries for OpenBSD 2.4 and later are available from:
 
 <htmlurl name="ftp://ftp.XFree86.org/pub/XFree86/current/binaries/OpenBSD"
 url="ftp://ftp.XFree86.org/pub/XFree86/current/binaries/OpenBSD">
@@ -37,7 +37,7 @@
 
 <p>
 
-XFree86 3.3.3 also builds on other OpenBSD architectures. See section
+XFree86 also builds on other OpenBSD architectures. See section
 <ref id="otherarch" name="Building on other architectures"> for details.
 
 
@@ -51,7 +51,7 @@
 <sect>New features in this release
 <p>
 See the <htmlurl url="RELNOTES.html" name="Release Notes"> for
-new features in XFree86 3.3.3.
+new features in XFree86.
 
 <sect>Installing the Binaries
 
@@ -258,7 +258,7 @@
 Uncomment the lines loading the aperture driver from
 <tt>/etc/rc.securelevel</tt> 
 
-<item> OpenBSD-2.3
+<item> OpenBSD 2.3
      
 The aperture driver is part of the kernel.  Add 'option APERTURE' to
 your kernel configuration file, build and install the new kernel and
@@ -266,7 +266,7 @@
 <tt>/etc/sysctl.conf</tt> to set the variable
 <bf>machdep.allowaperture</bf> to 1.
 
-<item> OpenBSD-current and the upcoming OpenBSD 2.4 
+<item> OpenBSD 2.4 and later
 
 OpenBSD now requires the aperture driver to be enabled for all X
 servers, because the aperture driver also controls access to the
@@ -335,7 +335,7 @@
 <sect1>Console drivers<label id="console-drivers">
 
 <p>
-XFree86 3.3.3 has a configuration option to select the console
+XFree86 has a configuration option to select the console
 drivers to use in <tt/xf86site.def/:
 <itemize>
 <item> if you're using pccons only put:
@@ -355,7 +355,7 @@
 <sect1>Building on other architectures<label id="otherarch">
 
 <p>
-XFree86 3.3.3 also compiles on other OpenBSD architectures. 
+XFree86 also compiles on other OpenBSD architectures. 
 
 The XFree86 servers can also been built on OpenBSD/mips. The S3 server
 has been tested on an Acer Mips system with a S3/928 board. Contact
@@ -393,7 +393,7 @@
 
 
 <verb>
-$XFree86: xc/programs/Xserver/hw/xfree86/doc/sgml/OpenBSD.sgml,v 1.1.2.7 1998/11/07 13:52:43 dawes Exp $
+$XFree86: xc/programs/Xserver/hw/xfree86/doc/sgml/OpenBSD.sgml,v 1.1.2.9 1999/01/05 07:15:47 hohndel Exp $
 
 
 
Index: xc/programs/Xserver/hw/xfree86/doc/sgml/P9000.sgml
diff -u xc/programs/Xserver/hw/xfree86/doc/sgml/P9000.sgml:3.18.2.6 xc/programs/Xserver/hw/xfree86/doc/sgml/P9000.sgml:3.18.2.7
--- xc/programs/Xserver/hw/xfree86/doc/sgml/P9000.sgml:3.18.2.6	Sun Nov  8 00:37:48 1998
+++ xc/programs/Xserver/hw/xfree86/doc/sgml/P9000.sgml	Tue Dec 29 18:54:30 1998
@@ -2,9 +2,9 @@
  
 <article>
  
-<title>XFree86 3.3.3 P9000 Server Release Notes
+<title>XFree86 P9000 Server Release Notes
 <author>Erik Nygren (<it>nygren@mit.edu</it>)
-<date>1998 October 13
+<date>1998 December 29
 <toc>
  
 <sect>Change Log <p>
@@ -459,7 +459,7 @@
 acceleration, etc.  Please send any patches to me (<it>nygren@mit.edu</it>).
 
 <verb>
-$XFree86: xc/programs/Xserver/hw/xfree86/doc/sgml/P9000.sgml,v 3.18.2.6 1998/11/07 13:37:48 dawes Exp $
+$XFree86: xc/programs/Xserver/hw/xfree86/doc/sgml/P9000.sgml,v 3.18.2.7 1998/12/29 07:54:30 hohndel Exp $
 
 
 
Index: xc/programs/Xserver/hw/xfree86/doc/sgml/README.sgml
diff -u xc/programs/Xserver/hw/xfree86/doc/sgml/README.sgml:3.75.2.41 xc/programs/Xserver/hw/xfree86/doc/sgml/README.sgml:3.75.2.46
--- xc/programs/Xserver/hw/xfree86/doc/sgml/README.sgml:3.75.2.41	Thu Nov 19 21:08:14 1998
+++ xc/programs/Xserver/hw/xfree86/doc/sgml/README.sgml	Tue Jan  5 18:15:48 1999
@@ -3,25 +3,24 @@
 
 <article>
 
-<title>README for XFree86&tm; 3.3.3
+<title>README for XFree86&tm; 3.3.3.1
 <author>The XFree86 Project, Inc
-<date>19 November 1998
+<date>20 December 1998
 
 
 <abstract>
 
 XFree86 is a port of X11R6.3 that supports several Unix and Unix-like
 operating systems on Intel and other platforms.  This release is a
-full release, fixing a number of bugs and adding support for lots of
-new cards compared to XFree86-3.3.2.
-The release is available
-as source patches against the X Consortium X11R6.3 code and the XFree86
-3.3.2 release.  Binary distributions for many architectures are also
-available, including a binary upgrade for XFree86 3.3.2.
+quick update to XFree86 3.3.3, fixing a number of bugs that were found
+after releasing it.  The release is available as source patches
+against the X Consortium X11R6.3 code and the XFree86 3.3.3 release.
+Binary distributions for many architectures are also available,
+including a binary upgrade for XFree86 3.3.3.
 
 </abstract>
 
-<sect>What's new in XFree86 3.3.3
+<sect>What's new in XFree86 3.3.3.1
 <p>
 
 For a summary of new features in this release, please refer to the
@@ -67,10 +66,10 @@
 
     <tag/Others:/
 	<itemize>	
-	<ITEM>NetBSD 1.0, 1.1, 1.2, 1.2.1, 1.3, 1.3.1, 1.3.2
-	<ITEM>OpenBSD 2.0, 2.1
+	<ITEM>NetBSD 1.0, 1.1, 1.2, 1.2.1, 1.3, 1.3.1, 1.3.2, 1.3.3
+	<ITEM>OpenBSD 2.0, 2.1, 2.2, 2.3, 2.4
 	<ITEM>FreeBSD 2.0.5, 2.1, 2.1.5, 2.1.6, 2.1.7, 2.1.7.1, 2.2,
-		2.2.1, 2.2.2, 2.2.5, 2.2.6, 2,2,7, 3.0
+		2.2.1, 2.2.2, 2.2.5, 2.2.6, 2,2,7, 2.2.8, 3.0
 <!--
 	<ITEM>BSD/386 1.1, BSD/OS 2.0
 	<ITEM>Mach 386
@@ -89,7 +88,7 @@
     <tag/PC98:/
 	<itemize>
 	<ITEM>FreeBSD(98) 2.0.5, 2.1, 2.1.5, 2.1.7.1, 2.2, 2.2.1,
-		2.2.2, 2.2.5, 2.2.6, 2,2,7
+		2.2.2, 2.2.5, 2.2.6, 2,2,7, 2.2.8, 3.0
 	<ITEM>NetBSD/pc98 (based on NetBSD 1.2, 1.2.1, 1.3, 1.3.1, 1.3.2)
 	<ITEM>PANIX 5.0 for 98
 	<ITEM>Linux/98
@@ -100,7 +99,7 @@
 <sect> Supported video-card chip-sets
 <p>
 
-At this time, XFree86 3.3.3 supports the following chipsets:
+At this time, XFree86 3.3.3.1 supports the following chipsets:
 
   <DESCRIP>
     <tag/Ark Logic/
@@ -148,7 +147,7 @@
     <tag/NeoMagic/
         2200, 2160, 2097, 2093, 2090, 2070
     <tag/Number Nine/
-	I128 (series I and II), Revolution 3D (T2R)
+	I128 (series I, II and IV), Revolution 3D (T2R)
     <tag>NVidia/SGS Thomson </tag>
 	NV1, STG2000, RIVA128, Riva TNT
     <tag/OAK /
@@ -194,7 +193,7 @@
 Refer to the chipset-specific <tt>README</tt> files (currently for
 <htmlurl name=TGA url=DECtga.html>, <htmlurl name=Matrox url=MGA.html>,
 <htmlurl name=Mach32 url=Mach32.html>, <htmlurl name=Mach64 url=Mach64.html>,
-<htmlurl name=NVidia url=NV1.html>, <htmlurl name=Oak url=Oak.html>,
+<htmlurl name=NVidia url=NVIDIA.html>, <htmlurl name=Oak url=Oak.html>,
 <htmlurl name=P9000 url=P9000.html>,
 <htmlurl name="S3 (except ViRGE)" url=S3.html>,
 <htmlurl name="S3 ViRGE" url=S3V.html>, <htmlurl name=SiS url=SiS.html>,
@@ -705,7 +704,7 @@
 <itemize>
        <item>Joerg Wunsch <it>&lt;joerg_wunsch@uriah.sax.de&gt;</it> (ET3000 banked mono),
        <item>Thomas Dickey <it>&lt;dickey@clark.net&gt;</it>
-		(xterm "new" model ANSI colors and VT220, VT520 emulation).
+		(xterm "new" model ANSI colors and VT220, VT52 emulation).
        <item>Eric Raymond <it>&lt;esr@snark.thyrsus.com&gt;</it> (new video mode documentation),
 
        <item>and an entire horde of beta-testers around the world!
@@ -725,6 +724,7 @@
        <item>Dirk Hohndel <it>&lt;hohndel@XFree86.org&gt;</it>
        <item>Harald Koenig <it>&lt;koenig@XFree86.org&gt;</it>
        <item>Rich Murphey <it>&lt;rich@XFree86.org&gt;</it>
+       <item>Takaaki Nomura <it>&lt;nomura@XFree86.org&gt;</it>
        <item>Jon Tombs <it>&lt;tombs@XFree86.org&gt;</it>
        <item>David Wexelblat <it>&lt;dwex@XFree86.org&gt;</it> 
 </itemize>
@@ -931,8 +931,8 @@
 
 Source patches are available to upgrade X11R6.3 PL2 from the X Consortium
 (now The Open Group)
-to XFree86 3.3.3.  Binaries for many OSs are also available.  The distribution
-is available from:
+to XFree86 3.3.3.1.  Binaries for many OSs are also available.  The
+distribution is available from:
 
 <itemize>
 <item><htmlurl url="ftp://ftp.XFree86.org/pub/XFree86"
@@ -1088,13 +1088,13 @@
 which files you need to get to build your distribution.
 -->
 
-Ensure that you are getting XFree86 3.3.3 - some of these sites may archive
+Ensure that you are getting XFree86 3.3.3.1 - some of these sites may archive
 older releases as well.  Check the <htmlurl name="RELNOTES"
 url="RELNOTES.html"> to find which files you need to take from the
 archive.
 
 <verb>
-$XFree86: xc/programs/Xserver/hw/xfree86/doc/sgml/README.sgml,v 3.75.2.41 1998/11/19 10:08:14 dawes Exp $
+$XFree86: xc/programs/Xserver/hw/xfree86/doc/sgml/README.sgml,v 3.75.2.46 1999/01/05 07:15:48 hohndel Exp $
 
 
 
Index: xc/programs/Xserver/hw/xfree86/doc/sgml/RELNOTE.sgml
diff -u xc/programs/Xserver/hw/xfree86/doc/sgml/RELNOTE.sgml:3.59.2.61 xc/programs/Xserver/hw/xfree86/doc/sgml/RELNOTE.sgml:3.59.2.68
--- xc/programs/Xserver/hw/xfree86/doc/sgml/RELNOTE.sgml:3.59.2.61	Thu Nov 19 22:27:57 1998
+++ xc/programs/Xserver/hw/xfree86/doc/sgml/RELNOTE.sgml	Wed Dec 30 21:22:34 1998
@@ -2,16 +2,17 @@
 
 <article>
 
-<title>Release Notes for XFree86&tm; 3.3.3
+<title>Release Notes for XFree86&tm; 3.3.3.1
 <author>The XFree86 Project, Inc
-<date>19 November 1998
+<date>30 December 1998
 
 <abstract>
 
-This document describes the bugs fixed and the features added in XFree86 3.3.3 
-compared with the 3.3.2 release,
+This document describes the bugs fixed and the features added in
+XFree86 3.3.3.1 compared with the 3.3.2 and 3.3.3 release, 
 It also includes installation instructions for the binary distributions.
-It is strongly recommended that anyone using XFree86 update to version 3.3.3.
+It is strongly recommended that anyone using XFree86 update to version
+3.3.3.1. 
 
 </abstract>
 
@@ -48,6 +49,8 @@
 Given the fact that our main development focus is on XFree86-4.0 and that 
 the 3.3.3 release was intended mostly to fix some bugs and get out new
 drivers to the public, we opted not to include X11R6.4 in XFree86-3.3.3.
+Since XFree86-3.3.3.1 is merely a quick bug fix release to
+XFree86-3.3.3, the same applies here as well.
 <p>
 XFree86-4.0 will be X11R6.4 based.
 <p>
@@ -65,6 +68,33 @@
 purposes.
 
 <p> 
+<sect> What's new in 3.3.3.1?
+<p>
+<itemize>
+  <item>A system clock slowdown caused by 3Dlabs driver has been fixed.
+  <item>Drawing bugs with C&amp;T HiQV chips have been fixed.
+  <item>Drawing problems in the Cyrix driver have been fixed.
+  <item>The Matrox G100/G200 PCI versions should now be fully supported.
+  <item>The Mach64 server now supports gamma correction.
+  <item>Open Source NVIDIA driver has been provided.
+  <item>I128 Rev IV support has been added.
+  <item>Another S3V lockup has been fixed.
+  <item>A drawing bug in cfb24 has been fixed.
+  <item>A problem causing lockups with some Trident cards has been fixed.
+  <item>Updates for SCO, FreeBSD, Linux glibc OS support.
+  <item>DG/ux support has been added.
+  <item>GNU/Hurd support has been added.
+  <item>Several XINPUT problems have been addressed.
+  <item>DGA relative mouse movement events when XINPUT is defined have
+        been fixed, as have DGA-related problems with the NVIDIA and S3V
+	drivers.
+  <item>The X server now reads Xauthority files using the real user id.
+  <item>Several small fixes to core clients.
+  <item>A bug in Xlib's handling of KOI8-R has been fixed.
+  <item>PC98 cards database, sample config file and XKB handling have
+        been fixed.
+</itemize>
+<p>
 <sect> What's new in 3.3.3?
 <p>
 <sect1> Security fixes
@@ -153,6 +183,10 @@
 </itemize>
 <sect1>Known Problems
 <p>
+The problems listed here are those known at the time of the release.  See
+the <htmlurl name="XFree86 FAQ" url="http://www.xfree86.org/FAQ"> for more
+up to date information.
+<p>
 <itemize>
   <item>There are problems with some Cirrus laptop chipsets (75xx).  The
 	driver seems to work for some people, but not others.  Until
@@ -181,43 +215,18 @@
 url="http://www.opensource.org/osd.html">. 
 This definition is actually a subset of our requirements.
 <p>
-After we had finalized XFree86 3.3.3, and within hours of our planned
-release, NVIDIA insisted that we withdraw two source files from the
-driver that they had supplied to us and replace some other source files
-with versions that were partly run through the C preprocessor.  NVIDIA's
-stated reason for this was to remove some of the names that they thought might
-reveal intellectual property from NVIDIA. This resulted in somewhat
-unreadable and unmaintainable code.
-<p> 
-The XFree86 Project is strongly opposed to such obfuscated code.  Among other
-things, such code does not satisfy the Open Source definition of "Source Code",
-which states that
-<quote>
-The source code must be the preferred form in which a programmer would
-modify the program. Deliberately obfuscated source code is not allowed.
-Intermediate forms such as the output of a preprocessor or translator
-are not allowed.
-</quote>
-Due to the extremely late date of this decision by NVIDIA, we decided
-to include the code as offered by NVIDIA.  All other options would have
-significantly delayed the release of XFree86-3.3.3.  Unless another
-solution can be found with NVIDIA, we will remove this code from future
-releases.
-<p>
-The code affected by this is located in the directory:
-<quote>
-<tt>xc/programs/Xserver/hw/xfree86/vga256/drivers/nv</tt>
-</quote>
-Specifically,
-the files: <tt>nv3arb.c</tt>, <tt>nv3cursor.c</tt>, <tt>nv3driver.c</tt>,
-<tt>nv3setup.c</tt>, <tt>nv4arb.c</tt>, <tt>nv4cursor.c</tt>,
-<tt>nv4driver.c</tt>, <tt>nv4setup.c</tt>.
-All other code in XFree86 3.3.3 satisfies the Open Source Software definition.
+All code in XFree86 3.3.3.1 satisfies the Open Source Software definition.
 <p>
 
-<sect>Installing the XFree86 3.3.3 Release
+<sect>Installing the XFree86 3.3.3.1 Release
 <p>
-The XFree86 3.3.3 binaries are distributed as a full release.
+The XFree86 3.3.3.1 binaries are distributed as a full release.
+<!--
+, and as an
+update to the 3.3.3 release.  For information about upgrading from 3.3.3
+to 3.3.3.1 see section <ref id="upgrade"
+name="Updating XFree86 3.3.3 to XFree86 3.3.3.1">.
+-->
 
 NOTE: the X servers are no longer installed setuid root.  If you are
 starting your X servers with startx/xinit, or something similar, you
@@ -289,6 +298,9 @@
 Intel ix86 based PCs).  Choose at least one which
 matches your hardware, as well as the VGA16 server.  The VGA16 server is
 required by the new configuration utility (XF86Setup).
+A list showing which X server is required for a range of video cards can
+be found at <htmlurl name="http://www.xfree86.org/cardlist.html"
+url="http://www.xfree86.org/cardlist.html">.
 <quote>
 <verb>
 X3DL.tgz        3Dlabs server
@@ -326,6 +338,10 @@
 is, you don't need any of these.  These servers <bf>will not run</bf>
 on "normal" PCs, so don't even try them if you don't have a Japanese PC98
 machine.
+A list showing which X server is required for a range of PC98 video cards
+and computers can
+be found at <htmlurl name="http://www.xfree86.org/cardlist98.html"
+url="http://www.xfree86.org/cardlist98.html">.
 <quote>
 <verb>
 X9NS3.tgz       PC98 NEC(S3) server
@@ -445,17 +461,19 @@
 information.
 
 <!--
-<sect>Updating XFree86 3.3.2 patch 3 to XFree86 3.3.3
+<sect>Updating XFree86 3.3.3 to XFree86 3.3.3.1<label id="upgrade">
 <p>
-The following is required to update an XFree86 3.3.2 patch 3 installation to
-XFree86 3.3.3:
+The following is required to update an XFree86 3.3.3 installation to
+XFree86 3.3.3.1:
 <quote>
 <verb>
 extract              XFree86 extraction utility
-X333upd.tgz         XFree86 3.3.3 update
-X333{SERVER}.tgz    3.3.3 Server update from Servers/PC98_Servers directory
+X3331upd.tgz         XFree86 3.3.3.1 update
+Xdoc.tgz             XFree86 3.3.3.1 documentation
+X{SERVER}.tgz        3.3.3.1 Server update from the Servers or PC98_Servers
+		     directory.
                      You must select the appropriate SERVER file for the
-		     server that you are currently running (i.e. X333S3.tgz).
+		     server that you are currently running (i.e. XI128.tgz).
 </verb>
 </quote>
 
@@ -463,21 +481,17 @@
 <tscreen><verb>
 	chmod 755 extract
 </verb></tscreen>
-To update your installation to 3.3.3, run the following as
+To update your installation to 3.3.3.1, run the following as
 <bf>root</bf>:
 <tscreen><verb>
 	cd /usr/X11R6
-	/var/tmp/extract /var/tmp/X333upd.tgz
-	/var/tmp/extract /var/tmp/X333{SERVER}.tgz
+	/var/tmp/extract /var/tmp/X3331upd.tgz
+	/var/tmp/extract /var/tmp/X{SERVER}.tgz
 </verb></tscreen>
-
-<bf>NOTE: X333upd.tgz supersedes the previous update (X3323upd.tgz),
-so there is no need to have installed X3323upd.tgz before installing
-X333upd.tgz.</bf>
 -->
 
 <verb>
-$XFree86: xc/programs/Xserver/hw/xfree86/doc/sgml/RELNOTE.sgml,v 3.59.2.61 1998/11/19 11:27:57 dawes Exp $
+$XFree86: xc/programs/Xserver/hw/xfree86/doc/sgml/RELNOTE.sgml,v 3.59.2.68 1998/12/30 10:22:34 hohndel Exp $
 </verb>
 
 </article>
Index: xc/programs/Xserver/hw/xfree86/doc/sgml/S3V.sgml
diff -u xc/programs/Xserver/hw/xfree86/doc/sgml/S3V.sgml:3.3.2.8 xc/programs/Xserver/hw/xfree86/doc/sgml/S3V.sgml:3.3.2.9
--- xc/programs/Xserver/hw/xfree86/doc/sgml/S3V.sgml:3.3.2.8	Fri Feb 27 15:53:51 1998
+++ xc/programs/Xserver/hw/xfree86/doc/sgml/S3V.sgml	Fri Dec  4 12:36:48 1998
@@ -254,6 +254,7 @@
 <p>
 
 <sect1> XF86_S3V server
+<p>
 Harald Koenig <it>&lt;koenig@tat.physik.uni-tuebingen.de&gt;</it>
 <p>
 
@@ -280,7 +281,7 @@
 </itemize>
 
 <verb>
-$XFree86: xc/programs/Xserver/hw/xfree86/doc/sgml/S3V.sgml,v 3.3.2.8 1998/02/27 04:53:51 dawes Exp $
+$XFree86: xc/programs/Xserver/hw/xfree86/doc/sgml/S3V.sgml,v 3.3.2.9 1998/12/04 01:36:48 dawes Exp $
 </verb>
 
 </article>
Index: xc/programs/Xserver/hw/xfree86/doc/sgml/SiS.sgml
diff -u xc/programs/Xserver/hw/xfree86/doc/sgml/SiS.sgml:3.3.2.5 xc/programs/Xserver/hw/xfree86/doc/sgml/SiS.sgml:3.3.2.6
--- xc/programs/Xserver/hw/xfree86/doc/sgml/SiS.sgml:3.3.2.5	Sun Nov  8 21:03:43 1998
+++ xc/programs/Xserver/hw/xfree86/doc/sgml/SiS.sgml	Tue Dec 29 18:54:30 1998
@@ -14,8 +14,9 @@
 
 This driver was primarily written for the SiS86c201.  It also works
 on the 202 , 205 and 5597/5598 chips. Support for 6326 is currently 
-enabled, but tested only on few cards. Also we added for 3.3.3 version
-some support for SiS86c215 and 225. This support consist simply in 
+enabled, but tested only on few cards. 
+Some support for SiS86c215 and 225 was added as well. This support consists
+simply in 
 identify it as 205, so probably 86c215 won't work with acceleration 
 (is a cheap 205 without some features).
 
@@ -172,6 +173,6 @@
 </verb>
 
 <verb>
-$XFree86: xc/programs/Xserver/hw/xfree86/doc/sgml/SiS.sgml,v 3.3.2.5 1998/11/08 10:03:43 hohndel Exp $
+$XFree86: xc/programs/Xserver/hw/xfree86/doc/sgml/SiS.sgml,v 3.3.2.6 1998/12/29 07:54:30 hohndel Exp $
 </verb>
 </article>
Index: xc/programs/Xserver/hw/xfree86/doc/sgml/trident.sgml
diff -u xc/programs/Xserver/hw/xfree86/doc/sgml/trident.sgml:3.22.2.6 xc/programs/Xserver/hw/xfree86/doc/sgml/trident.sgml:3.22.2.8
--- xc/programs/Xserver/hw/xfree86/doc/sgml/trident.sgml:3.22.2.6	Sun Nov  8 00:37:52 1998
+++ xc/programs/Xserver/hw/xfree86/doc/sgml/trident.sgml	Tue Dec 29 23:26:23 1998
@@ -3,7 +3,7 @@
 
 <title> Information for Trident Chipset Users
 <author> The XFree86 Project, Inc.
-<date> 25th October 1998
+<date> December 29 1998
 <toc>
 
 <sect> Supported chipsets <p>
@@ -31,7 +31,10 @@
 no longer specify 'tgui96xx' as the generic keyword, but you actually
 specify your chip. i.e. Chipset 'tgui9685' will set a ProVidia9685 chip.
 <item> The Cyber9388/9397, 3DImage975 and 3DImage985 cards are fixed in
-XFree86 v3.3.3, these chipsets have some acceleration now too.
+XFree86 v3.3.3, these chipsets have some acceleration now too. This
+acceleration has been disabled by default for the Cyber9388/9397
+because there have been problems, but it can be re-enabled with the
+<tt>"accel"</tt> option (see below).
 <item> 24bpp is all drivers remains unaccelerated, this will change in
 a future version, although 32bpp acceleration is supported for all TGUI
 based chipset except the 9440 which doesn't have the capability.
@@ -56,10 +59,14 @@
 	Turn on PCI burst read mode.
 <tag>Option "tgui_pci_write_on"</tag>
 	Turn on PCI burst write mode.
-	NOTE: PCI Burst modes are now OFF by default. The reason for
-	this is the Graphics Accelerator gets upset, but we allow
-	you to turn it back on it may improve performance, or lock up
-	the chip with Timeouts displayed.
+<tag>Option "pci_burst_on"</tag>
+	Turn on PCI burst (read and write)
+<tag>Option "pci_burst_off"</tag>
+	Turn off PCI burst (read and write)
+	<p>NOTE: PCI burst modes are now OFF by default for TGUI9440 cards
+        because it often upsets its Graphics Accelerator.  It can be
+	turned it back on as may improve performance.
+	PCI burst modes are ON by default for all other PCI/AGP cards.
 <tag>ClockChip "tgui"</tag>
 	Turn on programmable clocks.  This is the default for TGUIs.
 <tag>Option "no_program_clocks"</tag>
@@ -68,6 +75,8 @@
 	monitors - not SVGA.
 <tag>Option "noaccel"</tag>
 	Turn off XAA acceleration.
+<tag>Option "accel"</tag>
+	Enable acceleration for the Cyber9388/9397.
 <tag>Option "xaa_no_color_exp"</tag>
 	Disable color expansion.
 <tag>Option "no_stretch"</tag>
@@ -147,7 +156,7 @@
 be worth checking wait states etc. on the card and in the BIOS setup.
 
 <verb>
-$XFree86: xc/programs/Xserver/hw/xfree86/doc/sgml/trident.sgml,v 3.22.2.6 1998/11/07 13:37:52 dawes Exp $
+$XFree86: xc/programs/Xserver/hw/xfree86/doc/sgml/trident.sgml,v 3.22.2.8 1998/12/29 12:26:23 dawes Exp $
 
 
 
Index: xc/programs/Xserver/hw/xfree86/etc/fb.h
diff -u /dev/null xc/programs/Xserver/hw/xfree86/etc/fb.h:1.1.2.1
--- /dev/null	Wed Jan  6 00:31:42 1999
+++ xc/programs/Xserver/hw/xfree86/etc/fb.h	Thu Dec 31 12:38:15 1998
@@ -0,0 +1,487 @@
+/*
+ * This file may be required when building the XF86_FBDev server on Linux
+ * systems that don't have a recent 2.1.x kernel.
+ */
+#ifndef _LINUX_FB_H
+#define _LINUX_FB_H
+
+#include <asm/types.h>
+
+/* Definitions of frame buffers						*/
+
+#define FB_MAJOR	29
+
+#define FB_MODES_SHIFT		5	/* 32 modes per framebuffer */
+#define FB_NUM_MINORS		256	/* 256 Minors               */
+#define FB_MAX			(FB_NUM_MINORS / (1 << FB_MODES_SHIFT))
+#define GET_FB_IDX(node)	(MINOR(node) >> FB_MODES_SHIFT)
+
+/* ioctls
+   0x46 is 'F'								*/
+#define FBIOGET_VSCREENINFO	0x4600
+#define FBIOPUT_VSCREENINFO	0x4601
+#define FBIOGET_FSCREENINFO	0x4602
+#define FBIOGETCMAP		0x4604
+#define FBIOPUTCMAP		0x4605
+#define FBIOPAN_DISPLAY		0x4606
+/* 0x4607-0x460B are defined below */
+/* #define FBIOGET_MONITORSPEC	0x460C */
+/* #define FBIOPUT_MONITORSPEC	0x460D */
+/* #define FBIOSWITCH_MONIBIT	0x460E */
+#define FBIOGET_CON2FBMAP	0x460F
+#define FBIOPUT_CON2FBMAP	0x4610
+
+#define FB_TYPE_PACKED_PIXELS		0	/* Packed Pixels	*/
+#define FB_TYPE_PLANES			1	/* Non interleaved planes */
+#define FB_TYPE_INTERLEAVED_PLANES	2	/* Interleaved planes	*/
+#define FB_TYPE_TEXT			3	/* Text/attributes	*/
+
+#define FB_AUX_TEXT_MDA		0	/* Monochrome text */
+#define FB_AUX_TEXT_CGA		1	/* CGA/EGA/VGA Color text */
+#define FB_AUX_TEXT_S3_MMIO	2	/* S3 MMIO fasttext */
+
+#define FB_VISUAL_MONO01		0	/* Monochr. 1=Black 0=White */
+#define FB_VISUAL_MONO10		1	/* Monochr. 1=White 0=Black */
+#define FB_VISUAL_TRUECOLOR		2	/* True color	*/
+#define FB_VISUAL_PSEUDOCOLOR		3	/* Pseudo color (like atari) */
+#define FB_VISUAL_DIRECTCOLOR		4	/* Direct color */
+#define FB_VISUAL_STATIC_PSEUDOCOLOR	5	/* Pseudo color readonly */
+
+#define FB_ACCEL_NONE		0	/* no hardware accelerator	*/
+#define FB_ACCEL_ATARIBLITT	1	/* Atari Blitter		*/
+#define FB_ACCEL_AMIGABLITT	2	/* Amiga Blitter                */
+#define FB_ACCEL_S3_TRIO64	3	/* Cybervision64 (S3 Trio64)    */
+#define FB_ACCEL_NCR_77C32BLT	4	/* RetinaZ3 (NCR 77C32BLT)      */
+#define FB_ACCEL_S3_VIRGE	5	/* Cybervision64/3D (S3 ViRGE)	*/
+#define FB_ACCEL_ATI_MACH64GX	6	/* ATI Mach 64GX family		*/
+#define FB_ACCEL_DEC_TGA	7	/* DEC 21030 TGA		*/
+#define FB_ACCEL_ATI_MACH64CT	8	/* ATI Mach 64CT family		*/
+#define FB_ACCEL_ATI_MACH64VT	9	/* ATI Mach 64CT family VT class */
+#define FB_ACCEL_ATI_MACH64GT	10	/* ATI Mach 64CT family GT class */
+#define FB_ACCEL_SUN_CREATOR	11	/* Sun Creator/Creator3D	*/
+#define FB_ACCEL_SUN_CGSIX	12	/* Sun cg6			*/
+#define FB_ACCEL_SUN_LEO	13	/* Sun leo/zx			*/
+#define FB_ACCEL_IMS_TWINTURBO	14	/* IMS Twin Turbo		*/
+#define FB_ACCEL_3DLABS_PERMEDIA2 15	/* 3Dlabs Permedia 2		*/
+#define FB_ACCEL_MATROX_MGA2064W 16	/* Matrox MGA2064W (Millenium)	*/
+#define FB_ACCEL_MATROX_MGA1064SG 17	/* Matrox MGA1064SG (Mystique)	*/
+#define FB_ACCEL_MATROX_MGA2164W 18	/* Matrox MGA2164W (Millenium II) */
+#define FB_ACCEL_MATROX_MGA2164W_AGP 19	/* Matrox MGA2164W (Millenium II) */
+#define FB_ACCEL_MATROX_MGAG100	20	/* Matrox G100 (Productiva G100) */
+#define FB_ACCEL_MATROX_MGAG200	21	/* Matrox G200 (Myst, Mill, ...) */
+
+struct fb_fix_screeninfo {
+	char id[16];			/* identification string eg "TT Builtin" */
+	char *smem_start;		/* Start of frame buffer mem */
+					/* (physical address) */
+	__u32 smem_len;			/* Length of frame buffer mem */
+	__u32 type;			/* see FB_TYPE_*		*/
+	__u32 type_aux;			/* Interleave for interleaved Planes */
+	__u32 visual;			/* see FB_VISUAL_*		*/ 
+	__u16 xpanstep;			/* zero if no hardware panning  */
+	__u16 ypanstep;			/* zero if no hardware panning  */
+	__u16 ywrapstep;		/* zero if no hardware ywrap    */
+	__u32 line_length;		/* length of a line in bytes    */
+	char *mmio_start;		/* Start of Memory Mapped I/O   */
+					/* (physical address) */
+	__u32 mmio_len;			/* Length of Memory Mapped I/O  */
+	__u32 accel;			/* Type of acceleration available */
+	__u16 reserved[3];		/* Reserved for future compatibility */
+};
+
+/* Interpretation of offset for color fields: All offsets are from the right,
+ * inside a "pixel" value, which is exactly 'bits_per_pixel' wide (means: you
+ * can use the offset as right argument to <<). A pixel afterwards is a bit
+ * stream and is written to video memory as that unmodified. This implies
+ * big-endian byte order if bits_per_pixel is greater than 8.
+ */
+struct fb_bitfield {
+	__u32 offset;			/* beginning of bitfield	*/
+	__u32 length;			/* length of bitfield		*/
+	__u32 msb_right;		/* != 0 : Most significant bit is */ 
+					/* right */ 
+};
+
+#define FB_NONSTD_HAM		1	/* Hold-And-Modify (HAM)        */
+
+#define FB_ACTIVATE_NOW		0	/* set values immediately (or vbl)*/
+#define FB_ACTIVATE_NXTOPEN	1	/* activate on next open	*/
+#define FB_ACTIVATE_TEST	2	/* don't set, round up impossible */
+#define FB_ACTIVATE_MASK       15
+					/* values			*/
+#define FB_ACTIVATE_VBL	       16	/* activate values on next vbl  */
+#define FB_CHANGE_CMAP_VBL     32	/* change colormap on vbl	*/
+#define FB_ACTIVATE_ALL	       64	/* change all VCs on this fb	*/
+
+#define FB_ACCELF_TEXT		1	/* text mode acceleration */
+
+#define FB_SYNC_HOR_HIGH_ACT	1	/* horizontal sync high active	*/
+#define FB_SYNC_VERT_HIGH_ACT	2	/* vertical sync high active	*/
+#define FB_SYNC_EXT		4	/* external sync		*/
+#define FB_SYNC_COMP_HIGH_ACT	8	/* composite sync high active   */
+#define FB_SYNC_BROADCAST	16	/* broadcast video timings      */
+					/* vtotal = 144d/288n/576i => PAL  */
+					/* vtotal = 121d/242n/484i => NTSC */
+#define FB_SYNC_ON_GREEN	32	/* sync on green */
+
+#define FB_VMODE_NONINTERLACED  0	/* non interlaced */
+#define FB_VMODE_INTERLACED	1	/* interlaced	*/
+#define FB_VMODE_DOUBLE		2	/* double scan */
+#define FB_VMODE_MASK		255
+
+#define FB_VMODE_YWRAP		256	/* ywrap instead of panning     */
+#define FB_VMODE_SMOOTH_XPAN	512	/* smooth xpan possible (internally used) */
+#define FB_VMODE_CONUPDATE	512	/* don't update x/yoffset	*/
+
+struct fb_var_screeninfo {
+	__u32 xres;			/* visible resolution		*/
+	__u32 yres;
+	__u32 xres_virtual;		/* virtual resolution		*/
+	__u32 yres_virtual;
+	__u32 xoffset;			/* offset from virtual to visible */
+	__u32 yoffset;			/* resolution			*/
+
+	__u32 bits_per_pixel;		/* guess what			*/
+	__u32 grayscale;		/* != 0 Graylevels instead of colors */
+
+	struct fb_bitfield red;		/* bitfield in fb mem if true color, */
+	struct fb_bitfield green;	/* else only length is significant */
+	struct fb_bitfield blue;
+	struct fb_bitfield transp;	/* transparency			*/	
+
+	__u32 nonstd;			/* != 0 Non standard pixel format */
+
+	__u32 activate;			/* see FB_ACTIVATE_*		*/
+
+	__u32 height;			/* height of picture in mm    */
+	__u32 width;			/* width of picture in mm     */
+
+	__u32 accel_flags;		/* acceleration flags (hints)	*/
+
+	/* Timing: All values in pixclocks, except pixclock (of course) */
+	__u32 pixclock;			/* pixel clock in ps (pico seconds) */
+	__u32 left_margin;		/* time from sync to picture	*/
+	__u32 right_margin;		/* time from picture to sync	*/
+	__u32 upper_margin;		/* time from sync to picture	*/
+	__u32 lower_margin;
+	__u32 hsync_len;		/* length of horizontal sync	*/
+	__u32 vsync_len;		/* length of vertical sync	*/
+	__u32 sync;			/* see FB_SYNC_*		*/
+	__u32 vmode;			/* see FB_VMODE_*		*/
+	__u32 reserved[6];		/* Reserved for future compatibility */
+};
+
+struct fb_cmap {
+	__u32 start;			/* First entry	*/
+	__u32 len;			/* Number of entries */
+	__u16 *red;			/* Red values	*/
+	__u16 *green;
+	__u16 *blue;
+	__u16 *transp;			/* transparency, can be NULL */
+};
+
+struct fb_con2fbmap {
+	__u32 console;
+	__u32 framebuffer;
+};
+
+struct fb_monspecs {
+	__u32 hfmin;			/* hfreq lower limit (Hz) */
+	__u32 hfmax; 			/* hfreq upper limit (Hz) */
+	__u16 vfmin;			/* vfreq lower limit (Hz) */
+	__u16 vfmax;			/* vfreq upper limit (Hz) */
+	unsigned dpms : 1;		/* supports DPMS */
+};
+
+#ifdef __KERNEL__
+
+#include <linux/fs.h>
+
+
+struct fb_info;
+struct fb_info_gen;
+struct vm_area_struct;
+struct file;
+
+    /*
+     *  Frame buffer operations
+     */
+
+struct fb_ops {
+    /* open/release and usage marking */
+    int (*fb_open)(struct fb_info *info, int user);
+    int (*fb_release)(struct fb_info *info, int user);
+    /* get non settable parameters */
+    int (*fb_get_fix)(struct fb_fix_screeninfo *fix, int con,
+		      struct fb_info *info); 
+    /* get settable parameters */
+    int (*fb_get_var)(struct fb_var_screeninfo *var, int con,
+		      struct fb_info *info);		
+    /* set settable parameters */
+    int (*fb_set_var)(struct fb_var_screeninfo *var, int con,
+		      struct fb_info *info);		
+    /* get colormap */
+    int (*fb_get_cmap)(struct fb_cmap *cmap, int kspc, int con,
+		       struct fb_info *info);
+    /* set colormap */
+    int (*fb_set_cmap)(struct fb_cmap *cmap, int kspc, int con,
+		       struct fb_info *info);
+    /* pan display */
+    int (*fb_pan_display)(struct fb_var_screeninfo *var, int con,
+			  struct fb_info *info);
+    /* perform fb specific ioctl */
+    int (*fb_ioctl)(struct inode *inode, struct file *file, unsigned int cmd,
+		    unsigned long arg, int con, struct fb_info *info);
+    /* perform fb specific mmap */
+    int (*fb_mmap)(struct fb_info *info, struct file *file, struct vm_area_struct *vma);
+};
+
+
+   /*
+    *    This is the interface between the low-level console driver and the
+    *    low-level frame buffer device
+    */
+
+struct display {
+    /* Filled in by the frame buffer device */
+
+    struct fb_var_screeninfo var;   /* variable infos. yoffset and vmode */
+				    /* are updated by fbcon.c */
+    struct fb_cmap cmap;            /* colormap */
+    char *screen_base;              /* pointer to top of virtual screen */    
+				    /* (virtual address) */
+    int visual;
+    int type;                       /* see FB_TYPE_* */
+    int type_aux;                   /* Interleave for interleaved Planes */
+    u_short ypanstep;               /* zero if no hardware ypan */
+    u_short ywrapstep;              /* zero if no hardware ywrap */
+    u_long line_length;             /* length of a line in bytes */
+    u_short can_soft_blank;         /* zero if no hardware blanking */
+    u_short inverse;                /* != 0 text black on white as default */
+    struct display_switch *dispsw;  /* low level operations */
+    void *dispsw_data;		    /* optional dispsw helper data */
+
+#if 0
+    struct fb_fix_cursorinfo fcrsr;
+    struct fb_var_cursorinfo *vcrsr;
+    struct fb_cursorstate crsrstate;
+#endif
+
+    /* Filled in by the low-level console driver */
+
+    struct vc_data *conp;           /* pointer to console data */
+    struct fb_info *fb_info;        /* frame buffer for this console */
+    int vrows;                      /* number of virtual rows */
+    unsigned short cursor_x;	    /* current cursor position */
+    unsigned short cursor_y;
+    int fgcol;                      /* text colors */
+    int bgcol;
+    u_long next_line;               /* offset to one line below */
+    u_long next_plane;              /* offset to next plane */
+    u_char *fontdata;               /* Font associated to this display */
+    unsigned short _fontheightlog;
+    unsigned short _fontwidthlog;
+    unsigned short _fontheight;
+    unsigned short _fontwidth;
+    int userfont;                   /* != 0 if fontdata kmalloc()ed */
+    u_short scrollmode;             /* Scroll Method */
+    short yscroll;                  /* Hardware scrolling */
+    unsigned char fgshift, bgshift;
+    unsigned short charmask;	    /* 0xff or 0x1ff */
+};
+
+
+struct fb_info {
+   char modename[40];			/* default video mode */
+   int node;
+   int flags;
+#define FBINFO_FLAG_MODULE	1	/* Low-level driver is a module */
+   struct fb_ops *fbops;
+   struct fb_monspecs monspecs;
+   struct display *disp;		/* initial display variable */
+   struct vc_data *display_fg;		/* Console visible on this display */
+   char fontname[40];			/* default font name */
+   int (*changevar)(int);		/* tell console var has changed */
+   int (*switch_con)(int, struct fb_info*);
+					/* tell fb to switch consoles */
+   int (*updatevar)(int, struct fb_info*);
+					/* tell fb to update the vars */
+   void (*blank)(int, struct fb_info*);	/* tell fb to (un)blank the screen */
+					/* arg = 0: unblank */
+					/* arg > 0: VESA level (arg-1) */
+
+   /* From here on everything is device dependent */
+};
+
+#ifdef MODULE
+#define FBINFO_FLAG_DEFAULT	FBINFO_FLAG_MODULE
+#else
+#define FBINFO_FLAG_DEFAULT	0
+#endif
+
+    /*
+     *  This structure abstracts from the underlying hardware. It is not
+     *  mandatory but used by the `generic' frame buffer operations.
+     *  Read drivers/video/skeletonfb.c for more information.
+     */
+
+struct fbgen_hwswitch {
+    void (*detect)(void);
+    int (*encode_fix)(struct fb_fix_screeninfo *fix, const void *par,
+		      struct fb_info_gen *info);
+    int (*decode_var)(const struct fb_var_screeninfo *var, void *par,
+		      struct fb_info_gen *info);
+    int (*encode_var)(struct fb_var_screeninfo *var, const void *par,
+		      struct fb_info_gen *info);
+    void (*get_par)(void *par, struct fb_info_gen *info);
+    void (*set_par)(const void *par, struct fb_info_gen *info);
+    int (*getcolreg)(unsigned regno, unsigned *red, unsigned *green,
+		     unsigned *blue, unsigned *transp, struct fb_info *info);
+    int (*setcolreg)(unsigned regno, unsigned red, unsigned green,
+		     unsigned blue, unsigned transp, struct fb_info *info);
+    int (*pan_display)(const struct fb_var_screeninfo *var,
+		       struct fb_info_gen *info);
+    int (*blank)(int blank_mode, struct fb_info_gen *info);
+    void (*set_dispsw)(const void *par, struct display *disp,
+		       struct fb_info_gen *info);
+};
+
+struct fb_info_gen {
+    struct fb_info info;
+
+    /* Entries for a generic frame buffer device */
+    /* Yes, this starts looking like C++ */
+    u_int parsize;
+    struct fbgen_hwswitch *fbhw;
+
+   /* From here on everything is device dependent */
+};
+
+    /*
+     *  `Generic' versions of the frame buffer device operations
+     */
+
+extern int fbgen_get_fix(struct fb_fix_screeninfo *fix, int con,
+			 struct fb_info *info);
+extern int fbgen_get_var(struct fb_var_screeninfo *var, int con,
+			 struct fb_info *info);
+extern int fbgen_set_var(struct fb_var_screeninfo *var, int con,
+			 struct fb_info *info);
+extern int fbgen_get_cmap(struct fb_cmap *cmap, int kspc, int con,
+			  struct fb_info *info);
+extern int fbgen_set_cmap(struct fb_cmap *cmap, int kspc, int con,
+			  struct fb_info *info);
+extern int fbgen_pan_display(struct fb_var_screeninfo *var, int con,
+			     struct fb_info *info);
+extern int fbgen_ioctl(struct inode *inode, struct file *file,
+		       unsigned int cmd, unsigned long arg, int con,
+		       struct fb_info *info);
+
+    /*
+     *  Helper functions
+     */
+
+extern int fbgen_do_set_var(struct fb_var_screeninfo *var, int isactive,
+			    struct fb_info_gen *info);
+extern void fbgen_set_disp(int con, struct fb_info_gen *info);
+extern void fbgen_install_cmap(int con, struct fb_info_gen *info);
+extern int fbgen_update_var(int con, struct fb_info *info);
+extern int fbgen_switch(int con, struct fb_info *info);
+extern void fbgen_blank(int blank, struct fb_info *info);
+
+
+struct fb_videomode {
+    const char *name;
+    struct fb_var_screeninfo var;
+};
+
+
+/* drivers/char/fbmem.c */
+extern int register_framebuffer(struct fb_info *fb_info);
+extern int unregister_framebuffer(const struct fb_info *fb_info);
+extern int fbmon_valid_timings(u_int pixclock, u_int htotal, u_int vtotal,
+			       const struct fb_info *fb_info);
+extern int fbmon_dpms(const struct fb_info *fb_info);
+
+
+extern int num_registered_fb;
+extern struct fb_info *registered_fb[FB_MAX];
+extern char con2fb_map[MAX_NR_CONSOLES];
+
+/* drivers/video/fbcon.c */
+extern struct display fb_display[MAX_NR_CONSOLES];
+
+/* drivers/video/fbcmap.c */
+extern int fb_alloc_cmap(struct fb_cmap *cmap, int len, int transp);
+extern void fb_copy_cmap(struct fb_cmap *from, struct fb_cmap *to,
+			 int fsfromto);
+extern int fb_get_cmap(struct fb_cmap *cmap, int kspc,
+		       int (*getcolreg)(u_int, u_int *, u_int *, u_int *,
+					u_int *, struct fb_info *),
+		       struct fb_info *fb_info);
+extern int fb_set_cmap(struct fb_cmap *cmap, int kspc,
+		       int (*setcolreg)(u_int, u_int, u_int, u_int, u_int,
+					struct fb_info *),
+		       struct fb_info *fb_info);
+extern struct fb_cmap *fb_default_cmap(int len);
+extern void fb_invert_cmaps(void);
+
+/* VESA Blanking Levels */
+#define VESA_NO_BLANKING	0
+#define VESA_VSYNC_SUSPEND	1
+#define VESA_HSYNC_SUSPEND	2
+#define VESA_POWERDOWN		3
+
+#endif /* __KERNEL__ */
+
+#if 1
+
+#define FBCMD_GET_CURRENTPAR	0xDEAD0005
+#define FBCMD_SET_CURRENTPAR	0xDEAD8005
+
+#endif
+
+
+#if 1 /* Preliminary */
+
+   /*
+    *    Hardware Cursor
+    */
+
+#define FBIOGET_FCURSORINFO     0x4607
+#define FBIOGET_VCURSORINFO     0x4608
+#define FBIOPUT_VCURSORINFO     0x4609
+#define FBIOGET_CURSORSTATE     0x460A
+#define FBIOPUT_CURSORSTATE     0x460B
+
+
+struct fb_fix_cursorinfo {
+	__u16 crsr_width;		/* width and height of the cursor in */
+	__u16 crsr_height;		/* pixels (zero if no cursor)	*/
+	__u16 crsr_xsize;		/* cursor size in display pixels */
+	__u16 crsr_ysize;
+	__u16 crsr_color1;		/* colormap entry for cursor color1 */
+	__u16 crsr_color2;		/* colormap entry for cursor color2 */
+};
+
+struct fb_var_cursorinfo {
+	__u16 width;
+	__u16 height;
+	__u16 xspot;
+	__u16 yspot;
+	__u8 data[1];			/* field with [height][width]        */
+};
+
+struct fb_cursorstate {
+	__s16 xoffset;
+	__s16 yoffset;
+	__u16 mode;
+};
+
+#define FB_CURSOR_OFF		0
+#define FB_CURSOR_ON		1
+#define FB_CURSOR_FLASH		2
+
+#endif /* Preliminary */
+
+#endif /* _LINUX_FB_H */
Index: xc/programs/Xserver/hw/xfree86/etc/scanpci.c
diff -u xc/programs/Xserver/hw/xfree86/etc/scanpci.c:3.34.2.17 xc/programs/Xserver/hw/xfree86/etc/scanpci.c:3.34.2.22
--- xc/programs/Xserver/hw/xfree86/etc/scanpci.c:3.34.2.17	Tue Nov 10 22:55:40 1998
+++ xc/programs/Xserver/hw/xfree86/etc/scanpci.c	Tue Dec 29 21:57:46 1998
@@ -9,7 +9,7 @@
  *
  *  supported O/S's:  SVR4, UnixWare, SCO, Solaris,
  *                    FreeBSD, NetBSD, 386BSD, BSDI BSD/386,
- *                    Linux, Mach/386, ISC
+ *                    Linux, Mach/386, ISC, DGUX
  *                    DOS (WATCOM 9.5 compiler)
  *
  *  compiling:        [g]cc scanpci.c -o scanpci
@@ -18,10 +18,11 @@
  *                    for DOS, watcom 9.5:
  *                        wcc386p -zq -omaxet -7 -4s -s -w3 -d2 name.c
  *                        and link with PharLap or other dos extender for exe
+ * case Intel DG/ux:  gcc -DDGUX scanpci.c -o scanpci (with gcc-DG-2.7.2.88)
  *
  */
 
-/* $XFree86: xc/programs/Xserver/hw/xfree86/etc/scanpci.c,v 3.34.2.17 1998/11/10 11:55:40 dawes Exp $ */
+/* $XFree86: xc/programs/Xserver/hw/xfree86/etc/scanpci.c,v 3.34.2.22 1998/12/29 10:57:46 dawes Exp $ */
 
 /*
  * Copyright 1995 by Robin Cutshaw <robin@XFree86.Org>
@@ -47,11 +48,14 @@
  *
  */
 
+#if !defined(DGUX)
 #if defined(__SVR4)
 #if !defined(SVR4)
 #define SVR4
 #endif
 #endif
+#endif
+
 
 #ifdef __EMX__
 #define INCL_DOSFILEMGR
@@ -60,7 +64,7 @@
 
 #include <stdio.h>
 #include <sys/types.h>
-#if defined(SVR4)
+#if defined(SVR4) && !defined(DGUX)
 #if defined(sun)
 #ifndef __EXTENSIONS__
 #define __EXTENSIONS__
@@ -105,6 +109,13 @@
 #define GCCUSESGAS
 #endif
 #endif
+#if defined(DGUX)
+#include <sys/file.h>
+#include <sys/ioctl.h>
+#include <sys/proc.h>
+#include <sys/param.h>
+#include <sys/kd.h>
+#endif
 #if defined(SCO) || defined(ISC)
 #ifndef ISC
 #include <sys/console.h>
@@ -219,12 +230,18 @@
 	}
 #else
 
-#if defined(SVR4)
+#if defined(SVR4) && !defined(DGUX)
 # if !defined(__USLC__)
 #  define __USLC__
 # endif
 #endif
 
+#if defined(DGUX)
+# if !defined(_USL)
+#  define _USL
+# endif
+#endif
+
 #ifndef SCO325
 # include <sys/inline.h>
 #else
@@ -879,6 +896,7 @@
                             { 0x2309, "Imagine-128", print_i128 },
                             { 0x2339, "Imagine-128-II", print_i128 },
                             { 0x493D, "Imagine-128-T2R", print_i128 },
+                            { 0x5348, "Imagine-128-T2R4", print_i128 },
                             { 0x0000, (char *)NULL, NF } } },
         { 0x1060, "UMC", {
                             { 0x0101, "UM8673F", NF },
@@ -897,6 +915,9 @@
         { 0x1066, "PICOP", {
                             { 0x0001, "PT86C52x Vesuvius", NF },
                             { 0x0000, (char *)NULL, NF } } },
+        { 0x1069, "Mylex", {
+                            { 0x0010, "AccelRAID 250", NF },
+                            { 0x0000, (char *)NULL, NF } } },
         { 0x106B, "Apple", {
                             { 0x0001, "Bandit", NF },
                             { 0x0002, "Grand Central", NF },
@@ -1149,9 +1170,10 @@
                             { 0x0484, "82378IB/ZB pci-isa bridge", NF },
                             { 0x0486, "82430ZX Aries", NF },
                             { 0x04A3, "82434LX/NX pci cache mem controller", NF },
+                            { 0x0960, "960RD processor/bridge", NF },
                             { 0x1230, "82371 bus-master IDE controller", NF },
                             { 0x1223, "SAA7116", NF },
-                            { 0x1229, "82557 10/100MBit network controller",NF},
+                            { 0x1229, "82557/8 10/100MBit network controller",NF},
                             { 0x122D, "82437 Triton", NF },
                             { 0x122E, "82471 Triton", NF },
                             { 0x1230, "82438", NF },
@@ -1170,17 +1192,27 @@
 			    { 0x7192, "82443BX Host (no AGP)", NF },
                             { 0x0000, (char *)NULL, NF } } },
         { 0x9004, "Adaptec", {
+                            { 0x0010, "2940U2", NF },
+                            { 0x1078, "7810", NF },
                             { 0x5078, "7850", NF },
                             { 0x5578, "7855", NF },
                             { 0x6078, "7860", NF },
-                            { 0x7078, "294x", NF },
+                            { 0x6178, "2940AU", NF },
+                            { 0x7078, "7870", NF },
                             { 0x7178, "2940", NF },
                             { 0x7278, "7872", NF },
+                            { 0x7378, "398X", NF },
                             { 0x7478, "2944", NF },
-                            { 0x8178, "2940U", NF },
-                            { 0x8278, "3940U", NF },
+                            { 0x7895, "7895", NF },
+                            { 0x8078, "7880", NF },
+                            { 0x8178, "2940U/UW", NF },
+                            { 0x8278, "3940U/UW", NF },
+                            { 0x8378, "389XU", NF },
                             { 0x8478, "2944U", NF },
                             { 0x0000, (char *)NULL, NF } } },
+        { 0x9005, "Adaptec", {
+                            { 0x001F, "7890/7891", NF },
+                            { 0x0000, (char *)NULL, NF } } },
         { 0x907F, "Atronics", {
                             { 0x2015, "IDE-2015PL", NF },
                             { 0x0000, (char *)NULL, NF } } },
@@ -1246,6 +1278,10 @@
     }
 #endif
 
+#if defined(DGUX)
+    printf("Scanpci for Intel ix86 DG/ux R4.20MU03...MUxx\n\n");
+#endif
+
     enable_os_io();
 
 #if !defined(__alpha__) && !defined(__powerpc__)
@@ -1517,32 +1553,32 @@
             if (pcr->_base0)
                 printf("  BASE0     0x%08x  addr 0x%08x  %s\n",
                     pcr->_base0, pcr->_base0 & (pcr->_base0 & 0x1 ?
-		    0xFFFFFFFC : 0xFFFFFFF0), 
+		    0xFFFFFFFC : 0xFFFFFFF0),
 		    pcr->_base0 & 0x1 ? "I/O" : "MEM");
             if (pcr->_base1)
                 printf("  BASE1     0x%08x  addr 0x%08x  %s\n",
                     pcr->_base1, pcr->_base1 & (pcr->_base1 & 0x1 ?
-		    0xFFFFFFFC : 0xFFFFFFF0), 
+		    0xFFFFFFFC : 0xFFFFFFF0),
 		    pcr->_base1 & 0x1 ? "I/O" : "MEM");
             if (pcr->_base2)
                 printf("  BASE2     0x%08x  addr 0x%08x  %s\n",
                     pcr->_base2, pcr->_base2 & (pcr->_base2 & 0x1 ?
-		    0xFFFFFFFC : 0xFFFFFFF0), 
+		    0xFFFFFFFC : 0xFFFFFFF0),
 		    pcr->_base2 & 0x1 ? "I/O" : "MEM");
             if (pcr->_base3)
                 printf("  BASE3     0x%08x  addr 0x%08x  %s\n",
                     pcr->_base3, pcr->_base3 & (pcr->_base3 & 0x1 ?
-		    0xFFFFFFFC : 0xFFFFFFF0), 
+		    0xFFFFFFFC : 0xFFFFFFF0),
 		    pcr->_base3 & 0x1 ? "I/O" : "MEM");
             if (pcr->_base4)
                 printf("  BASE4     0x%08x  addr 0x%08x  %s\n",
                     pcr->_base4, pcr->_base4 & (pcr->_base4 & 0x1 ?
-		    0xFFFFFFFC : 0xFFFFFFF0), 
+		    0xFFFFFFFC : 0xFFFFFFF0),
 		    pcr->_base4 & 0x1 ? "I/O" : "MEM");
             if (pcr->_base5)
                 printf("  BASE5     0x%08x  addr 0x%08x  %s\n",
                     pcr->_base5, pcr->_base5 & (pcr->_base5 & 0x1 ?
-		    0xFFFFFFFC : 0xFFFFFFF0), 
+		    0xFFFFFFFC : 0xFFFFFFF0),
 		    pcr->_base5 & 0x1 ? "I/O" : "MEM");
             if (pcr->_baserom)
                 printf("  BASEROM   0x%08x  addr 0x%08x  %sdecode-enabled\n",
@@ -1550,11 +1586,11 @@
                     pcr->_baserom & 0x1 ? "" : "not-");
             if (pcr->_max_min_ipin_iline)
                 printf("  MAX_LAT   0x%02x  MIN_GNT 0x%02x  INT_PIN 0x%02x  INT_LINE 0x%02x\n",
-                    pcr->_max_lat, pcr->_min_gnt, 
+                    pcr->_max_lat, pcr->_min_gnt,
 		    pcr->_int_pin, pcr->_int_line);
             if (pcr->_user_config)
                 printf("  BYTE_0    0x%02x  BYTE_1  0x%02x  BYTE_2  0x%02x  BYTE_3  0x%02x\n",
-                    pcr->_user_config_0, pcr->_user_config_1, 
+                    pcr->_user_config_0, pcr->_user_config_1,
 		    pcr->_user_config_2, pcr->_user_config_3);
 	}
 }
@@ -1684,7 +1720,7 @@
 void
 enable_os_io()
 {
-#if defined(SVR4) || defined(SCO) || defined(ISC)
+#if (defined(SVR4) || defined(SCO) || defined(ISC)) && !defined(DGUX)
 #if defined(SI86IOPL)
     sysi86(SI86IOPL, 3);
 #else
@@ -1694,12 +1730,12 @@
 #if defined(linux)
     iopl(3);
 #endif
-#if defined(__FreeBSD__)  || defined(__386BSD__) || defined(__bsdi__)
+#if defined(__FreeBSD__)  || defined(__386BSD__) || defined(__bsdi__) || defined(DGUX)
     if ((io_fd = open("/dev/console", O_RDWR, 0)) < 0) {
         perror("/dev/console");
         exit(1);
     }
-#if defined(__FreeBSD__)  || defined(__386BSD__)
+#if defined(__FreeBSD__)  || defined(__386BSD__) || defined(DGUX)
     if (ioctl(io_fd, KDENABIO, 0) < 0) {
         perror("ioctl(KDENABIO)");
         exit(1);
@@ -1769,7 +1805,7 @@
 /* Calling callgate with function 13 sets IOPL for the program */
 
 	asm volatile ("movl $13,%%ebx;.byte 0xff,0x1d;.long _callgate"
-			: /*no outputs */ 
+			: /*no outputs */
 			: /*no inputs */
 			: "eax","ebx","ecx","edx","cc");
 
@@ -1788,7 +1824,7 @@
 void
 disable_os_io()
 {
-#if defined(SVR4) || defined(SCO) || defined(ISC)
+#if (defined(SVR4) || defined(SCO) || defined(ISC)) && !defined(DGUX)
 #if defined(SI86IOPL)
     sysi86(SI86IOPL, 0);
 #else
@@ -1798,10 +1834,10 @@
 #if defined(linux)
     iopl(0);
 #endif
-#if defined(__FreeBSD__)  || defined(__386BSD__)
+#if defined(__FreeBSD__)  || defined(__386BSD__) || defined(DGUX)
     if (ioctl(io_fd, KDDISABIO, 0) < 0) {
         perror("ioctl(KDDISABIO)");
-	close(io_fd);
+        close(io_fd);
         exit(1);
     }
     close(io_fd);
@@ -1811,15 +1847,15 @@
     close(io_fd);
 #else
     if (i386_iopl(0) < 0) {
-	perror("i386_iopl");
-	exit(1);
+        perror("i386_iopl");
+        exit(1);
     }
 #endif /* NetBSD1_1 */
 #endif /* __NetBSD__ */
 #if defined(__bsdi__)
     if (ioctl(io_fd, PCCONDISABIOPL, 0) < 0) {
         perror("ioctl(PCCONDISABIOPL)");
-	close(io_fd);
+        close(io_fd);
         exit(1);
     }
     close(io_fd);
@@ -1833,3 +1869,4 @@
     pciConfBase = NULL;
 #endif
 }
+
Index: xc/programs/Xserver/hw/xfree86/etc/bindist/build-bindist
diff -u xc/programs/Xserver/hw/xfree86/etc/bindist/build-bindist:1.1.2.3 xc/programs/Xserver/hw/xfree86/etc/bindist/build-bindist:1.1.2.4
--- xc/programs/Xserver/hw/xfree86/etc/bindist/build-bindist:1.1.2.3	Sun Jul 27 12:41:18 1997
+++ xc/programs/Xserver/hw/xfree86/etc/bindist/build-bindist	Sun Dec  6 16:40:39 1998
@@ -1,6 +1,6 @@
 #!/bin/sh
 #
-# $XFree86: xc/programs/Xserver/hw/xfree86/etc/bindist/build-bindist,v 1.1.2.3 1997/07/27 02:41:18 dawes Exp $
+# $XFree86: xc/programs/Xserver/hw/xfree86/etc/bindist/build-bindist,v 1.1.2.4 1998/12/06 05:40:39 dawes Exp $
 #
 #
 # This script assumes that you have the `extract' binary installed somewhere
@@ -53,7 +53,7 @@
 LISTFILE=FILES
 
 case `uname` in
-Linux*)
+Linux*|dgux*)
   CKSUM=md5sum
   ;;
 *)
Index: xc/programs/Xserver/hw/xfree86/os-support/Imakefile
diff -u xc/programs/Xserver/hw/xfree86/os-support/Imakefile:3.14.2.2 xc/programs/Xserver/hw/xfree86/os-support/Imakefile:3.14.2.4
--- xc/programs/Xserver/hw/xfree86/os-support/Imakefile:3.14.2.2	Sun May 11 15:04:24 1997
+++ xc/programs/Xserver/hw/xfree86/os-support/Imakefile	Tue Dec 22 22:23:27 1998
@@ -1,4 +1,4 @@
-XCOMM $XFree86: xc/programs/Xserver/hw/xfree86/os-support/Imakefile,v 3.14.2.2 1997/05/11 05:04:24 dawes Exp $
+XCOMM $XFree86: xc/programs/Xserver/hw/xfree86/os-support/Imakefile,v 3.14.2.4 1998/12/22 11:23:27 hohndel Exp $
 
 
 
@@ -25,6 +25,8 @@
 #if defined(SVR4Architecture) 
 # if defined(SunArchitecture)
 OS_SUBDIR = solx86
+# elif defined(DguxArchitecture)
+OS_SUBDIR = dgux
 # else
 OS_SUBDIR = sysv
 # endif
@@ -47,7 +49,11 @@
 #endif
 
 #if defined(i386MachArchitecture) || defined(OsfArchitecture)
+#if defined(GNUMachArchitecture)
+OS_SUBDIR = hurd
+#else
 OS_SUBDIR = mach
+#endif
 #endif
 
 #if defined(AmoebaArchitecture)
Index: xc/programs/Xserver/hw/xfree86/os-support/xf86_OSlib.h
diff -u xc/programs/Xserver/hw/xfree86/os-support/xf86_OSlib.h:3.36.2.6 xc/programs/Xserver/hw/xfree86/os-support/xf86_OSlib.h:3.36.2.8
--- xc/programs/Xserver/hw/xfree86/os-support/xf86_OSlib.h:3.36.2.6	Sun Sep 27 22:58:58 1998
+++ xc/programs/Xserver/hw/xfree86/os-support/xf86_OSlib.h	Tue Dec 22 22:23:27 1998
@@ -1,4 +1,4 @@
-/* $XFree86: xc/programs/Xserver/hw/xfree86/os-support/xf86_OSlib.h,v 3.36.2.6 1998/09/27 12:58:58 hohndel Exp $ */
+/* $XFree86: xc/programs/Xserver/hw/xfree86/os-support/xf86_OSlib.h,v 3.36.2.8 1998/12/22 11:23:27 hohndel Exp $ */
 /*
  * Copyright 1990, 1991 by Thomas Roell, Dinkelscherben, Germany
  * Copyright 1992 by David Dawes <dawes@XFree86.org>
@@ -9,7 +9,8 @@
  * Copyright 1993 by Vrije Universiteit, The Netherlands
  * Copyright 1993 by David Wexelblat <dwex@XFree86.org>
  * Copyright 1994, 1996 by Holger Veit <Holger.Veit@gmd.de>
- * Copyright 1994, 1995 by The XFree86 Project, Inc
+ * Copyright 1997 by Takis Psarogiannakopoulos <takis@dpmms.cam.ac.uk>
+ * Copyright 1994-1998 by The XFree86 Project, Inc
  *
  * Permission to use, copy, modify, distribute, and sell this software and its
  * documentation for any purpose is hereby granted without fee, provided that
@@ -51,7 +52,7 @@
 /**************************************************************************/
 /* SYSV386 (SVR3, SVR4)                                                   */
 /**************************************************************************/
-#if defined(SYSV) || defined(SVR4)
+#if (defined(SYSV) || defined(SVR4)) && !defined(DGUX)
 # ifdef SCO325
 #  define _SVID3
 # endif
@@ -169,7 +170,80 @@
 # define NULL 0
 #endif
 
-#endif /* SYSV || SVR4 */
+#endif /* (SYSV || SVR4) && !DGUX */
+
+
+/**************************************************************************/
+/* DG/ux R4.20MU03 Intel AViion Machines                                  */
+/**************************************************************************/
+#if defined(DGUX) && defined(SVR4)
+#include <sys/ioctl.h>
+#include <signal.h>
+#include <ctype.h>
+#include <termios.h>      /* Use termios for BSD Flavor ttys */
+#include <sys/termios.h>
+#include <sys/stat.h>
+#include <sys/types.h>
+#include <sys/param.h>
+#include <errno.h>
+#include <sys/sysi86.h>
+#include <unistd.h>
+#include <sys/_int_unistd.h>
+#include <sys/proc.h>
+#include <sys/map.h>
+#include <sys/sysmacros.h>
+#include <sys/mman.h>       /* Memory handling */
+#include <sys/kd.h>       /* definitions for KDENABIO KDDISABIO needed for IOPL s */
+#include <sys/kbd.h>
+#include <sys/_int_dg_kbd_ioctl.h>
+#include <fcntl.h>
+#include <time.h>
+#include <sys/stream.h>
+#include <sys/_int_streams_ioctl.h>
+#include <sys/ptms.h>
+
+#include <sys/socket.h>
+#include <sys/utsname.h>
+#include <sys/stropts.h>
+#include <sys/sockio.h>
+
+
+#define POSIX_TTY
+
+#undef HAS_USL_VTS
+#undef USE_VT_SYSREQ
+#undef VT_ACKACQ
+
+#define LED_CAP KBD_LED_CAPS_LOCK
+#define LED_NUM KBD_LED_NUM_LOCK
+#define LED_SCR KBD_LED_SCROLL_LOCK
+
+#define KDGKBTYPE KBD_GET_LANGUAGE
+
+
+/* General keyboard types */
+# define KB_84          2
+# define KB_101         1  /* Because ioctl(dgkeybdFd,KBD_GET_LANGUAGE,&type) gives 1=US keyboard */
+# define KB_OTHER       3
+
+#define KDSETLED KBD_SET_LED
+#define KDGETLED KBD_GET_STATE
+#undef KDMKTONE
+#define KDMKTONE KBD_TONE_HIGH
+
+
+#undef DEV_MEM
+#define DEV_MEM "/dev/mem"
+#define CLEARDTR_SUPPORT
+
+#undef  VT_SYSREQ_DEFAULT
+#define VT_SYSREQ_DEFAULT FALSE        /* Make sure that we dont define any VTs since DG/ux has none */
+
+#ifndef NULL
+# define NULL 0
+#endif
+
+#endif /* DGUX && SVR4 */
 
 /**************************************************************************/
 /* Linux                                                                  */
@@ -473,6 +547,25 @@
 extern char* __XOS2RedirRoot(char*);
 
 #endif
+
+/**************************************************************************/
+/* GNU/Hurd
+/**************************************************************************/
+#if defined(__GNU__)
+
+#include <stdlib.h>
+#include <sys/types.h>
+#include <errno.h>
+#include <signal.h>
+#include <sys/ioctl.h>
+#include <termios.h>
+#include <sys/stat.h>
+
+#define POSIX_TTY
+#include <assert.h>
+#define USE_OSMOUSE
+
+#endif /* __GNU__ */
 
 /**************************************************************************/
 /* Generic                                                                */
Index: xc/programs/Xserver/hw/xfree86/os-support/dgux/Imakefile
diff -u /dev/null xc/programs/Xserver/hw/xfree86/os-support/dgux/Imakefile:1.1.2.1
--- /dev/null	Wed Jan  6 00:32:00 1999
+++ xc/programs/Xserver/hw/xfree86/os-support/dgux/Imakefile	Fri Dec 18 22:56:27 1998
@@ -0,0 +1,23 @@
+XCOMM $XFree86: xc/programs/Xserver/hw/xfree86/os-support/dgux/Imakefile,v 1.1.2.1 1998/12/18 11:56:27 dawes Exp $
+#include <Server.tmpl>
+
+BIOS_MOD = bios_DGmmap
+
+SRCS = dgux_init.c dgux_video.c IO_utils.c dgux_io.c $(BIOS_MOD).c VTsw_noop.c \
+       dgux_kbd.c dgux_kbdEv.c dgux_tty.c std_mouse.c std_mseEv.c
+
+OBJS = dgux_init.o dgux_video.o IO_utils.o dgux_io.o $(BIOS_MOD).o VTsw_noop.o \
+       dgux_kbd.o dgux_kbdEv.o dgux_tty.o std_mouse.o std_mseEv.o 
+
+INCLUDES = -I$(XF86COMSRC) -I$(XF86OSSRC) -I. -I$(SERVERSRC)/include \
+           -I$(XINCLUDESRC) -I$(EXTINCSRC)
+
+SubdirLibraryRule($(OBJS))
+NormalLibraryObjectRule()
+
+ObjectFromSpecialSource(VTsw_noop,../shared/VTsw_noop,/**/)
+ObjectFromSpecialSource(IO_utils,../shared/IO_utils,/**/)
+ObjectFromSpecialSource(std_mouse,../shared/std_mouse,/**/)
+ObjectFromSpecialSource(std_mseEv,../shared/std_mseEv,/**/)
+
+DependTarget()
Index: xc/programs/Xserver/hw/xfree86/os-support/dgux/bios_DGmmap.c
diff -u /dev/null xc/programs/Xserver/hw/xfree86/os-support/dgux/bios_DGmmap.c:1.1.2.1
--- /dev/null	Wed Jan  6 00:32:00 1999
+++ xc/programs/Xserver/hw/xfree86/os-support/dgux/bios_DGmmap.c	Fri Dec 18 22:56:27 1998
@@ -0,0 +1,60 @@
+/* $XFree86: xc/programs/Xserver/hw/xfree86/os-support/dgux/bios_DGmmap.c,v 1.1.2.1 1998/12/18 11:56:27 dawes Exp $ */
+/*
+ * INTEL DG/UX RELEASE 4.20 MU03
+ * Copyright 1997 Takis Psarogiannakopoulos Cambridge,UK
+ * <takis@dpmms.cam.ac.uk>
+ *
+ * Permission to use, copy, modify, distribute, and sell this software and its
+ * documentation for any purpose is hereby granted without fee, provided that
+ * the above copyright notice appear in all copies and that both that
+ * copyright notice and this permission notice appear in supporting
+ * documentation.
+ * XCONSORTIUM DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE.
+ * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ * FITNESS, IN NO EVENT SHALL XCONSORTIUM BE LIABLE FOR
+ * ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER
+ * RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF
+ * CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ *
+ */
+
+#include "X.h"
+#include "input.h"
+#include "scrnintstr.h"
+
+#include "xf86.h"
+#include "xf86Priv.h"
+#include "xf86_OSlib.h"
+
+/*
+ * Read the BIOS via mmap() to the device /dev/mem.
+ */
+int xf86ReadBIOS(Base, Offset, Buf, Len)
+unsigned long Base;
+unsigned long Offset;
+unsigned char *Buf;
+int Len;
+{
+	int fd;
+	unsigned char *ptr;
+
+	if ((fd = open(DEV_MEM, O_RDONLY)) < 0)
+	{
+		ErrorF("xf86ReadBios: Failed to open %s (%s)\n", DEV_MEM,
+		       strerror(errno));
+		return(-1);
+	}
+	ptr = (unsigned char *)mmap((caddr_t)0, 0x8000, PROT_READ, MAP_SHARED,
+				    fd, (off_t)Base);
+	if ((int)ptr == -1)
+	{
+		ErrorF("xf86ReadBios: %s mmap failed\n", DEV_MEM);
+		close(fd);
+		return(-1);
+	}
+	(void)memcpy(Buf, (void *)(ptr + Offset), Len);
+	(void)munmap((caddr_t)ptr, 0x8000);
+	(void)close(fd);
+	return(Len);
+}
Index: xc/programs/Xserver/hw/xfree86/os-support/dgux/dgux_init.c
diff -u /dev/null xc/programs/Xserver/hw/xfree86/os-support/dgux/dgux_init.c:1.1.2.1
--- /dev/null	Wed Jan  6 00:32:00 1999
+++ xc/programs/Xserver/hw/xfree86/os-support/dgux/dgux_init.c	Fri Dec 18 22:56:27 1998
@@ -0,0 +1,180 @@
+/* $XFree86: xc/programs/Xserver/hw/xfree86/os-support/dgux/dgux_init.c,v 1.1.2.1 1998/12/18 11:56:27 dawes Exp $ */
+/*
+ * INTEL DG/UX RELEASE 4.20 MU03
+ * Copyright 1997 Takis Psarogiannakopoulos Cambridge,UK
+ * <takis@dpmms.cam.ac.uk>
+ *
+ * Permission to use, copy, modify, distribute, and sell this software and its
+ * documentation for any purpose is hereby granted without fee, provided that
+ * the above copyright notice appear in all copies and that both that
+ * copyright notice and this permission notice appear in supporting
+ * documentation.
+ * XCONSORTIUM DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE.
+ * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ * FITNESS, IN NO EVENT SHALL XCONSORTIUM BE LIABLE FOR
+ * ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER
+ * RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF
+ * CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ *
+ */
+
+
+#include "X.h"
+#include "Xmd.h"
+#include "input.h"
+#include "scrnintstr.h"
+
+#include "compiler.h"
+
+#include "xf86.h"
+#include "xf86Procs.h"
+#include "xf86_OSlib.h"
+
+static Bool KeepTty = FALSE;
+static Bool Protect0 = FALSE;
+static int VTnum = -1;
+
+extern void xf86VTRequest(
+#if NeedFunctionPrototypes
+	int
+#endif
+);
+
+void xf86OpenConsole()
+{
+    int i;
+    int fd;
+    char vtname[14];
+
+    if (serverGeneration == 1) 
+    {
+    	/* check if we're run with euid==0 */
+    	if (geteuid() != 0)
+	{
+      	    FatalError("xf86OpenConsole: Server must be suid root\n");
+	}
+	if (Protect0)
+	{
+	    int fd = -1;
+
+	    if ((fd = open("/dev/zero", O_RDONLY, 0)) < 0)
+	    {
+		ErrorF("xf86OpenConsole: cannot open /dev/zero (%s)\n",
+		       strerror(errno));
+	    }
+	    else
+	    {
+		if ((int)mmap(0, 0x1000, PROT_NONE,
+			      MAP_FIXED | MAP_SHARED, fd, 0) == -1)
+		{
+		    ErrorF("xf86OpenConsole: failed to protect page 0 (%s)\n",
+		       strerror(errno));
+		}
+		close(fd);
+	    }
+	}
+    	if (VTnum != -1) 
+	{
+      	    xf86Info.vtno = VTnum;
+    	}
+    	else 
+	{
+      	    if ((fd = open("/dev/console",O_WRONLY,0)) < 0) 
+	    {
+        	FatalError(
+		    "xf86OpenConsole: Cannot open system tty (/dev/console), (%s)\n",
+		    strerror(errno));
+	    }
+           close(fd);
+        }
+        xf86Info.vtno=0;
+	ErrorF("   (Intel DG/ux: using VT number: systty%d)\n\n", xf86Info.vtno);
+
+	sprintf(vtname,"/dev/console");
+
+	xf86Config(FALSE); /* Read XF86Config */
+
+	if (!KeepTty)
+    	{
+    	    setpgrp();
+	}
+
+	if ((xf86Info.consoleFd = open("/dev/console", O_RDWR|O_NDELAY, 0)) < 0)
+	{
+            FatalError("xf86OpenConsole: Cannot open %s (%s)\n",
+		       vtname, strerror(errno));
+	}
+
+
+
+        if ((xf86Info.kbdFd = open("/dev/keybd", O_RDONLY|O_NDELAY, 0)) < 0)
+        {
+            FatalError("xf86OpenConsole: Cannot open keyboard (/dev/keybd), (%s)\n", strerror(errno));
+        }
+	/* change ownerships and Grab all other system consoles  */
+	chown(vtname, getuid(), getgid());
+        chown("/dev/syscon", getuid(), getgid());
+        chown("/dev/systty", getuid(), getgid());
+        if (!KeepTty)
+        {
+            /*
+             * Detach from the controlling tty to avoid char loss
+             */
+            if ((i = open("/dev/tty",O_RDWR)) >= 0)
+            {
+                ioctl(i, TIOCNOTTY, 0);
+                close(i);
+            }
+        }
+    }
+    else 
+    {   
+	/* serverGeneration != 1 */
+	if (!xf86VTSema)
+	    sleep(5);
+    }
+    return;
+}
+
+void xf86CloseConsole()
+{
+    close(xf86Info.kbdFd);      /* Close the keyboard */
+    close(xf86Info.consoleFd);      /* Close the system console */
+    return;
+}
+
+int xf86ProcessArgument(argc, argv, i)
+int argc;
+char *argv[];
+int i;
+{
+	if (!strcmp(argv[i], "-keeptty"))
+	{
+		KeepTty = TRUE;
+		return(1);
+	}
+	if (!strcmp(argv[i], "-protect0"))
+	{
+		Protect0 = TRUE;
+		return(1);
+	}
+	if ((argv[i][0] == 'v') && (argv[i][1] == 't'))
+	{
+		if (sscanf(argv[i], "vt%2d", &VTnum) == 0)
+		{
+			UseMsg();
+			VTnum = -1;
+			return(0);
+		}
+		return(1);
+	}
+	return(0);
+}
+
+void xf86UseMsg()
+{
+	ErrorF("-keeptty               ");
+	ErrorF("don't detach controlling tty (for debugging only)\n");
+	return;
+}
Index: xc/programs/Xserver/hw/xfree86/os-support/dgux/dgux_io.c
diff -u /dev/null xc/programs/Xserver/hw/xfree86/os-support/dgux/dgux_io.c:1.1.2.1
--- /dev/null	Wed Jan  6 00:32:01 1999
+++ xc/programs/Xserver/hw/xfree86/os-support/dgux/dgux_io.c	Fri Dec 18 22:56:28 1998
@@ -0,0 +1,84 @@
+/* $XFree86: xc/programs/Xserver/hw/xfree86/os-support/dgux/dgux_io.c,v 1.1.2.1 1998/12/18 11:56:28 dawes Exp $ */
+/*
+ * INTEL DG/UX RELEASE 4.20 MU03
+ * Copyright 1997 Takis Psarogiannakopoulos Cambridge,UK
+ * <takis@dpmms.cam.ac.uk>
+ *
+ * Permission to use, copy, modify, distribute, and sell this software and its
+ * documentation for any purpose is hereby granted without fee, provided that
+ * the above copyright notice appear in all copies and that both that
+ * copyright notice and this permission notice appear in supporting
+ * documentation.
+ * XCONSORTIUM DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE.
+ * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ * FITNESS, IN NO EVENT SHALL XCONSORTIUM BE LIABLE FOR
+ * ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER
+ * RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF
+ * CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ *
+ */
+
+#define NEED_EVENTS
+#include "X.h"
+#include "Xproto.h"
+#include "inputstr.h"
+#include "scrnintstr.h"
+
+#include "compiler.h"
+
+#include "xf86Procs.h"
+#include "xf86_OSlib.h"
+
+
+
+void xf86SoundKbdBell(loudness, pitch, duration)
+int loudness;
+int pitch;
+int duration;
+{
+	if (loudness && pitch)
+	{
+
+		/*
+		 * We use KBD_TONE_HIGH to avoid putting the server
+		 * to sleep
+		 */
+		ioctl(xf86Info.kbdFd, KBD_TONE_HIGH,
+		      ((1193190 / pitch) & 0xffff) |
+		      (((unsigned long)duration *
+			loudness / 50) << 16));
+
+	}
+}
+
+
+
+void xf86MouseInit(mouse)
+MouseDevPtr mouse;
+{
+	return;
+}
+
+
+
+/* Added for DG/ux: only RDONLY will not crash the Xserver */
+int xf86MouseOn(mouse)
+MouseDevPtr mouse;
+{
+	if ((mouse->mseFd = open(mouse->mseDevice, O_RDONLY|O_NDELAY)) < 0)
+	{
+		if (xf86AllowMouseOpenFail) {
+			ErrorF("Cannot open mouse (%s) - Continuing...\n",
+				strerror(errno));
+			return(-2);
+		}
+		FatalError("Cannot open mouse (%s)\n", strerror(errno));
+	}
+
+	xf86SetupMouse(mouse);
+
+	/* Flush any pending input */
+	ioctl(mouse->mseFd, TCFLSH, 0);
+	return(mouse->mseFd);
+}
Index: xc/programs/Xserver/hw/xfree86/os-support/dgux/dgux_kbd.c
diff -u /dev/null xc/programs/Xserver/hw/xfree86/os-support/dgux/dgux_kbd.c:1.1.2.1
--- /dev/null	Wed Jan  6 00:32:01 1999
+++ xc/programs/Xserver/hw/xfree86/os-support/dgux/dgux_kbd.c	Fri Dec 18 22:56:28 1998
@@ -0,0 +1,121 @@
+/* $XFree86: xc/programs/Xserver/hw/xfree86/os-support/dgux/dgux_kbd.c,v 1.1.2.1 1998/12/18 11:56:28 dawes Exp $ */
+/*
+ * INTEL DG/UX RELEASE 4.20 MU03
+ * Copyright 1997 Takis Psarogiannakopoulos Cambridge,UK
+ * <takis@dpmms.cam.ac.uk>
+ *
+ * Permission to use, copy, modify, distribute, and sell this software and its
+ * documentation for any purpose is hereby granted without fee, provided that
+ * the above copyright notice appear in all copies and that both that
+ * copyright notice and this permission notice appear in supporting
+ * documentation.
+ * XCONSORTIUM DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE.
+ * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ * FITNESS, IN NO EVENT SHALL XCONSORTIUM BE LIABLE FOR
+ * ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER
+ * RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF
+ * CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ *
+ */
+
+/* *Contents*
+
+  1  xf86KbdSetLeds    
+  2  xf86KbdGetLeds  
+  3  xf86SetKbdRepeat
+  4  xf86KbdInit()
+  5  xf86KbdOn()
+  6  xf86KbdOff()
+
+*/
+
+
+#define NEED_EVENTS
+#include "X.h"
+#include "Xproto.h"
+#include "inputstr.h"
+#include "scrnintstr.h"
+
+#include "compiler.h"
+
+#include "xf86Procs.h"
+#include "xf86_OSlib.h"
+
+
+static struct termios kbdtty;
+
+
+/* ADDED FOR  INTEL DGUX */
+void xf86SetKbdLeds(leds)
+int leds;
+{
+        ioctl(xf86Info.kbdFd, KBD_SET_LED, leds);
+}
+
+
+
+/* ADDED FOR  INTEL DGUX */
+int xf86GetKbdLeds()
+{
+        int leds;
+
+        ioctl(xf86Info.kbdFd, KBD_GET_STATE, &leds);
+        return(leds);
+}
+
+/* ADDED FOR INTEL DGUX */
+#if NeedFunctionPrototypes
+void xf86SetKbdRepeat(char rad)
+#else
+void xf86SetKbdRepeat(rad)
+char rad;
+#endif
+{
+        return;
+}
+
+
+
+
+/* ADDED FOR INTEL DGUX */
+
+void xf86KbdInit()
+{
+        tcgetattr(xf86Info.kbdFd, &kbdtty);
+}
+
+
+
+
+
+/* ADDED FOR INTEL DGUX */
+
+int xf86KbdOn()
+{
+        struct termios nTty;
+
+        nTty = kbdtty;
+        nTty.c_iflag = IGNPAR | IGNBRK;
+        nTty.c_oflag = 0;
+        nTty.c_cflag = CREAD | CS8;
+        nTty.c_lflag = 0;
+        nTty.c_cc[VTIME] = 0;
+        nTty.c_cc[VMIN] = 1;
+        cfsetispeed(&nTty, 9600);
+        cfsetospeed(&nTty, 9600);
+        tcsetattr(xf86Info.kbdFd, TCSANOW, &nTty);
+        return(xf86Info.kbdFd);
+}
+
+
+
+
+
+/* Intel DG/ux */
+int xf86KbdOff()
+{
+        tcsetattr(xf86Info.kbdFd, TCSANOW, &kbdtty);
+        return(xf86Info.kbdFd);
+}
+
Index: xc/programs/Xserver/hw/xfree86/os-support/dgux/dgux_kbdEv.c
diff -u /dev/null xc/programs/Xserver/hw/xfree86/os-support/dgux/dgux_kbdEv.c:1.1.2.1
--- /dev/null	Wed Jan  6 00:32:01 1999
+++ xc/programs/Xserver/hw/xfree86/os-support/dgux/dgux_kbdEv.c	Fri Dec 18 22:56:28 1998
@@ -0,0 +1,43 @@
+/* $XFree86: xc/programs/Xserver/hw/xfree86/os-support/dgux/dgux_kbdEv.c,v 1.1.2.1 1998/12/18 11:56:28 dawes Exp $ */
+/*
+ * INTEL DG/UX RELEASE 4.20 MU02
+ * Copyright 1997 Takis Psarogiannakopoulos Cambridge,UK
+ * <takis@dpmms.cam.ac.uk>
+ *
+ * Permission to use, copy, modify, distribute, and sell this software and its
+ * documentation for any purpose is hereby granted without fee, provided that
+ * the above copyright notice appear in all copies and that both that
+ * copyright notice and this permission notice appear in supporting
+ * documentation.
+ * XCONSORTIUM DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE.
+ * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ * FITNESS, IN NO EVENT SHALL XCONSORTIUM BE LIABLE FOR
+ * ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER
+ * RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF
+ * CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ *
+ */
+
+
+#define NEED_EVENTS
+#include "X.h"
+#include "Xproto.h"
+#include "inputstr.h"
+#include "scrnintstr.h"
+
+#include "xf86Procs.h"
+#include "xf86_OSlib.h"
+
+void xf86KbdEvents()
+{
+	unsigned char rBuf[64];
+	int nBytes, i;
+
+	if ((nBytes = read( xf86Info.kbdFd, (char *)rBuf, sizeof(rBuf))) > 0)
+	{
+		for (i = 0; i < nBytes; i++)
+			xf86PostKbdEvent(rBuf[i]);
+	}
+}
+
Index: xc/programs/Xserver/hw/xfree86/os-support/dgux/dgux_tty.c
diff -u /dev/null xc/programs/Xserver/hw/xfree86/os-support/dgux/dgux_tty.c:1.1.2.1
--- /dev/null	Wed Jan  6 00:32:01 1999
+++ xc/programs/Xserver/hw/xfree86/os-support/dgux/dgux_tty.c	Fri Dec 18 22:56:29 1998
@@ -0,0 +1,171 @@
+/* $XFree86: xc/programs/Xserver/hw/xfree86/os-support/dgux/dgux_tty.c,v 1.1.2.1 1998/12/18 11:56:29 dawes Exp $ */
+/*
+ * INTEL DG/UX RELEASE 4.20 MU03
+ * Copyright 1997 Takis Psarogiannakopoulos Cambridge,UK
+ * <takis@dpmms.cam.ac.uk>
+ *
+ * Permission to use, copy, modify, distribute, and sell this software and its
+ * documentation for any purpose is hereby granted without fee, provided that
+ * the above copyright notice appear in all copies and that both that
+ * copyright notice and this permission notice appear in supporting
+ * documentation.
+ * XCONSORTIUM DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE.
+ * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ * FITNESS, IN NO EVENT SHALL XCONSORTIUM BE LIABLE FOR
+ * ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER
+ * RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF
+ * CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ *
+ */
+/* BSD (POSIX) Flavor tty for ix86 DG/ux R4.20MU03 */
+
+#define NEED_EVENTS
+#include "X.h"
+#include "Xproto.h"
+#include "inputstr.h"
+#include "scrnintstr.h"
+
+#include "xf86Procs.h"
+#include "xf86_OSlib.h"
+#include "xf86_Config.h"
+
+static Bool not_a_tty = FALSE;
+
+void xf86SetMouseSpeed(mouse, old, new, cflag)
+MouseDevPtr mouse;
+int old;
+int new;
+unsigned cflag;
+{
+	struct termios tty;
+	char *c;
+
+	if (not_a_tty)
+		return;
+
+	if (tcgetattr(mouse->mseFd, &tty) < 0)
+	{
+		not_a_tty = TRUE;
+		ErrorF("Warning: %s unable to get status of mouse fd (%s)\n",
+		       mouse->mseDevice, strerror(errno));
+		return;
+	}
+
+	/* this will query the initial baudrate only once */
+	if (mouse->oldBaudRate < 0) { 
+	   switch (cfgetispeed(&tty)) 
+	      {
+	      case B9600: 
+		 mouse->oldBaudRate = 9600;
+		 break;
+	      case B4800: 
+		 mouse->oldBaudRate = 4800;
+		 break;
+	      case B2400: 
+		 mouse->oldBaudRate = 2400;
+		 break;
+	      case B1200: 
+	      default:
+		 mouse->oldBaudRate = 1200;
+		 break;
+	      }
+	}
+
+	tty.c_iflag = IGNBRK | IGNPAR;
+	tty.c_oflag = 0;
+	tty.c_lflag = 0;
+	tty.c_cflag = (tcflag_t)cflag;
+	tty.c_cc[VTIME] = 0;
+	tty.c_cc[VMIN] = 1;
+
+	switch (old)
+	{
+	case 9600:
+		cfsetispeed(&tty, B9600);
+		cfsetospeed(&tty, B9600);
+		break;
+	case 4800:
+		cfsetispeed(&tty, B4800);
+		cfsetospeed(&tty, B4800);
+		break;
+	case 2400:
+		cfsetispeed(&tty, B2400);
+		cfsetospeed(&tty, B2400);
+		break;
+	case 1200:
+	default:
+		cfsetispeed(&tty, B1200);
+		cfsetospeed(&tty, B1200);
+	}
+
+	if (tcsetattr(mouse->mseFd, TCSADRAIN, &tty) < 0)
+	{
+		if (xf86AllowMouseOpenFail) {
+			ErrorF("Unable to set status of mouse fd (%s) - Continuing...\n",
+			       strerror(errno));
+			return;
+		}
+		xf86FatalError("Unable to set status of mouse fd (%s)\n",
+			       strerror(errno));
+	}
+
+	switch (new)
+	{
+	case 9600:
+		c = "*q";
+		cfsetispeed(&tty, B9600);
+		cfsetospeed(&tty, B9600);
+		break;
+	case 4800:
+		c = "*p";
+		cfsetispeed(&tty, B4800);
+		cfsetospeed(&tty, B4800);
+		break;
+	case 2400:
+		c = "*o";
+		cfsetispeed(&tty, B2400);
+		cfsetospeed(&tty, B2400);
+		break;
+	case 1200:
+	default:
+		c = "*n";
+		cfsetispeed(&tty, B1200);
+		cfsetospeed(&tty, B1200);
+	}
+
+	if (mouse->mseType == P_LOGIMAN || mouse->mseType == P_LOGI)
+	{
+		if (write(mouse->mseFd, c, 2) != 2)
+		{
+			if (xf86AllowMouseOpenFail) {
+				ErrorF("Unable to write to mouse fd (%s) - Continuing...\n",
+				       strerror(errno));
+				return;
+			}
+			xf86FatalError("Unable to write to mouse fd (%s)\n",
+				       strerror(errno));
+		}
+	}
+	usleep(100000);
+
+	if (tcsetattr(mouse->mseFd, TCSADRAIN, &tty) < 0)
+	{
+		if (xf86AllowMouseOpenFail) {
+			ErrorF("Unable to set status of mouse fd (%s) - Continuing...\n",
+			       strerror(errno));
+			return;
+		}
+		xf86FatalError("Unable to set status of mouse fd (%s)\n",
+			       strerror(errno));
+	}
+}
+
+/* ADDED FOR X 3.3.2.3 */
+int
+xf86FlushInput(fd)
+int fd;
+{
+        return tcflush(fd, TCIFLUSH);
+}
+
Index: xc/programs/Xserver/hw/xfree86/os-support/dgux/dgux_video.c
diff -u /dev/null xc/programs/Xserver/hw/xfree86/os-support/dgux/dgux_video.c:1.1.2.1
--- /dev/null	Wed Jan  6 00:32:02 1999
+++ xc/programs/Xserver/hw/xfree86/os-support/dgux/dgux_video.c	Fri Dec 18 22:56:29 1998
@@ -0,0 +1,537 @@
+/* $XFree86: xc/programs/Xserver/hw/xfree86/os-support/dgux/dgux_video.c,v 1.1.2.1 1998/12/18 11:56:29 dawes Exp $ */
+/*
+ * INTEL DG/UX RELEASE 4.20 MU03
+ * Copyright 1997 Takis Psarogiannakopoulos Cambridge,UK
+ * <takis@dpmms.cam.ac.uk>
+ *
+ *
+ * Permission to use, copy, modify, distribute, and sell this software and its
+ * documentation for any purpose is hereby granted without fee, provided that
+ * the above copyright notice appear in all copies and that both that
+ * copyright notice and this permission notice appear in supporting
+ * documentation.
+ * XFREE86 PROJECT DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE.
+ * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ * FITNESS, IN NO EVENT SHALL XCONSORTIUM BE LIABLE FOR
+ * ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER
+ * RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF
+ * CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ *
+ */
+
+#include "X.h"
+#include "input.h"
+#include "scrnintstr.h"
+
+#include "xf86.h"
+#include "xf86Priv.h"
+#include "xf86_OSlib.h"
+
+/* Stuff for the SET_IOPL() ,RESET_IOPL() */
+/* #include <fcntl.h> */
+static int io_takis;
+int set_takis;
+
+
+/***************************************************************************/
+/* SET_IOPL() and RESET_IOPL() section for ix86 DG/ux 4.20MU03             */
+/***************************************************************************/
+
+
+int SET_IOPL()
+{
+    io_takis=open("/dev/console", O_RDWR,0);
+    if ((io_takis) < 0)
+    {
+        return(-1);
+    }
+    set_takis = ioctl(io_takis,KDENABIO,0);
+
+    if (set_takis < 0)
+    {
+        return(-1);
+    }
+    return(1);
+}
+
+
+
+
+void RESET_IOPL()
+{
+
+    ioctl(io_takis,KDDISABIO,0);
+    close(io_takis);
+    return;
+
+}
+
+/***************************************************************************/
+/* DG/ux Video Memory Mapping part                                         */
+/***************************************************************************/
+
+#undef HAS_SVR3_MMAPDRV /* ix86 DG/ux is a typical SVR4 without SVR3_MMAPDRV */
+
+Bool xf86LinearVidMem()
+{
+   return(TRUE);
+}
+
+
+
+pointer AllocAddress[MAXSCREENS][NUM_REGIONS];
+#ifndef SVR4
+static int mmapFd = -2;
+#endif
+
+
+
+#if 0
+/* For DGA support */
+static struct xf86memMap {
+  int offset;
+  int memSize;
+} xf86memMaps[MAXSCREENS];
+#endif
+
+
+
+pointer xf86MapVidMem(ScreenNum, Region, Base, Size)
+int ScreenNum;
+int Region;
+pointer Base;
+unsigned long Size;
+{
+        pointer base;
+        int fd;
+
+#if defined(DGUX)
+        if ((fd = open(DEV_MEM, O_RDWR)) < 0)
+        {
+                FatalError("xf86MapVidMem: failed to open %s (%s)\n",
+                           DEV_MEM, strerror(errno));
+        }
+        base = (pointer)mmap((caddr_t)0, Size, PROT_READ|PROT_WRITE,
+                             MAP_SHARED, fd, (off_t)Base);
+        close(fd);
+        if ((long)base == -1)
+        {
+                FatalError("%s: Could not mmap framebuffer [s=%x,a=%x] (%s)\n",
+                           "xf86MapVidMem", Size, Base, strerror(errno));
+        }
+#else /* HAS SVR#_MMAPDRV */
+#ifdef HAS_SVR3_MMAPDRV
+        if (mmapFd == -2)
+        {
+                mmapFd = open("/dev/mmap", O_RDWR);
+        }
+#endif
+        if (mmapFd >= 0)
+        {
+                /* To force the MMAP driver to provide the address */
+                base = (pointer)0;
+        }
+        else
+        {
+            AllocAddress[ScreenNum][Region] = (pointer)xalloc(Size + 0x1000);
+            if (AllocAddress[ScreenNum][Region] == (pointer)0)
+            {
+                FatalError("xf86MapVidMem: can't alloc framebuffer space\n");
+                /* NOTREACHED */
+            }
+            base = (pointer)(((unsigned int)AllocAddress[ScreenNum][Region]
+                              & ~0xFFF) + 0x1000);
+        }
+
+
+#ifdef HAS_SVR3_MMAPDRV
+        if(mmapFd >= 0)
+        {
+            if((base = (pointer)ioctl(mmapFd, MAP,
+                           &(MapDSC[ScreenNum][Region]))) == (pointer)-1)
+            {
+                FatalError("%s: Could not mmap framebuffer [s=%x,a=%x] (%s)\n",
+                           "xf86MapVidMem", Size, Base, strerror(errno));
+                /* NOTREACHED */
+            }
+
+#if 0
+/* inserted for DGA support */
+            xf86memMaps[ScreenNum].offset = (int) Base;
+            xf86memMaps[ScreenNum].memSize = Size;
+#endif
+            return((pointer)base);
+        }
+#endif
+#endif /* DGUX */
+#if 0
+        xf86memMaps[ScreenNum].offset = (int) Base;
+        xf86memMaps[ScreenNum].memSize = Size;
+#endif
+        return((pointer)base);
+}
+
+
+
+
+
+
+#if 0
+void xf86GetVidMemData(ScreenNum, Base, Size)
+int ScreenNum;
+int *Base;
+int *Size;
+{
+   *Base = xf86memMaps[ScreenNum].offset;
+   *Size = xf86memMaps[ScreenNum].memSize;
+}
+#endif
+
+
+
+
+void xf86UnMapVidMem(ScreenNum, Region, Base, Size)
+int ScreenNum;
+int Region;
+pointer Base;
+unsigned long Size;
+{
+	munmap(Base, Size);
+}
+
+
+
+
+
+/* NULL for DG/ux  */
+void xf86MapDisplay(ScreenNum, Region)
+int ScreenNum;
+int Region;
+{
+	return;
+}
+
+
+
+
+/* NULL for DG/ux */
+void xf86UnMapDisplay(ScreenNum, Region)
+int ScreenNum;
+int Region;
+{
+	return;
+}
+
+/***************************************************************************/
+/* I/O Permissions section                                                 */
+/***************************************************************************/
+
+#define ALWAYS_USE_EXTENDED
+#ifdef ALWAYS_USE_EXTENDED
+
+static Bool ScreenEnabled[MAXSCREENS];
+static Bool ExtendedEnabled = FALSE;
+static Bool InitDone = FALSE;
+
+void
+xf86ClearIOPortList(ScreenNum)
+int ScreenNum;
+{
+	if (!InitDone)
+	{
+		int i;
+		for (i = 0; i < MAXSCREENS; i++)
+			ScreenEnabled[i] = FALSE;
+		InitDone = TRUE;
+	}
+	return;
+}
+
+void
+xf86AddIOPorts(ScreenNum, NumPorts, Ports)
+int ScreenNum;
+int NumPorts;
+unsigned *Ports;
+{
+	return;
+}
+
+void
+xf86EnableIOPorts(ScreenNum)
+int ScreenNum;
+{
+	int i;
+
+	ScreenEnabled[ScreenNum] = TRUE;
+
+	if (ExtendedEnabled)
+		return;
+
+	if (SET_IOPL() < 0)
+	{
+		FatalError("%s: Failed to set IOPL for extended I/O\n",
+			   "xf86EnableIOPorts");
+	}
+	ExtendedEnabled = TRUE;
+
+	return;
+}
+	
+void
+xf86DisableIOPorts(ScreenNum)
+int ScreenNum;
+{
+	int i;
+
+	ScreenEnabled[ScreenNum] = FALSE;
+
+	if (!ExtendedEnabled)
+		return;
+
+	for (i = 0; i < MAXSCREENS; i++)
+		if (ScreenEnabled[i])
+			return;
+
+	RESET_IOPL();
+	ExtendedEnabled = FALSE;
+
+	return;
+}
+
+#else /* !ALWAYS_USE_EXTENDED */
+
+#define DISABLED	0
+#define NON_EXTENDED	1
+#define EXTENDED	2
+
+static unsigned *EnabledPorts[MAXSCREENS];
+static int NumEnabledPorts[MAXSCREENS];
+static Bool ScreenEnabled[MAXSCREENS];
+static Bool ExtendedPorts[MAXSCREENS];
+static Bool ExtendedEnabled = FALSE;
+static Bool InitDone = FALSE;
+static struct kd_disparam OrigParams;
+
+void xf86ClearIOPortList(ScreenNum)
+int ScreenNum;
+{
+	if (!InitDone)
+	{
+		xf86InitPortLists(EnabledPorts, NumEnabledPorts, ScreenEnabled,
+				  ExtendedPorts, MAXSCREENS);
+		if (ioctl(xf86Info.consoleFd, KDDISPTYPE, &OrigParams) < 0)
+		{
+			FatalError("%s: Could not get display parameters\n",
+				   "xf86ClearIOPortList");
+		}
+		InitDone = TRUE;
+		return;
+	}
+	ExtendedPorts[ScreenNum] = FALSE;
+	if (EnabledPorts[ScreenNum] != (unsigned *)NULL)
+		xfree(EnabledPorts[ScreenNum]);
+	EnabledPorts[ScreenNum] = (unsigned *)NULL;
+	NumEnabledPorts[ScreenNum] = 0;
+}
+
+void xf86AddIOPorts(ScreenNum, NumPorts, Ports)
+int ScreenNum;
+int NumPorts;
+unsigned *Ports;
+{
+	int i;
+
+	if (!InitDone)
+	{
+	    FatalError("xf86AddIOPorts: I/O control lists not initialised\n");
+	}
+	EnabledPorts[ScreenNum] = (unsigned *)xrealloc(EnabledPorts[ScreenNum], 
+			(NumEnabledPorts[ScreenNum]+NumPorts)*sizeof(unsigned));
+	for (i = 0; i < NumPorts; i++)
+	{
+		EnabledPorts[ScreenNum][NumEnabledPorts[ScreenNum] + i] =
+								Ports[i];
+		if (Ports[i] > 0x3FF)
+			ExtendedPorts[ScreenNum] = TRUE;
+	}
+	NumEnabledPorts[ScreenNum] += NumPorts;
+}
+
+void xf86EnableIOPorts(ScreenNum)
+int ScreenNum;
+{
+	struct kd_disparam param;
+	int i, j;
+
+	if (ScreenEnabled[ScreenNum])
+		return;
+
+	for (i = 0; i < MAXSCREENS; i++)
+	{
+		if (ExtendedPorts[i] && (ScreenEnabled[i] || i == ScreenNum))
+		{
+		    if (SET_IOPL() < 0)
+		    {
+			FatalError("%s: Failed to set IOPL for extended I/O\n",
+				   "xf86EnableIOPorts");
+		    }
+		    ExtendedEnabled = TRUE;
+		    break;
+		}
+	}
+	if (ExtendedEnabled && i == MAXSCREENS)
+	{
+		RESET_IOPL();
+		ExtendedEnabled = FALSE;
+	}
+	if (ioctl(xf86Info.consoleFd, KDDISPTYPE, &param) < 0)
+	{
+		FatalError("%s: Could not get display parameters\n",
+			   "xf86EnableIOPorts");
+	}
+	for (i = 0; i < NumEnabledPorts[ScreenNum]; i++)
+	{
+		unsigned port = EnabledPorts[ScreenNum][i];
+
+		if (port > 0x3FF)
+			continue;
+
+		if (!xf86CheckPorts(port, EnabledPorts, NumEnabledPorts,
+				    ScreenEnabled, MAXSCREENS))
+		{
+			continue;
+		}
+		for (j=0; j < MKDIOADDR; j++)
+		{
+			if (param.ioaddr[j] == port)
+			{
+				break;
+			}
+		}
+		if (j == MKDIOADDR)
+		{
+			if (ioctl(xf86Info.consoleFd, KDADDIO, port) < 0)
+			{
+				FatalError("%s: Failed to enable port 0x%x\n",
+					   "xf86EnableIOPorts", port);
+			}
+		}
+	}
+	if (ioctl(xf86Info.consoleFd, KDENABIO, 0) < 0)
+	{
+		FatalError("xf86EnableIOPorts: I/O port enable failed (%s)\n",
+			   strerror(errno));
+	}
+	ScreenEnabled[ScreenNum] = TRUE;
+	return;
+}
+
+void xf86DisableIOPorts(ScreenNum)
+int ScreenNum;
+{
+	struct kd_disparam param;
+	int i, j;
+
+	if (!ScreenEnabled[ScreenNum])
+		return;
+
+	ScreenEnabled[ScreenNum] = FALSE;
+	for (i = 0; i < MAXSCREENS; i++)
+	{
+		if (ScreenEnabled[i] && ExtendedPorts[i])
+			break;
+	}
+	if (ExtendedEnabled && i == MAXSCREENS)
+	{
+		RESET_IOPL();
+		ExtendedEnabled = FALSE;
+	}
+	/* Turn off I/O before changing the access list */
+	ioctl(xf86Info.consoleFd, KDDISABIO, 0);
+	if (ioctl(xf86Info.consoleFd, KDDISPTYPE, &param) < 0)
+	{
+		ErrorF("%s: Could not get display parameters\n",
+		       "xf86DisableIOPorts");
+		return;
+	}
+
+	for (i=0; i < MKDIOADDR; i++)
+	{
+		if (param.ioaddr[i] == 0)
+		{
+			break;
+		}
+		if (!xf86CheckPorts(param.ioaddr[i], EnabledPorts,
+				    NumEnabledPorts, ScreenEnabled, MAXSCREENS))
+		{
+			continue;
+		}
+		for (j=0; j < MKDIOADDR; j++)
+		{
+			if (param.ioaddr[i] == OrigParams.ioaddr[j])
+			{
+				/*
+				 * Port was one of the original ones; don't
+				 * touch it.
+				 */
+				break;
+			}
+		}
+		if (j == MKDIOADDR)
+		{
+			/*
+			 * We added this port, so remove it.
+			 */
+			ioctl(xf86Info.consoleFd, KDDELIO, param.ioaddr[i]);
+		}
+	}
+	for (i = 0; i < MAXSCREENS; i++)
+	{
+		if (ScreenEnabled[i])
+		{
+			ioctl(xf86Info.consoleFd, KDENABIO, 0);
+			break;
+		}
+	}
+	return;
+}
+#endif
+
+void xf86DisableIOPrivs()
+{
+	if (ExtendedEnabled)
+		RESET_IOPL();
+	return;
+}
+
+/***************************************************************************/
+/* Interrupt Handling section                                              */
+/***************************************************************************/
+
+
+Bool xf86DisableInterrupts()
+{
+
+#ifdef __GNUC__
+        __asm__ __volatile__("cli");
+#else
+        asm("cli");
+#endif /* __GNUC__ */
+
+        return(TRUE);
+}
+
+void xf86EnableInterrupts()
+{
+
+#ifdef __GNUC__
+        __asm__ __volatile__("sti");
+#else
+        asm("sti");
+#endif /* __GNUC__ */
+
+        return;
+}
+
+
Index: xc/programs/Xserver/hw/xfree86/os-support/hurd/Imakefile
diff -u /dev/null xc/programs/Xserver/hw/xfree86/os-support/hurd/Imakefile:1.2.2.2
--- /dev/null	Wed Jan  6 00:32:02 1999
+++ xc/programs/Xserver/hw/xfree86/os-support/hurd/Imakefile	Tue Dec 22 23:27:33 1998
@@ -0,0 +1,28 @@
+XCOMM
+XCOMM $XFree86: xc/programs/Xserver/hw/xfree86/os-support/hurd/Imakefile,v 1.2.2.2 1998/12/22 12:27:33 hohndel Exp $
+XCOMM
+
+#include <Server.tmpl>
+
+BIOS_MOD = bios_mmap
+
+SRCS = hurd_init.c hurd_video.c hurd_io.c $(BIOS_MOD).c mapVT_noop.c std_mseEv.c std_kbdEv.c\
+       VTsw_noop.c posix_tty.c
+
+OBJS = hurd_init.o hurd_video.o hurd_io.o $(BIOS_MOD).o mapVT_noop.o std_mseEv.o std_kbdEv.o\
+       VTsw_noop.o posix_tty.o
+
+INCLUDES = -I$(XF86COMSRC) -I$(XF86OSSRC) -I. -I$(SERVERSRC)/include \
+           -I$(XINCLUDESRC)
+
+SubdirLibraryRule($(OBJS))
+NormalLibraryObjectRule()
+
+ObjectFromSpecialSource(std_kbdEv,../shared/std_kbdEv,/**/)
+ObjectFromSpecialSource(std_mseEv,../shared/std_mseEv,/**/)
+ObjectFromSpecialSource(mapVT_noop,../shared/mapVT_noop,/**/)
+ObjectFromSpecialSource(VTsw_noop,../shared/VTsw_noop,/**/)
+ObjectFromSpecialSource(posix_tty,../shared/posix_tty,/**/)
+
+DependTarget()
+
Index: xc/programs/Xserver/hw/xfree86/os-support/hurd/bios_mmap.c
diff -u /dev/null xc/programs/Xserver/hw/xfree86/os-support/hurd/bios_mmap.c:1.1.2.2
--- /dev/null	Wed Jan  6 00:32:03 1999
+++ xc/programs/Xserver/hw/xfree86/os-support/hurd/bios_mmap.c	Tue Dec 22 23:27:33 1998
@@ -0,0 +1,92 @@
+/*
+ * $XFree86: xc/programs/Xserver/hw/xfree86/os-support/hurd/bios_mmap.c,v 1.1.2.2 1998/12/22 12:27:33 hohndel Exp $
+ *
+ * Copyright 1997 by UCHIYAMA Yasushi
+ *
+ * Permission to use, copy, modify, distribute, and sell this software and its
+ * documentation for any purpose is hereby granted without fee, provided that
+ * the above copyright notice appear in all copies and that both that
+ * copyright notice and this permission notice appear in supporting
+ * documentation, and that the name of UCHIYAMA Yasushi not be used in
+ * advertising or publicity pertaining to distribution of the software without
+ * specific, written prior permission.  UCHIYAMA Yasushi makes no representations
+ * about the suitability of this software for any purpose.  It is provided
+ * "as is" without express or implied warranty.
+ *
+ * UCHIYAMA YASUSHI DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
+ * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
+ * EVENT SHALL UCHIYAMA YASUSHI BE LIABLE FOR ANY SPECIAL, INDIRECT OR
+ * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
+ * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
+ * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
+ * PERFORMANCE OF THIS SOFTWARE.
+ *
+ */
+#include<mach.h>
+#include<device/device.h>
+
+#include "X.h"
+#include "misc.h"
+
+#include "xf86.h"
+#include "xf86_OSlib.h"
+
+#define BIOS_SIZE 0x20000
+
+int 
+xf86ReadBIOS(unsigned long Base,unsigned long Offset,unsigned char *Buf,int Len)
+{
+    mach_port_t device,iopl_dev;
+    memory_object_t iopl_mem;
+    vm_address_t addr = (vm_address_t)0; /* serach starting address */
+    kern_return_t err;
+
+
+    err = get_privileged_ports (NULL, &device);
+    if( err )
+    {
+	errno = err;
+	FatalError("xf86ReadBIOS() can't get_privileged_ports. (%s)\n",strerror(errno));
+    }
+    err = device_open(device,D_READ|D_WRITE,"iopl",&iopl_dev);
+    mach_port_deallocate (mach_task_self (), device);
+    if( err )
+    {
+	errno = err;
+	FatalError("xf86ReadBIOS() can't device_open. (%s)\n",strerror(errno));
+    }
+    err = device_map(iopl_dev,VM_PROT_READ|VM_PROT_WRITE, Base , BIOS_SIZE ,&iopl_mem,0);
+    if( err )
+    {
+	errno = err;
+	FatalError("xf86ReadBIOS() can't device_map. (%s)\n",strerror(errno));
+    }
+    err = vm_map(mach_task_self(),
+		 &addr,
+		 BIOS_SIZE,
+		 0,
+		 TRUE,
+		 iopl_mem,
+		 Base,
+		 FALSE,
+		 VM_PROT_READ|VM_PROT_WRITE,
+		 VM_PROT_READ|VM_PROT_WRITE,
+		 VM_INHERIT_SHARE);
+    mach_port_deallocate(mach_task_self(),iopl_mem);
+    if( err )
+    {
+	errno = err;
+	FatalError("xf86ReadBIOS() can't vm_map. (%s)\n",strerror(errno));
+    }
+
+    memcpy(Buf,(void*)((int)addr + Offset), Len);
+    
+    err = vm_deallocate(mach_task_self(), addr, BIOS_SIZE);
+    if( err )
+    {
+	errno = err;
+	FatalError("xf86ReadBIOS() can't vm_deallocate. (%s)\n",strerror(errno));
+    }
+    
+    return Len;
+}
Index: xc/programs/Xserver/hw/xfree86/os-support/hurd/hurd_init.c
diff -u /dev/null xc/programs/Xserver/hw/xfree86/os-support/hurd/hurd_init.c:1.1.2.2
--- /dev/null	Wed Jan  6 00:32:03 1999
+++ xc/programs/Xserver/hw/xfree86/os-support/hurd/hurd_init.c	Tue Dec 22 23:27:33 1998
@@ -0,0 +1,85 @@
+/*
+ * $XFree86: xc/programs/Xserver/hw/xfree86/os-support/hurd/hurd_init.c,v 1.1.2.2 1998/12/22 12:27:33 hohndel Exp $
+ *
+ * Copyright 1997,1998 by UCHIYAMA Yasushi
+ *
+ * Permission to use, copy, modify, distribute, and sell this software and its
+ * documentation for any purpose is hereby granted without fee, provided that
+ * the above copyright notice appear in all copies and that both that
+ * copyright notice and this permission notice appear in supporting
+ * documentation, and that the name of UCHIYAMA Yasushi not be used in
+ * advertising or publicity pertaining to distribution of the software without
+ * specific, written prior permission.  UCHIYAMA Yasushi makes no representations
+ * about the suitability of this software for any purpose.  It is provided
+ * "as is" without express or implied warranty.
+ *
+ * UCHIYAMA YASUSHI DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
+ * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
+ * EVENT SHALL UCHIYAMA YASUSHI BE LIABLE FOR ANY SPECIAL, INDIRECT OR
+ * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
+ * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
+ * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
+ * PERFORMANCE OF THIS SOFTWARE.
+ *
+ */
+#include "X.h"
+
+#include "input.h"
+#include "scrnintstr.h"
+
+#include "compiler.h"
+
+#include "xf86.h"
+#include "xf86Procs.h"
+
+#include <stdio.h>
+#include <errno.h>
+#include <sys/time.h>
+#include <sys/file.h>
+#include <assert.h>
+#include <mach.h>
+
+int 
+xf86ProcessArgument( int argc,char **argv, int i )
+{
+    return 0;
+}
+void 
+xf86UseMsg()
+{
+    return;
+}
+
+void 
+xf86OpenConsole()
+{
+    if( serverGeneration == 1 )
+    {
+	kern_return_t err;
+	mach_port_t device;
+	int fd;
+	err = get_privileged_ports( NULL, &device );
+	if( err )
+	{
+	    errno = err;
+	    FatalError( "xf86KbdInit can't get_privileged_ports. (%s)\n" , strerror(errno) );
+	}
+	mach_port_deallocate (mach_task_self (), device);
+	
+	if( ( fd = open( "/dev/kbd" , O_RDONLY|O_NONBLOCK ) ) < 0 )
+	{
+	    fprintf( stderr , "Cannot open keyboard (%s)\n",strerror(errno) );
+	    exit(1);
+	}
+	xf86Info.consoleFd = fd;
+	xf86Config(FALSE); /* Read XF86Config */
+    }
+    return;
+}
+
+void 
+xf86CloseConsole()
+{
+    close( xf86Info.consoleFd );
+    return;
+}
Index: xc/programs/Xserver/hw/xfree86/os-support/hurd/hurd_io.c
diff -u /dev/null xc/programs/Xserver/hw/xfree86/os-support/hurd/hurd_io.c:1.1.2.2
--- /dev/null	Wed Jan  6 00:32:03 1999
+++ xc/programs/Xserver/hw/xfree86/os-support/hurd/hurd_io.c	Tue Dec 22 23:27:34 1998
@@ -0,0 +1,290 @@
+/*
+ * $XFree86: xc/programs/Xserver/hw/xfree86/os-support/hurd/hurd_io.c,v 1.1.2.2 1998/12/22 12:27:34 hohndel Exp $
+ *
+ * Copyright 1997,1998 by UCHIYAMA Yasushi
+ *
+ * Permission to use, copy, modify, distribute, and sell this software and its
+ * documentation for any purpose is hereby granted without fee, provided that
+ * the above copyright notice appear in all copies and that both that
+ * copyright notice and this permission notice appear in supporting
+ * documentation, and that the name of UCHIYAMA Yasushi not be used in
+ * advertising or publicity pertaining to distribution of the software without
+ * specific, written prior permission.  UCHIYAMA Yasushi makes no representations
+ * about the suitability of this software for any purpose.  It is provided
+ * "as is" without express or implied warranty.
+ *
+ * UCHIYAMA YASUSHI DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
+ * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
+ * EVENT SHALL UCHIYAMA YASUSHI BE LIABLE FOR ANY SPECIAL, INDIRECT OR
+ * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
+ * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
+ * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
+ * PERFORMANCE OF THIS SOFTWARE.
+ *
+ */
+#define NEED_EVENTS
+#include "X.h"
+#include "Xproto.h"
+#include "inputstr.h"
+#include "scrnintstr.h"
+
+#include "compiler.h"
+
+#include "xf86.h"
+#include "xf86Procs.h"
+#include "xf86_OSlib.h"
+
+#include "xf86_Config.h"
+
+#include <stdio.h>
+#include <errno.h>
+#include <sys/time.h>
+#include <sys/file.h>
+#include <assert.h>
+#include <mach.h>
+#include <sys/ioctl.h>
+
+typedef unsigned short kev_type;		/* kd event type */
+typedef unsigned char Scancode;
+
+struct mouse_motion {		
+    short mm_deltaX;		/* units? */
+    short mm_deltaY;
+};
+
+typedef struct {
+    kev_type type;			/* see below */
+    struct timeval time;		/* timestamp */
+    union {				/* value associated with event */
+	boolean_t up;		/* MOUSE_LEFT .. MOUSE_RIGHT */
+	Scancode sc;		/* KEYBD_EVENT */
+	struct mouse_motion mmotion;	/* MOUSE_MOTION */
+    } value;
+} kd_event;
+
+/* 
+ * kd_event ID's.
+ */
+#define MOUSE_LEFT	1		/* mouse left button up/down */
+#define MOUSE_MIDDLE	2
+#define MOUSE_RIGHT	3
+#define MOUSE_MOTION	4		/* mouse motion */
+#define KEYBD_EVENT	5		/* key up/down */
+
+/*
+ *	Handle any XF86Config options for "OsMouse", How you treat errors
+ *	is up to you, they may or may not be Fatal
+ */
+void
+xf86OsMouseOption(
+    int		lt,	/* type returned by gettoken */
+    pointer	lp	/* The lexical return symbol */
+    )
+{
+}
+/*
+ * xf86OsMouseProc --
+ *      Handle the initialization, etc. of a mouse
+ */
+int
+xf86OsMouseProc( DeviceIntPtr pPointer , int what )
+{
+    extern int miPointerGetMotionEvents(DeviceIntPtr pPtr, xTimecoord *coords,
+					unsigned long start, unsigned long stop,
+					ScreenPtr pScreen);
+    unsigned char map[MSE_MAXBUTTONS + 1];
+    int nbuttons;
+    int mousefd;
+
+    switch( what )
+    {
+    case DEVICE_INIT: 
+	pPointer->public.on = FALSE;
+
+	for (nbuttons = 0; nbuttons < MSE_MAXBUTTONS; ++nbuttons)
+	    map[nbuttons + 1] = nbuttons + 1;
+
+	InitPointerDeviceStruct((DevicePtr)pPointer, 
+				map, 
+				min(xf86Info.mouseDev->buttons, MSE_MAXBUTTONS),
+				miPointerGetMotionEvents, 
+				(PtrCtrlProcPtr)xf86MseCtrl, 
+				0);
+#ifdef XINPUT
+	InitValuatorAxisStruct(pPointer,
+			       0,
+			       0, /* min val */
+			       screenInfo.screens[0]->width, /* max val */
+			       1, /* resolution */
+			       0, /* min_res */
+			       1); /* max_res */
+	InitValuatorAxisStruct(pPointer,
+			       1,
+			       0, /* min val */
+			       screenInfo.screens[0]->height, /* max val */
+			       1, /* resolution */
+			       0, /* min_res */
+			       1); /* max_res */
+	/* Initialize valuator values in synch
+	 * with dix/event.c DefineInitialRootWindow
+	 */
+	*pPointer->valuator->axisVal = screenInfo.screens[0]->width / 2;
+	*(pPointer->valuator->axisVal+1) = screenInfo.screens[0]->height / 2;
+#endif
+	break;
+    case DEVICE_ON:
+	if ( (xf86Info.mouseDev->mseFd = open(xf86Info.mouseDev->mseDevice,O_RDONLY|O_NONBLOCK) ) == -1 )
+	    return !Success;
+	AddEnabledDevice( xf86Info.mouseDev->mseFd );
+	xf86Info.mouseDev->lastButtons = 0;
+	xf86Info.mouseDev->emulateState = 0;
+	pPointer->public.on = TRUE;
+	break;
+    case DEVICE_OFF:
+    case DEVICE_CLOSE:
+	if( close( xf86Info.mouseDev->mseFd ) != -1 )
+	    RemoveEnabledDevice(mousefd);
+	pPointer->public.on = FALSE;
+	usleep(300000);
+	break;
+    }
+    return Success;
+}
+/*
+ * xf86OsMouseEvents --
+ *      Get some events from our queue.  Process all outstanding events now.
+ */
+void
+xf86OsMouseEvents()
+{
+    static kd_event eventList[64];
+    int n; 
+    kd_event *event = eventList;
+
+    if( (n =  read( xf86Info.mouseDev->mseFd , eventList, sizeof eventList )) <= 0 )
+	return;
+    n /= sizeof( kd_event );
+    while( n-- )
+    {
+	int buttons = xf86Info.mouseDev->lastButtons;
+	int dx =0, dy = 0;
+	switch( event->type )
+	{
+	case MOUSE_RIGHT:
+	    buttons  = buttons & 6 |(event->value.up ? 0 : 1);
+	    break;
+	case MOUSE_MIDDLE:
+	    buttons  = buttons & 5 |(event->value.up ? 0 : 2);
+	    break;
+	case MOUSE_LEFT:
+	    buttons  = buttons & 3 |(event->value.up ? 0 : 4) ;
+	    break;
+	case MOUSE_MOTION:
+	    dx = event->value.mmotion.mm_deltaX;
+	    dy = - event->value.mmotion.mm_deltaY;
+	    break;
+	default:
+	    ErrorF("Bad mouse event (%d)\n",event->type);
+	    continue;
+	}
+	xf86PostMseEvent(xf86Info.pMouse,buttons, dx, dy );
+	++event;
+    }
+    return;
+}
+
+void 
+xf86MouseInit( MouseDevPtr mouse )
+{
+}
+int 
+xf86MouseOn( MouseDevPtr mouse)
+{
+    if ((mouse->mseFd = open(mouse->mseDevice, O_RDWR | O_NONBLOCK)) < 0)
+    {
+	if (xf86AllowMouseOpenFail) {
+	    ErrorF("Cannot open mouse (%s) - Continuing...\n",
+		   strerror(errno));
+	    return(-2);
+	}
+	FatalError("Cannot open mouse (%s)\n", strerror(errno));
+    }
+
+    xf86SetupMouse(mouse);
+
+    /* Flush any pending input */
+    tcflush(mouse->mseFd, TCIFLUSH);
+
+    return mouse->mseFd;
+}
+int 
+xf86MouseOff( MouseDevPtr mouse,Bool doclose )
+{
+    int oldfd;
+
+    if ((oldfd = mouse->mseFd) >= 0)
+    {
+	if (mouse->mseType == P_LOGI)
+	{
+	    write(mouse->mseFd, "U", 1);
+	}
+	if (mouse->oldBaudRate > 0) {
+	    xf86SetMouseSpeed(mouse,
+			      mouse->baudRate,
+			      mouse->oldBaudRate,
+			      xf86MouseCflags[mouse->mseType]);
+	}
+	close(mouse->mseFd);
+	oldfd = mouse->mseFd;
+	mouse->mseFd = -1;
+    }
+    return oldfd;
+}
+
+/***********************************************************************
+ * Keyboard
+ **********************************************************************/
+void 
+xf86SoundKbdBell(int loudness,int pitch,int duration)
+{
+    return;
+}
+
+void 
+xf86SetKbdLeds(int leds)
+{
+    return;
+}
+
+int 
+xf86GetKbdLeds()
+{
+    return 0;
+}
+
+void 
+xf86SetKbdRepeat(char rad)
+{
+    return;
+}
+
+void 
+xf86KbdInit()
+{
+    return;
+}
+int
+xf86KbdOn()
+{
+    int data = 1;
+    if( ioctl( xf86Info.consoleFd, _IOW('k', 1, int),&data) < 0)
+	FatalError("Cannot set event mode on keyboard (%s)\n",strerror(errno));
+    return xf86Info.consoleFd;
+}
+int
+xf86KbdOff()
+{
+    int data = 2;
+    if( ioctl( xf86Info.consoleFd, _IOW('k', 1, int),&data) < 0)
+	FatalError("can't reset keyboard mode (%s)\n",strerror(errno));
+}
Index: xc/programs/Xserver/hw/xfree86/os-support/hurd/hurd_video.c
diff -u /dev/null xc/programs/Xserver/hw/xfree86/os-support/hurd/hurd_video.c:1.1.2.2
--- /dev/null	Wed Jan  6 00:32:03 1999
+++ xc/programs/Xserver/hw/xfree86/os-support/hurd/hurd_video.c	Tue Dec 22 23:27:34 1998
@@ -0,0 +1,153 @@
+/*
+ * $XFree86: xc/programs/Xserver/hw/xfree86/os-support/hurd/hurd_video.c,v 1.1.2.2 1998/12/22 12:27:34 hohndel Exp $
+ *
+ * Copyright 1997, 1998 by UCHIYAMA Yasushi
+ *
+ * Permission to use, copy, modify, distribute, and sell this software and its
+ * documentation for any purpose is hereby granted without fee, provided that
+ * the above copyright notice appear in all copies and that both that
+ * copyright notice and this permission notice appear in supporting
+ * documentation, and that the name of UCHIYAMA Yasushi not be used in
+ * advertising or publicity pertaining to distribution of the software without
+ * specific, written prior permission.  UCHIYAMA Yasushi makes no representations
+ * about the suitability of this software for any purpose.  It is provided
+ * "as is" without express or implied warranty.
+ *
+ * UCHIYAMA YASUSHI DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
+ * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
+ * EVENT SHALL UCHIYAMA YASUSHI BE LIABLE FOR ANY SPECIAL, INDIRECT OR
+ * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
+ * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
+ * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
+ * PERFORMANCE OF THIS SOFTWARE.
+ *
+ */
+#include <mach.h>
+#include <device/device.h>
+
+#include "X.h"
+#include "input.h"
+#include "scrnintstr.h"
+
+#include "xf86.h"
+#include "xf86Priv.h"
+#include "xf86_OSlib.h"
+
+/**************************************************************************
+ * Video Memory Mapping section                                            
+ ***************************************************************************/
+pointer 
+xf86MapVidMem(int ScreenNum,int Region,pointer Base,unsigned long Size)
+{
+    mach_port_t device,iopl_dev;
+    memory_object_t iopl_mem;
+    kern_return_t err;
+    vm_address_t addr=(vm_address_t)0;
+
+    err = get_privileged_ports (NULL, &device);
+    if( err )
+    {
+	errno = err;
+	FatalError("xf86MapVidMem() can't get_privileged_ports. (%s)\n",strerror(errno));
+    }
+    err = device_open(device,D_READ|D_WRITE,"iopl",&iopl_dev);
+    mach_port_deallocate (mach_task_self(), device);
+    if( err )
+    {
+	errno = err;
+	FatalError("xf86MapVidMem() can't device_open. (%s)\n",strerror(errno));
+    }
+
+    err = device_map(iopl_dev,VM_PROT_READ|VM_PROT_WRITE, (int)Base , Size ,&iopl_mem,0);
+    if( err )
+    {
+	errno = err;
+	FatalError("xf86MapVidMem() can't device_map. (%s)\n",strerror(errno));
+    }
+    err = vm_map(mach_task_self(),
+		 &addr,
+		 Size,
+		 0,     /* mask */
+		 TRUE,  /* anywhere */
+		 iopl_mem,
+		 (vm_offset_t)Base,
+		 FALSE, /* copy on write */
+		 VM_PROT_READ|VM_PROT_WRITE,
+		 VM_PROT_READ|VM_PROT_WRITE,
+		 VM_INHERIT_SHARE);
+    mach_port_deallocate(mach_task_self(),iopl_mem);
+    if( err )
+    {
+	errno = err;
+	FatalError("xf86MapVidMem() can't vm_map.(iopl_mem) (%s)\n",strerror(errno));
+    }
+    mach_port_deallocate(mach_task_self(),iopl_dev);
+    if( err )
+    {
+	errno = err;
+	FatalError("xf86MapVidMem() can't mach_port_deallocate.(iopl_dev) (%s)\n",strerror(errno));
+    }
+    return (pointer)addr;
+}
+
+void 
+xf86UnMapVidMem(int ScreenNum,int Region,pointer Base,unsigned long Size)
+{
+    kern_return_t err = vm_deallocate(mach_task_self(), (int)Base, Size);
+    if( err )
+    {
+	errno = err;
+	ErrorF("xf86UnMapVidMem: can't dealloc framebuffer space (%s)\n",strerror(errno));
+    }
+    return;
+}
+
+Bool 
+xf86LinearVidMem()
+{
+    return(TRUE);
+}
+
+/**************************************************************************
+ * I/O Permissions section                                                 
+ ***************************************************************************/
+void 
+xf86ClearIOPortList(int ScreenNum)
+{
+    return;
+}
+void 
+xf86AddIOPorts(int ScreenNum,int NumPorts,unsigned int *Ports)
+{
+    return;
+}
+void 
+xf86EnableIOPorts(int ScreenNum)
+{
+    return;
+}
+
+void 
+xf86DisableIOPorts(int ScreenNum)
+{
+    return;
+}
+void 
+xf86DisableIOPrivs()
+{
+    return;
+}
+/**************************************************************************
+ * Interrupt Handling section                                              
+ **************************************************************************/
+Bool 
+xf86DisableInterrupts()
+{
+    return TRUE;
+}
+void 
+xf86EnableInterrupts()
+{
+    return;
+}
+
Index: xc/programs/Xserver/hw/xfree86/os-support/sco/sco_mouse.c
diff -u xc/programs/Xserver/hw/xfree86/os-support/sco/sco_mouse.c:3.8 xc/programs/Xserver/hw/xfree86/os-support/sco/sco_mouse.c:3.8.2.1
--- xc/programs/Xserver/hw/xfree86/os-support/sco/sco_mouse.c:3.8	Mon Dec 23 17:50:50 1996
+++ xc/programs/Xserver/hw/xfree86/os-support/sco/sco_mouse.c	Sun Dec  6 16:40:40 1998
@@ -1,4 +1,4 @@
-/* $XFree86: xc/programs/Xserver/hw/xfree86/os-support/sco/sco_mouse.c,v 3.8 1996/12/23 06:50:50 dawes Exp $ */
+/* $XFree86: xc/programs/Xserver/hw/xfree86/os-support/sco/sco_mouse.c,v 3.8.2.1 1998/12/06 05:40:40 dawes Exp $ */
 
 
 
@@ -116,6 +116,27 @@
 			      miPointerGetMotionEvents, 
 			      (PtrCtrlProcPtr)xf86MseCtrl, 
 			      0);
+#ifdef XINPUT
+      InitValuatorAxisStruct(pPointer,
+			     0,
+			     0, /* min val */
+			     screenInfo.screens[0]->width, /* max val */
+			     1, /* resolution */
+			     0, /* min_res */
+			     1); /* max_res */
+      InitValuatorAxisStruct(pPointer,
+			     1,
+			     0, /* min val */
+			     screenInfo.screens[0]->height, /* max val */
+			     1, /* resolution */
+			     0, /* min_res */
+			     1); /* max_res */
+      /* Initialize valuator values in synch
+       * with dix/event.c DefineInitialRootWindow
+       */
+      *pPointer->valuator->axisVal = screenInfo.screens[0]->width / 2;
+      *(pPointer->valuator->axisVal+1) = screenInfo.screens[0]->height / 2;
+#endif
       xfree(map);
       ev_suspend(); /* suspend device until its turned on */
       break;
Index: xc/programs/Xserver/hw/xfree86/vga256/drivers/chips/ct_BltHiQV.h
diff -u xc/programs/Xserver/hw/xfree86/vga256/drivers/chips/ct_BltHiQV.h:3.4.2.1 xc/programs/Xserver/hw/xfree86/vga256/drivers/chips/ct_BltHiQV.h:3.4.2.2
--- xc/programs/Xserver/hw/xfree86/vga256/drivers/chips/ct_BltHiQV.h:3.4.2.1	Sat May  3 19:47:58 1997
+++ xc/programs/Xserver/hw/xfree86/vga256/drivers/chips/ct_BltHiQV.h	Sun Dec  6 16:40:40 1998
@@ -4,7 +4,7 @@
 
 
 
-/* $XFree86: xc/programs/Xserver/hw/xfree86/vga256/drivers/chips/ct_BltHiQV.h,v 3.4.2.1 1997/05/03 09:47:58 dawes Exp $ */
+/* $XFree86: xc/programs/Xserver/hw/xfree86/vga256/drivers/chips/ct_BltHiQV.h,v 3.4.2.2 1998/12/06 05:40:40 dawes Exp $ */
 
 /* Definitions for the Chips and Technology BitBLT engine communication. */
 /* These are done using Memory Mapped IO, of the registers */
@@ -107,7 +107,7 @@
       ((Width)&0xFFFF)
 
 #define ctSETPATSRCADDR(srcAddr)\
-  *(unsigned int *)(ctMMIOBase + BR(0x5)) = (srcAddr)&0x1FFFFFL
+  *(unsigned int *)(ctMMIOBase + BR(0x5)) = (srcAddr)&0x7FFFFFL
 
 #define ctSETBGCOLOR8(bgColor)\
   *(unsigned int *)(ctMMIOBase + BR(0x1)) = ((bgColor)&0xFF)
Index: xc/programs/Xserver/hw/xfree86/vga256/drivers/cyrix/cyrix.h
diff -u xc/programs/Xserver/hw/xfree86/vga256/drivers/cyrix/cyrix.h:1.1.2.5 xc/programs/Xserver/hw/xfree86/vga256/drivers/cyrix/cyrix.h:1.1.2.6
--- xc/programs/Xserver/hw/xfree86/vga256/drivers/cyrix/cyrix.h:1.1.2.5	Fri Nov  6 20:47:02 1998
+++ xc/programs/Xserver/hw/xfree86/vga256/drivers/cyrix/cyrix.h	Tue Dec 22 18:49:58 1998
@@ -1,5 +1,5 @@
 
-/* $XFree86: xc/programs/Xserver/hw/xfree86/vga256/drivers/cyrix/cyrix.h,v 1.1.2.5 1998/11/06 09:47:02 hohndel Exp $ */
+/* $XFree86: xc/programs/Xserver/hw/xfree86/vga256/drivers/cyrix/cyrix.h,v 1.1.2.6 1998/12/22 07:49:58 hohndel Exp $ */
 
 /* this code is partly based on the MediaGX sources from the GGI project
    based on CYRIX example code (gxvideo.c) and included with CYRIX and
@@ -88,9 +88,10 @@
 #define CYRIXsetVectorMode()                 \
                      GX_REG(GP_VECTOR_MODE)  = (vectorMode)
 
-#define IfDest(xrop, val)   ((((xrop) & 0x5) ^ (((xrop) & 0xA) >> 1)) ? (val) : 0)
-
-
+#define IfDest(rop, planemask, val)                                        \
+                                 (( (((rop) & 0x5) ^ (((rop) & 0xA) >> 1)) \
+                                 || (~((planemask) & 0xFF))                \
+                                 ) ? (val) : 0)
 
 /* Generic MediaGX hardware register and value definitions */
 
Index: xc/programs/Xserver/hw/xfree86/vga256/drivers/cyrix/cyrix_accel.c
diff -u xc/programs/Xserver/hw/xfree86/vga256/drivers/cyrix/cyrix_accel.c:1.1.2.3 xc/programs/Xserver/hw/xfree86/vga256/drivers/cyrix/cyrix_accel.c:1.1.2.5
--- xc/programs/Xserver/hw/xfree86/vga256/drivers/cyrix/cyrix_accel.c:1.1.2.3	Fri Nov  6 20:47:04 1998
+++ xc/programs/Xserver/hw/xfree86/vga256/drivers/cyrix/cyrix_accel.c	Tue Dec 22 18:49:58 1998
@@ -1,4 +1,4 @@
-/* $XFree86: xc/programs/Xserver/hw/xfree86/vga256/drivers/cyrix/cyrix_accel.c,v 1.1.2.3 1998/11/06 09:47:04 hohndel Exp $ */
+/* $XFree86: xc/programs/Xserver/hw/xfree86/vga256/drivers/cyrix/cyrix_accel.c,v 1.1.2.5 1998/12/22 07:49:58 hohndel Exp $ */
 
 /*
  * Copyright 1998 by Annius Groenink, Amsterdam.
@@ -80,10 +80,12 @@
 {	/* General acceleration flags */
 	xf86AccelInfoRec.Flags = PIXMAP_CACHE
 	                       | BACKGROUND_OPERATIONS
+#if 0
+	                       | HARDWARE_PATTERN_MONO_TRANSPARENCY
+#endif
 	                       | HARDWARE_PATTERN_SCREEN_ORIGIN
 	                       | HARDWARE_PATTERN_BIT_ORDER_MSBFIRST
-	                       | HARDWARE_PATTERN_PROGRAMMED_BITS
-	                       | HARDWARE_PATTERN_MONO_TRANSPARENCY;
+	                       | HARDWARE_PATTERN_PROGRAMMED_BITS;
 
 	/* Sync */
 	xf86AccelInfoRec.Sync = CYRIXAccelSync;
@@ -93,19 +95,22 @@
 	    CYRIXSetupForFillRectSolid;
 	xf86AccelInfoRec.SubsequentFillRectSolid = 
 	    CYRIXSubsequentFillRectSolid;
-	xf86GCInfoRec.PolyFillRectSolidFlags = 0;
+	xf86GCInfoRec.PolyFillRectSolidFlags = NO_PLANEMASK;
 
 	/* ScreenToScreen copies */
 	xf86AccelInfoRec.SetupForScreenToScreenCopy =
 	    CYRIXSetupForScreenToScreenCopy;
 	xf86AccelInfoRec.SubsequentScreenToScreenCopy =
 	    CYRIXSubsequentScreenToScreenCopy;
-	xf86GCInfoRec.CopyAreaFlags = TRANSPARENCY_GXCOPY;
 
-	/* Bresenham lines */
+	xf86GCInfoRec.CopyAreaFlags = NO_PLANEMASK | GXCOPY_ONLY;
+
+#if 0
+	/* Bresenham lines - disable because of minor display errors */
 	xf86AccelInfoRec.SubsequentBresenhamLine =
 	    CYRIXSubsequentBresenhamLine;
 	xf86AccelInfoRec.ErrorTermBits = 15;
+#endif
 
 	/* 8x8 color-expanded patterns */
 	xf86AccelInfoRec.SetupFor8x8PatternColorExpand =
@@ -115,6 +120,8 @@
 
 	/* Color expansion */
 	xf86AccelInfoRec.ColorExpandFlags = BIT_ORDER_IN_BYTE_MSBFIRST |
+	                                    NO_PLANEMASK |
+	                                    TRANSPARENCY_GXCOPY |
 	                                    SCANLINE_PAD_BYTE;
 
 	/* Use two blit buffers in a row for text expansion
@@ -175,13 +182,18 @@
 CYRIXSetupForFillRectSolid(color, rop, planemask)
 int color, rop;
 unsigned int planemask;
-{	CYRIXsetupSync();
+{	if (xf86GCInfoRec.PolyFillRectSolidFlags & NO_PLANEMASK)
+		planemask = 0xFFFF;
+	if (xf86GCInfoRec.PolyFillRectSolidFlags & GXCOPY_ONLY)
+		rop = GXcopy;
+
+	CYRIXsetupSync();
 	CYRIXsetSourceColors01(color, color);
 	CYRIXsetPatColors01(planemask, 0);
 	CYRIXsetPatMode(rop, RM_PAT_DISABLE);
 	blitMode = BM_READ_SRC_NONE | BM_WRITE_FB | BM_SOURCE_EXPAND
-	         | IfDest(rop, BM_READ_DST_FB0);
-	vectorMode = IfDest(rop, VM_READ_DST_FB);
+	         | IfDest(rop, planemask, BM_READ_DST_FB0);
+	vectorMode = IfDest(rop, planemask, VM_READ_DST_FB);
 }
     
     
@@ -209,7 +221,14 @@
 int rop;
 unsigned int planemask;
 int transparency_color;
-{	CYRIXsetupSync();
+{	if (xf86GCInfoRec.CopyAreaFlags & NO_PLANEMASK)
+		planemask = 0xFFFF;
+	if (xf86GCInfoRec.CopyAreaFlags & GXCOPY_ONLY)
+		rop = GXcopy;
+	if (xf86GCInfoRec.CopyAreaFlags & NO_TRANSPARENCY)
+		transparency_color = -1;
+
+	CYRIXsetupSync();
 	CYRIXsetPatColors01(planemask, 0);
 
 	if (transparency_color == -1)
@@ -220,6 +239,9 @@
 	{	CYRIXsetPatModeTrans(RM_PAT_DISABLE);
 		transMode = 1;
 
+		if (xf86GCInfoRec.CopyAreaFlags & TRANSPARENCY_GXCOPY)
+			rop = GXcopy;
+
 		/* fill blit buffer 1 with the transparency color */
 		if (vgaBitsPerPixel == 16)
 		{	int              k   = CYRIXbltBufSize / 4;
@@ -235,7 +257,7 @@
 	}
 
 	blitMode = BM_READ_SRC_FB | BM_WRITE_FB | BM_SOURCE_COLOR
-	         | (transMode ? IfDest(rop, BM_READ_DST_FB1) : BM_READ_DST_NONE)
+	         | (transMode ? BM_READ_DST_NONE : IfDest(rop, planemask, BM_READ_DST_FB1))
 	         | (ydir < 0 ? BM_REVERSE_Y : 0);
 
 	copyXdir = xdir;
@@ -318,6 +340,11 @@
 unsigned int planemask;
 {	int trans = (bg == -1);
 
+	if (xf86AccelInfoRec.ColorExpandFlags & NO_PLANEMASK)
+		planemask = 0xFFFF;
+	if (trans && (xf86AccelInfoRec.ColorExpandFlags & TRANSPARENCY_GXCOPY))
+		rop = GXcopy;
+
 	CYRIXsetupSync();
 	CYRIXsetSourceColors01(planemask, planemask);
 	CYRIXsetPatColors01(trans ? 0 : bg, fg);
@@ -325,7 +352,7 @@
 	CYRIXsetPatModeX(rop, RM_PAT_MONO | (trans ? RM_PAT_TRANSPARENT : 0));
 
 	blitMode = BM_READ_SRC_NONE | BM_WRITE_FB | BM_SOURCE_EXPAND
-	         | (trans ? IfDest(rop, BM_READ_DST_FB0) : BM_READ_DST_NONE);
+	         | (trans ? IfDest(rop, planemask, BM_READ_DST_FB0) : BM_READ_DST_NONE);
 }
 
 void CYRIXSubsequent8x8PatternColorExpand(patternx, patterny, x, y, w, h)
@@ -341,6 +368,9 @@
 unsigned int planemask;
 {	int trans = (bg == -1);
 
+	if (trans && (xf86AccelInfoRec.ColorExpandFlags & TRANSPARENCY_GXCOPY))
+		rop = GXcopy;
+
 	CYRIXsetupSync();
 	CYRIXsetSourceColors01(trans ? 0 : bg, fg);
 	CYRIXsetPatColors01(planemask, 0);
@@ -352,7 +382,7 @@
 	   used.  So far, this problem has not manifested itself in
 	   practice. */
 	blitMode = BM_READ_SRC_BB0 | BM_WRITE_FB | BM_SOURCE_EXPAND
-	         | (trans ? IfDest(rop, BM_READ_DST_FB1) : BM_READ_DST_NONE);
+	         | (trans ? IfDest(rop, planemask, BM_READ_DST_FB1) : BM_READ_DST_NONE);
 }
 
 void CYRIXSubsequentCPUToScreenColorExpand(x, y, w, h, skipleft)
Index: xc/programs/Xserver/hw/xfree86/vga256/drivers/mga/mga.h
diff -u xc/programs/Xserver/hw/xfree86/vga256/drivers/mga/mga.h:3.8.2.8 xc/programs/Xserver/hw/xfree86/vga256/drivers/mga/mga.h:3.8.2.9
--- xc/programs/Xserver/hw/xfree86/vga256/drivers/mga/mga.h:3.8.2.8	Wed Oct 21 06:51:20 1998
+++ xc/programs/Xserver/hw/xfree86/vga256/drivers/mga/mga.h	Mon Dec 28 00:10:16 1998
@@ -1,4 +1,4 @@
-/* $XFree86: xc/programs/Xserver/hw/xfree86/vga256/drivers/mga/mga.h,v 3.8.2.8 1998/10/20 20:51:20 hohndel Exp $ */
+/* $XFree86: xc/programs/Xserver/hw/xfree86/vga256/drivers/mga/mga.h,v 3.8.2.9 1998/12/27 13:10:16 dawes Exp $ */
 /*
  * MGA Millennium (MGA2064W) functions
  *
@@ -86,6 +86,7 @@
 extern int MGAydstorg;
 extern unsigned char *MGAMMIOBase;
 extern Bool MGAIsSDRAM;
+extern Bool MGACursorBug;
 
 extern void Mga8AccelInit();
 extern void Mga16AccelInit();
Index: xc/programs/Xserver/hw/xfree86/vga256/drivers/mga/mga_dac3026.c
diff -u xc/programs/Xserver/hw/xfree86/vga256/drivers/mga/mga_dac3026.c:1.1.2.11 xc/programs/Xserver/hw/xfree86/vga256/drivers/mga/mga_dac3026.c:1.1.2.12
--- xc/programs/Xserver/hw/xfree86/vga256/drivers/mga/mga_dac3026.c:1.1.2.11	Wed Oct 14 17:50:16 1998
+++ xc/programs/Xserver/hw/xfree86/vga256/drivers/mga/mga_dac3026.c	Mon Dec 28 00:10:16 1998
@@ -1,4 +1,4 @@
-/* $XFree86: xc/programs/Xserver/hw/xfree86/vga256/drivers/mga/mga_dac3026.c,v 1.1.2.11 1998/10/14 07:50:16 dawes Exp $ */
+/* $XFree86: xc/programs/Xserver/hw/xfree86/vga256/drivers/mga/mga_dac3026.c,v 1.1.2.12 1998/12/27 13:10:16 dawes Exp $ */
 /*
  * Copyright 1994 by Robin Cutshaw <robin@XFree86.org>
  *
@@ -1095,10 +1095,20 @@
     /* reset cursor RAM load address A7..A0 */
     outTi3026dreg(TVP3026_WADR_PAL, 0x00); 
 
-    for (i = 0; i < 512; i++, mask+=2) 
+    for (i = 0; i < 512; i++, mask+=2) {
+	if (MGACursorBug) {
+	    while (INREG8(0x1FDA) & 0x01);
+	    while (!(INREG8(0x1FDA) & 0x01));
+	}
         outTi3026dreg(TVP3026_CUR_RAM, *mask);    
-    for (i = 0; i < 512; i++, src+=2) 
+    }
+    for (i = 0; i < 512; i++, src+=2) {
+	if (MGACursorBug) {
+	    while (INREG8(0x1FDA) & 0x01);
+	    while (!(INREG8(0x1FDA) & 0x01));
+	}
         outTi3026dreg(TVP3026_CUR_RAM, *src);   
+    }
 }
 
 static void 
Index: xc/programs/Xserver/hw/xfree86/vga256/drivers/mga/mga_dacG200.c
diff -u xc/programs/Xserver/hw/xfree86/vga256/drivers/mga/mga_dacG200.c:1.1.2.11 xc/programs/Xserver/hw/xfree86/vga256/drivers/mga/mga_dacG200.c:1.1.2.12
--- xc/programs/Xserver/hw/xfree86/vga256/drivers/mga/mga_dacG200.c:1.1.2.11	Sun Nov  1 18:51:18 1998
+++ xc/programs/Xserver/hw/xfree86/vga256/drivers/mga/mga_dacG200.c	Fri Dec 18 22:56:29 1998
@@ -1,4 +1,4 @@
-/* $XFree86: xc/programs/Xserver/hw/xfree86/vga256/drivers/mga/mga_dacG200.c,v 1.1.2.11 1998/11/01 07:51:18 dawes Exp $ */
+/* $XFree86: xc/programs/Xserver/hw/xfree86/vga256/drivers/mga/mga_dacG200.c,v 1.1.2.12 1998/12/18 11:56:29 dawes Exp $ */
 /*
  * Millennium G200 RAMDAC driver
  */
@@ -530,6 +530,7 @@
 vgaMGAPtr save;
 {
 	int i;
+	static Bool firstTime = TRUE;
 	
 	/*
 	 * Code is needed to get back to bank zero.
@@ -550,9 +551,11 @@
 		save->DACreg[i]	 = inMGAdac(i);
 
 	save->DAClong = pciReadLong(MGAPciTag, PCI_OPTION_REG);
-	if (xf86Verbose)
+	if (firstTime && xf86Verbose)
 	    ErrorF("%s %s: Read OPTION 0x%08x\n",
 		XCONFIG_PROBED, vga256InfoRec.name,save->DAClong);
+
+	firstTime = FALSE;
 
 	for (i = 0; i < 6; i++) {
 		outb(0x3DE, i);
Index: xc/programs/Xserver/hw/xfree86/vga256/drivers/mga/mga_driver.c
diff -u xc/programs/Xserver/hw/xfree86/vga256/drivers/mga/mga_driver.c:1.1.2.35 xc/programs/Xserver/hw/xfree86/vga256/drivers/mga/mga_driver.c:1.1.2.38
--- xc/programs/Xserver/hw/xfree86/vga256/drivers/mga/mga_driver.c:1.1.2.35	Sun Nov  1 01:41:00 1998
+++ xc/programs/Xserver/hw/xfree86/vga256/drivers/mga/mga_driver.c	Mon Dec 28 00:10:17 1998
@@ -40,7 +40,7 @@
  *		Fixed 32bpp hires 8MB horizontal line glitch at middle right
  */
  
-/* $XFree86: xc/programs/Xserver/hw/xfree86/vga256/drivers/mga/mga_driver.c,v 1.1.2.35 1998/10/31 14:41:00 hohndel Exp $ */
+/* $XFree86: xc/programs/Xserver/hw/xfree86/vga256/drivers/mga/mga_driver.c,v 1.1.2.38 1998/12/27 13:10:17 dawes Exp $ */
 
 #include "X.h"
 #include "input.h"
@@ -92,6 +92,7 @@
 int MGABppShft;
 int MGAusefbitblt;
 int MGAydstorg;
+Bool MGACursorBug = FALSE;
 unsigned char* MGAMMIOBase = NULL;
 #ifdef __alpha__
 unsigned char* MGAMMIOBaseDENSE = NULL;
@@ -734,7 +735,7 @@
 	   if ( MGA_IS_2164(MGAchipset) || MGA_IS_G100(MGAchipset) ) {
 		vga256InfoRec.videoRam = 4096;
 		ErrorF("(!!) %s: Unable to probe for video memory size.  "
-			"Assuming 8 Meg.\tPlease specify the correct amount "
+			"Assuming 4 Meg.\tPlease specify the correct amount "
 			"in the XF86Config file.\tSee the file README.MGA "
 			"for details.\n", vga256InfoRec.name);
 	   } else if (MGA_IS_G200(MGAchipset)) {
@@ -788,6 +789,8 @@
 		break;
 	case PCI_CHIP_MGAG100:
 	case PCI_CHIP_MGAG200:
+	case PCI_CHIP_MGAG100_PCI:
+	case PCI_CHIP_MGAG200_PCI:
 		MGAG200RamdacInit();
 		break;
 	}
@@ -815,6 +818,7 @@
 	OFLG_SET(OPTION_DAC_8_BIT, &MGA.ChipOptionFlags);
 	OFLG_SET(OPTION_SW_CURSOR, &MGA.ChipOptionFlags);
 	OFLG_SET(OPTION_HW_CURSOR, &MGA.ChipOptionFlags);
+	OFLG_SET(OPTION_CURSOR_BUG, &MGA.ChipOptionFlags);
 	OFLG_SET(OPTION_PCI_RETRY, &MGA.ChipOptionFlags);
 	OFLG_SET(OPTION_MGA_24BPP_FIX, &MGA.ChipOptionFlags);
 	OFLG_SET(OPTION_MGA_SDRAM, &MGA.ChipOptionFlags);
@@ -1156,6 +1160,10 @@
 			   XCONFIG_GIVEN, vga256InfoRec.name);
 #endif
 
+		if (MGA_IS_2164(MGAchipset) &&
+		    OFLG_ISSET(OPTION_CURSOR_BUG, &vga256InfoRec.options))
+		    MGACursorBug = TRUE;
+	
 		/*
 		 * now call the new acc interface
 		 */
Index: xc/programs/Xserver/hw/xfree86/vga256/drivers/mga/mga_hwcurs.c
diff -u xc/programs/Xserver/hw/xfree86/vga256/drivers/mga/mga_hwcurs.c:1.1.2.3 xc/programs/Xserver/hw/xfree86/vga256/drivers/mga/mga_hwcurs.c:1.1.2.4
--- xc/programs/Xserver/hw/xfree86/vga256/drivers/mga/mga_hwcurs.c:1.1.2.3	Mon Feb  2 03:05:12 1998
+++ xc/programs/Xserver/hw/xfree86/vga256/drivers/mga/mga_hwcurs.c	Sun Dec 20 22:12:07 1998
@@ -1,4 +1,4 @@
-/* $XFree86: xc/programs/Xserver/hw/xfree86/vga256/drivers/mga/mga_hwcurs.c,v 1.1.2.3 1998/02/01 16:05:12 robin Exp $ */
+/* $XFree86: xc/programs/Xserver/hw/xfree86/vga256/drivers/mga/mga_hwcurs.c,v 1.1.2.4 1998/12/20 11:12:07 hohndel Exp $ */
 /*
  * Copyright 1994 by Robin Cutshaw <robin@XFree86.org>
  *
@@ -61,9 +61,21 @@
  */
 Bool MGAHwCursorInit()
 {
+    int RamUsed;
+
     if (!MGAdac.isHwCursor) 
 	return FALSE;
-
+    RamUsed = vga256InfoRec.virtualY * vga256InfoRec.displayWidth 
+                 * vgaBitsPerPixel / 8;
+#ifdef DEBUG
+    ErrorF("Ram %d Used %d Cursor %d\n",vga256InfoRec.videoRam*1024,RamUsed,
+    		MGAdac.CursorMaxWidth * MGAdac.CursorMaxHeight*
+		vgaBitsPerPixel / 8);
+#endif
+    if ((vga256InfoRec.videoRam * 1024 - RamUsed) < 
+	    (MGAdac.CursorMaxWidth * MGAdac.CursorMaxHeight 
+		* vgaBitsPerPixel / 8))
+        return FALSE;
     XAACursorInfoRec.MaxWidth = MGAdac.CursorMaxWidth;
     XAACursorInfoRec.MaxHeight = MGAdac.CursorMaxHeight;
     XAACursorInfoRec.Flags = MGAdac.CursorFlags;
Index: xc/programs/Xserver/hw/xfree86/vga256/drivers/nv/Imakefile
diff -u xc/programs/Xserver/hw/xfree86/vga256/drivers/nv/Imakefile:3.2.2.3 xc/programs/Xserver/hw/xfree86/vga256/drivers/nv/Imakefile:3.2.2.6
--- xc/programs/Xserver/hw/xfree86/vga256/drivers/nv/Imakefile:3.2.2.3	Tue Oct 20 06:57:08 1998
+++ xc/programs/Xserver/hw/xfree86/vga256/drivers/nv/Imakefile	Tue Dec 22 23:39:13 1998
@@ -1,21 +1,19 @@
 XCOMM $XConsortium: Imakefile /main/2 1996/10/27 13:00:56 kaleb $
 XCOMM
 XCOMM
-XCOMM $XFree86: xc/programs/Xserver/hw/xfree86/vga256/drivers/nv/Imakefile,v 3.2.2.3 1998/10/19 20:57:08 hohndel Exp $
+XCOMM $XFree86: xc/programs/Xserver/hw/xfree86/vga256/drivers/nv/Imakefile,v 3.2.2.6 1998/12/22 12:39:13 hohndel Exp $
 
 
 
 
-XCOMM $XFree86: xc/programs/Xserver/hw/xfree86/vga256/drivers/nv/Imakefile,v 3.2.2.3 1998/10/19 20:57:08 hohndel Exp $
+XCOMM $XFree86: xc/programs/Xserver/hw/xfree86/vga256/drivers/nv/Imakefile,v 3.2.2.6 1998/12/22 12:39:13 hohndel Exp $
 #include <Server.tmpl>
 
-SRCS = nv_driver.c nv1driver.c nv3driver.c nv4driver.c nvaccel.c nv1setup.c nv3setup.c nv4setup.c \
-       nv1cursor.c nv3cursor.c nv4cursor.c nv3arb.c nv4arb.c
+SRCS = nv_driver.c nv1driver.c nv1accel.c nv1setup.c \
+       nv1cursor.c riva_hw.c riva_xaa.c
 
-OBJS = nv_driver.o nv1driver.o nv3driver.o nv4driver.o nvaccel.o nv1setup.o nv3setup.o nv4setup.o \
-       nv1cursor.o nv3cursor.o nv4cursor.o nv3arb.o nv4arb.o
-
-DEFINES = -DPSZ=8
+OBJS = nv_driver.o nv1driver.o nv1accel.o nv1setup.o \
+       nv1cursor.o riva_hw.o riva_xaa.o
 
 #if XF86LinkKit
 INCLUDES = -I. -I../../../include -I../../../include/X11 -I../..
@@ -26,6 +24,8 @@
            -I$(FONTINCSRC) -I$(SERVERSRC)/include -I$(XINCLUDESRC)
 #endif
 
+DEFINES = -DPSZ=8
+
 #if MakeHasPosixVariableSubstitutions
 SubdirLibraryRule($(OBJS))
 #endif
@@ -34,28 +34,18 @@
 
 NormalRelocatableTarget(nv_drv,$(OBJS))
 
-InstallLinkKitNonExecFile(nv1ref.h,$(LINKKITDIR)/drivers/vga256/nv)
-InstallLinkKitNonExecFile(nv3ref.h,$(LINKKITDIR)/drivers/vga256/nv)
-InstallLinkKitNonExecFile(nv4ref.h,$(LINKKITDIR)/drivers/vga256/nv)
-InstallLinkKitNonExecFile(nv3arb.h,$(LINKKITDIR)/drivers/vga256/nv)
-InstallLinkKitNonExecFile(nv4arb.h,$(LINKKITDIR)/drivers/vga256/nv)
-InstallLinkKitNonExecFile(nvreg.h,$(LINKKITDIR)/drivers/vga256/nv)
-InstallLinkKitNonExecFile(nvuser.h,$(LINKKITDIR)/drivers/vga256/nv)
-InstallLinkKitNonExecFile(nvvga.h,$(LINKKITDIR)/drivers/vga256/nv)
-InstallLinkKitNonExecFile(nvcursor.h,$(LINKKITDIR)/drivers/vga256/nv)
+InstallLinkKitNonExecFile(Imakefile,$(LINKKITDIR)/drivers/vga256/nv)
+InstallLinkKitNonExecFile(nv1accel.c,$(LINKKITDIR)/drivers/vga256/nv)
 InstallLinkKitNonExecFile(nv1cursor.c,$(LINKKITDIR)/drivers/vga256/nv)
-InstallLinkKitNonExecFile(nv3cursor.c,$(LINKKITDIR)/drivers/vga256/nv)
-InstallLinkKitNonExecFile(nv4cursor.c,$(LINKKITDIR)/drivers/vga256/nv)
-InstallLinkKitNonExecFile(nv_driver.c,$(LINKKITDIR)/drivers/vga256/nv)
 InstallLinkKitNonExecFile(nv1driver.c,$(LINKKITDIR)/drivers/vga256/nv)
-InstallLinkKitNonExecFile(nv3driver.c,$(LINKKITDIR)/drivers/vga256/nv)
-InstallLinkKitNonExecFile(nv4driver.c,$(LINKKITDIR)/drivers/vga256/nv)
-InstallLinkKitNonExecFile(nvaccel.c,$(LINKKITDIR)/drivers/vga256/nv)
+InstallLinkKitNonExecFile(nv1ref.h,$(LINKKITDIR)/drivers/vga256/nv)
 InstallLinkKitNonExecFile(nv1setup.c,$(LINKKITDIR)/drivers/vga256/nv)
-InstallLinkKitNonExecFile(nv3setup.c,$(LINKKITDIR)/drivers/vga256/nv)
-InstallLinkKitNonExecFile(nv4setup.c,$(LINKKITDIR)/drivers/vga256/nv)
-InstallLinkKitNonExecFile(nv3arb.c,$(LINKKITDIR)/drivers/vga256/nv)
-InstallLinkKitNonExecFile(nv4arb.c,$(LINKKITDIR)/drivers/vga256/nv)
-InstallLinkKitNonExecFile(Imakefile,$(LINKKITDIR)/drivers/vga256/nv)
+InstallLinkKitNonExecFile(nv_driver.c,$(LINKKITDIR)/drivers/vga256/nv)
+InstallLinkKitNonExecFile(nvreg.h,$(LINKKITDIR)/drivers/vga256/nv)
+InstallLinkKitNonExecFile(nvvga.h,$(LINKKITDIR)/drivers/vga256/nv)
+InstallLinkKitNonExecFile(riva_hw.c,$(LINKKITDIR)/drivers/vga256/nv)
+InstallLinkKitNonExecFile(riva_hw.h,$(LINKKITDIR)/drivers/vga256/nv)
+InstallLinkKitNonExecFile(riva_tbl.h,$(LINKKITDIR)/drivers/vga256/nv)
+InstallLinkKitNonExecFile(riva_xaa.c,$(LINKKITDIR)/drivers/vga256/nv)
 
 DependTarget()
Index: xc/programs/Xserver/hw/xfree86/vga256/drivers/nv/README.RIVA
diff -u /dev/null xc/programs/Xserver/hw/xfree86/vga256/drivers/nv/README.RIVA:1.1.2.3
--- /dev/null	Wed Jan  6 00:32:28 1999
+++ xc/programs/Xserver/hw/xfree86/vga256/drivers/nv/README.RIVA	Thu Dec 24 00:36:27 1998
@@ -0,0 +1,30 @@
+The RIVA family of graphics processors are supported in this patch release of
+XFree86.  The functionality is basically equivalent to the previous 3.3.3
+release, however the source has been totally rewritten and some minor bugs
+have been fixed.  Having multiple X servers running at different resolutions
+and color depths in separate VTerms should work fine now. The NV1 code has been
+left alone.  The RIVA code now shares common code for the XAA routines.  A new
+file, riva_hw.c, manages all the differences between RIVA 128 and RIVA TNT
+such that they look almost identical to the XAA code.  The one major
+difference is that RIVA 128 still uses the 6 bit DAC, whereas TNT uses the 8
+bit DAC.  RIVA 128 is also limited to 555 RGB so asking for a 16 BPP forces 15
+BPP.  RIVA 128 still has some video noise in 32 BPP mode.  I removed all
+bandwidth calculations trying to avoid this, because they didn't really seem
+to help.  You should try reducing your video refresh rate if you want to run
+32 BPP on your RIVA 128/ZX at high res.  Someday this will get fixed for good...
+
+If you are interested in supporting RIVA chips in another environment, all you
+need is the riva_hw.c and associated header files.  It should just compile as
+it is OS agnostic.  Look in riva_xaa.c for the usage.  It is assumed all VGA
+code is external to riva_hw.c.  Only SVGA and accelerated state
+initialization, save, and restore is handled in riva_hw.c. Not all the
+2D/3D functionality is used in riva_xaa.c yet.  Soon, though...
+
+
+  	Dave Schmenk
+	NVIDIA Corp.
+
+
+
+
+$XFree86: xc/programs/Xserver/hw/xfree86/vga256/drivers/nv/README.RIVA,v 1.1.2.3 1998/12/23 13:36:27 hohndel Exp $
Index: xc/programs/Xserver/hw/xfree86/vga256/drivers/nv/README.RIVA128
diff -u xc/programs/Xserver/hw/xfree86/vga256/drivers/nv/README.RIVA128:1.1.2.3 xc/programs/Xserver/hw/xfree86/vga256/drivers/nv/README.RIVA128:removed
--- xc/programs/Xserver/hw/xfree86/vga256/drivers/nv/README.RIVA128:1.1.2.3	Mon Oct 19 17:33:38 1998
+++ xc/programs/Xserver/hw/xfree86/vga256/drivers/nv/README.RIVA128	Wed Jan  6 00:32:28 1999
@@ -1,38 +0,0 @@
-
-$XFree86: xc/programs/Xserver/hw/xfree86/vga256/drivers/nv/README.RIVA128,v 1.1.2.3 1998/10/19 07:33:38 hohndel Exp $
-
-XFree driver for NVidia/SGS-Thomson RIVA128
-===========================================
-
-This driver now accelerates bitblits,filled rectangles and colour expansion.
-It also support a hardware cursor.
-
-Note that requesting 16bpp actually gives 15bpp. This is because the RIVA128
-cannot accelerate many functions at 565 colour depth. If you put 
-"option noaccel" in the config file then 565 will be available - but without 
-acceleration of course.
-
-Known Bugs
-==========
-
-* Pixel noise at high resolution in 32bpp
-
-Thanks
-======
-
-Thanks to Chris Cox of STB systems for supplying a board.
-Also many thanks to Curtis,Dwight and Don at Nvidia for their help and support.
-
-
-Dave McKay
-January 1998
-
-10/16/98
-
-Update
-=====
-Video noise fixed.  Also disabled mono expansion code.  Should be faster
-on higher end machines.
-
-Dave Schmenk
-NVIDIA Corp
Index: xc/programs/Xserver/hw/xfree86/vga256/drivers/nv/README.RIVATNT
diff -u xc/programs/Xserver/hw/xfree86/vga256/drivers/nv/README.RIVATNT:1.1.2.3 xc/programs/Xserver/hw/xfree86/vga256/drivers/nv/README.RIVATNT:removed
--- xc/programs/Xserver/hw/xfree86/vga256/drivers/nv/README.RIVATNT:1.1.2.3	Thu Nov 19 03:38:43 1998
+++ xc/programs/Xserver/hw/xfree86/vga256/drivers/nv/README.RIVATNT	Wed Jan  6 00:32:28 1999
@@ -1,52 +0,0 @@
-XFree86 3.3.2 X Server for NVIDIA NV1, RIVA 128/ZX (NV3), RIVA TNT(NV4)
-
-This is simply the X server compiled only for NV acceleration (to reduce 
-binary image size) with the XFree86 version 3.3.2 distribution for Linux 
-w/glibc.  The server is Dave McKay's code with fixes for the video noise 
-along with support for the TNT.  If you aren't running the latest version 
-of XFree86, get that installed first using the XF86_SVGA server.  I've 
-been building and running this on RedHat 5.1, kernel version 2.0.34.  I 
-want to first get some feedback before releasing the source to make sure I 
-really did fix the video noise problems.  I've tried it up to 
-1280x1024x32, but I'm sure others push harder or use higher refresh rates.  
-128ZX users especially try the higher resolutions.  The SDRAM 128ZX parts 
-are more susceptible to the video noise.  I've tested this server using 
-both RIVA 128/ZX and TNT on my PPro 200 PCI and K6-2 AGP systems.  (The 
-K6-2 system really rocks on Linux - whats the corollary to Wintel?  
-LinAMD?).  If you still use an NV1, I'd like to hear from you - you must 
-be a real trooper.  
-
-Update:
-
-10/16/98
-
-The video clock was indeed being programmed wrong.  Thanks to everyone who 
-pointed this out.  If you had to make changes to your XF86Config file to 
-get the display correct, you may have to undo it.  Sorry.  
-
-Many people mentioned text was slow and the display update was a little 
-erratic.  I was trying to be clever and yield the CPU when the graphics 
-engine was busy, but it really didn't work well.  I've gone back to being 
-a CPU hog.  It probably doesn't slow apps down too much, and it keeps the 
-display responsive.  
-
-
-	Dave Schmenk
-	NVIDIA Corp.
-
-11/18/98
-
-After we already finalized XFree86-3.3.3 NVIDIA forced The XFree86 Project
-to replace the sources we had with sources that were partly run through the
-C preprocessor in order to remove some of the names that NVIDIA thought
-might give away IP from NVIDIA. This resulted in unreadable and unmaintainable
-code.
-
-The XFree86 Project is strongly opposed to such obfuscated code. We do not
-regard this as free software according to our standards. Due to the extremely
-late date of this decision from NVIDIA we decided to include the code as
-offered by NVIDIA. We are considering to remove support for the later NVIDIA
-chips in a future release, though.
-
-
-$XFree86: xc/programs/Xserver/hw/xfree86/vga256/drivers/nv/README.RIVATNT,v 1.1.2.3 1998/11/18 16:38:43 hohndel Exp $
Index: xc/programs/Xserver/hw/xfree86/vga256/drivers/nv/README.tech
diff -u xc/programs/Xserver/hw/xfree86/vga256/drivers/nv/README.tech:1.1.2.2 xc/programs/Xserver/hw/xfree86/vga256/drivers/nv/README.tech:removed
--- xc/programs/Xserver/hw/xfree86/vga256/drivers/nv/README.tech:1.1.2.2	Sat Jan 24 11:04:37 1998
+++ xc/programs/Xserver/hw/xfree86/vga256/drivers/nv/README.tech	Wed Jan  6 00:32:29 1999
@@ -1,60 +0,0 @@
-
-$XFree86: xc/programs/Xserver/hw/xfree86/vga256/drivers/nv/README.tech,v 1.1.2.2 1998/01/24 00:04:37 robin Exp $
-
-Brief technical note on the NV1
--------------------------------
-
-This document attempts to explain some of the technical features of the NV1.
-
-Central to the chip is the concept that user-space programs should be allowed 
-to have direct access to the chip. To enable this, the chip supports the 
-concepts of "channels". Each application that wants to draw to screen is 
-given a channel which allows it to perform graphics operations by writing to 
-specified locations. Each channel is a 64K region of memory mapped registers,
-divided into 8 identical subchannels. The NV1 supports 128 channels in total.
-
-Each channel can be mapped to a specific area of the screen. All coordinates
-supplied by the application are relative to this, the application doesn't
-actually know where on the screen it's window is mapped. The chip also
-supports clipping of this region, with multiple clip regions. If the number of
-clip regions is exceeded then the object has to be drawn multiple times,
-changing the clip regions for each invocation to ensure the correct clipping
-behaviour.
-
-Another feature of the chip is that all drawing is done via objects. For
-example, if I want to draw a rectangle, I create a rectangle object. Each
-object is given a unique 32 bit id. To actually draw a rectangle, I would load
-the rectangle object id into the subchannel, and then write the
-coordinates. The chip will add these coordinates to the channel's window offset
-to get the real screen coordinates, handle clipping, and then finally draw the
-rectangle.
-
-Each object has data associated with it, which specifies how to configure 
-the graphics hardware for that operation. The hardware has a hash table to 
-perform look up of objects. If you load a different object into the subchannel 
-then the hardware will look at the hash table for that id number and load the 
-associated data for that object into the graphics hardware.
-
-Software is needed to control this functionality. If the subchannel is loaded 
-with an object that isn't in the hash table, an interrupt is raised.
-Software will be expected to load the appropriate object into the hash 
-table and restart the drawing operation.
-
-Also, if multiple channels are drawing at the same time, the hardware will 
-multiplex between them. An interrupt will be raised when a context switch is 
-needed and the software will be expected to load the state for the channel to 
-be swapped to and restart drawing.
-
-In the case of XFree86, since the driver cannot handle interrupts as it 
-is not part of the kernel, we have to be extremely careful not to raise an 
-interrupt, as the chip will not do anything until the interrupt is dealt 
-with. It also means that we can only ever use one channel, and cannot 
-do any operations which require DMA such as host memory to screen blits, 
-the 3D texture mapping, or any of the sound functionality. If these features 
-are to be supported the driver will need to be moved into the kernel.
-
-For more details, download Nvidia's NVlib SDK.
-
-
-
-/* $XFree86: xc/programs/Xserver/hw/xfree86/vga256/drivers/nv/README.tech,v 1.1.2.2 1998/01/24 00:04:37 robin Exp $ */
Index: xc/programs/Xserver/hw/xfree86/vga256/drivers/nv/nv1accel.c
diff -u /dev/null xc/programs/Xserver/hw/xfree86/vga256/drivers/nv/nv1accel.c:1.1.2.2
--- /dev/null	Wed Jan  6 00:32:29 1999
+++ xc/programs/Xserver/hw/xfree86/vga256/drivers/nv/nv1accel.c	Wed Dec 23 03:33:18 1998
@@ -0,0 +1,473 @@
+/*
+ * $XFree86: xc/programs/Xserver/hw/xfree86/vga256/drivers/nv/nv1accel.c,v 1.1.2.2 1998/12/22 16:33:18 hohndel Exp $
+ *
+ * Copyright 1996-1997  David J. McKay
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * DAVID J. MCKAY BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+ * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF
+ * OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ */
+
+#include <stdlib.h>
+
+#include "vga256.h"
+#include "xf86.h"
+#include "vga.h"
+#include "xf86xaa.h"
+#include "miline.h"
+
+#define XCONFIG_FLAGS_ONLY
+#include "xf86_Config.h"
+
+#include "nvuser.h"
+#include "nvreg.h"
+
+#ifdef DEBUG
+#define CHECK()
+#else
+#define CHECK()
+#endif
+
+/* These are the subchannels where the various objects are */
+
+#define ROP_SUBCHANNEL           0
+#define BLIT_SUBCHANNEL          1
+#define PATTERN_SUBCHANNEL       2
+#define RECT_SUBCHANNEL          3
+#define CLIP_SUBCHANNEL          4
+#define COLOUR_EXPAND_SUBCHANNEL 5
+#define GLYPH_SUBCHANNEL         5
+#define LINE_SUBCHANNEL          6
+#define TRI3D_SUBCHANNEL         6
+#define LIN_SUBCHANNEL           7
+
+extern void * pfb;
+
+/* This is the pointer to the channel */
+static NvChannel *chan0=NULL;
+/* Pointers to fixed subchannels */
+static NvSubChannel *ropChan=NULL;
+static NvSubChannel *rectChan=NULL;
+static NvSubChannel *blitChan=NULL;
+static NvSubChannel *clipChan=NULL;
+static NvSubChannel *colourExpandChan=NULL;
+
+/*#define NV_ENABLE_LINES*/
+
+/* Lines are disables at the moment. I have been unable to get the
+ * lines produced by the NV1 hardware to match the software routines.
+ * The NV1 draws lines a la windows, which is different to what X wants
+ * Even fiddling with the zero bias does not get it correct. Will need a
+ * lot of work to get it to work
+ */
+#ifdef NV_ENABLE_LINES
+static NvSubChannel *lineChan=NULL;
+static NvSubChannel *linChan=NULL;
+#endif
+
+/* Holds number of free slots in fifo. Means we don't have to re-read
+ * the fifo count every time we want to write to the chip.  Should do something useful if chip
+ * is busy (like keep the cursor updated). Calling sched_yield() is nice for the other apps running,
+ * but it really makes the server sluggish.
+ */
+int freeSlots=0;
+
+#define WaitForSlots(n,words) \
+  while((freeSlots-=((words)*4))<0){\
+    freeSlots=chan0->subChannel[n].control.free;\
+  }
+
+static int currentRop=-1;
+
+static void NVSetRop(int rop)
+{
+    static int ropTrans[16] = {
+        0x0,  /* GXclear */
+        0x88, /* Gxand */
+        0x44, /* GXandReverse */
+        0xcc, /* GXcopy */
+        0x22, /* GXandInverted */
+        0xaa, /* GXnoop */
+        0x66, /* GXxor */
+        0xee, /* GXor */
+        0x11, /* GXnor */
+        0x99, /* GXequiv */
+        0x55, /* GXinvert */
+        0xdd, /* GXorReverse */
+        0x33, /* GXcopyInverted */
+        0xbb, /* GXorInverted */
+        0x77, /* GXnand */
+        0xff  /* GXset */
+    };
+    currentRop=rop;
+    WaitForSlots(ROP_SUBCHANNEL,1);
+    ropChan->method.ropSolid.setRop=ropTrans[rop];
+    CHECK();
+}
+
+/* I haven't figured out how Patterns work yet, so this code is
+ * not used at present
+ */
+#if 0
+static NVSetPatternRop(int rop)
+{
+    static int ropTrans[16]={
+        0x00, /* GXclear */
+        0xa0, /* Gxand */
+        0x0a, /* GXandReverse */
+        0xf0, /* GXcopy */
+        0x30, /* GXandInverted */
+        0xaa, /* GXnoop */
+        0x3a, /* GXxor */
+        0xfa, /* GXor */
+        0x03, /* GXnor */
+        0xa0, /* Gxequiv */
+        0x0f, /* GXinvert */
+        0xaf, /* GXorReverse */
+        0x33, /* GXcopyInverted */
+        0xbb, /* GXorInverted */
+        0xf3, /* GXnand */
+        0xff  /* GXset */
+    };
+    currentRop=rop+16; /* +16 is important */
+    WaitForSlots(ROP_SUBCHANNEL,1);
+    ropChan->method.ropSolid.setRop=ropTrans[rop];
+    CHECK();
+
+}
+
+#endif
+
+/*
+ * Due to the fact that the SetupForFillRectSolid() is also used
+ * to setup for lines we have to record the colour in a static
+ * variable and write it out every time we do a drawing operation.
+ * This costs some performance and is IMHO wrong anyway. Why should
+ * you call a routine for filled rectangles when you are drawing lines?
+ * Will get round to "fixing" this if I ever get lines on the NV1 to work
+ * correctly
+ */
+
+#if 1
+static int currentColor;
+#endif
+
+static void NVSetupForFillRectSolid(int color,int rop,unsigned planemask)
+{
+    if (currentRop!=rop)
+    {
+        NVSetRop(rop);
+    }
+#if 1
+    currentColor=color;
+#else
+    WaitForSlots(RECT_SUBCHANNEL,1);
+    rectChan->method.renderSolidRectangle.color=color;
+#endif
+
+    CHECK();
+}
+
+static void NVSubsequentFillRectSolid(int x,int y,int w,int h)
+{
+
+#if 1
+    WaitForSlots(RECT_SUBCHANNEL,3);
+    rectChan->method.renderSolidRectangle.color=currentColor;
+#else
+    WaitForSlots(RECT_SUBCHANNEL,2);
+#endif
+
+    rectChan->method.renderSolidRectangle.rectangle[0].yx=PACK_UINT16(y,x);
+    rectChan->method.renderSolidRectangle.rectangle[0].heightWidth=
+    PACK_UINT16(h,w);
+    CHECK();
+}
+
+
+
+
+static int clippingOn=0;
+
+static void NVSetClippingRectangle(int x1,int y1,int x2,int y2)
+{
+    int height,width;
+
+    width=x2-x1+1;height=y2-y1+1;
+    WaitForSlots(CLIP_SUBCHANNEL,2);
+    clipChan->method.clip.setRectangle.yx=PACK_INT16(y1,x1);
+    clipChan->method.clip.setRectangle.heightWidth=PACK_UINT16(height,width);
+    clippingOn=1;
+    CHECK();
+}
+
+
+#define NVResetClippingRectangle() \
+  { NVSetClippingRectangle(0,0,MAX_INT16,MAX_INT16);\
+  clippingOn=0;}
+
+#ifdef NV_ENABLE_LINES
+static void NVSubsequentTwoPointLine(int x1,int y1,int x2,int y2,int bias)
+{
+    NvRenderSolidLine *line;
+
+    line = (bias&0x0100) ?  &(linChan->method.line) : &(lineChan->method.line);
+    /* We should really check appropriate subchannel here */
+    WaitForSlots(LINE_SUBCHANNEL,3);
+    line->color=currentColor;
+    line->line[0].y0_x0=PACK_INT16(y1,x1);
+    line->line[0].y1_x1=PACK_INT16(y2,x2);
+    /* Reset clipping rectangle to normal */
+    if (clippingOn)
+    {
+        NVResetClippingRectangle();
+    }
+}
+
+#endif
+
+static void NVSetupForScreenToScreenCopy(int xdir,int ydir,int rop,
+                                         unsigned planemask,
+                                         int transparency_color)
+{
+    if (rop!=currentRop)
+    {
+        NVSetRop(rop);
+    }
+
+    /* When transparency is implemented, will have to flip object */
+}
+
+static void NVSubsequentScreenToScreenCopy(int x1,int y1,
+                                           int x2,int y2,int w,int h)
+{
+    WaitForSlots(BLIT_SUBCHANNEL,3);
+    blitChan->method.blit.yxIn=PACK_UINT16(y1,x1);
+    blitChan->method.blit.yxOut=PACK_UINT16(y2,x2);
+    blitChan->method.blit.heightWidth=PACK_UINT16(h,w);
+    CHECK();
+}
+
+
+/* How much date to transfer */
+static int scanlineWordCount;
+static unsigned char scratchBuffer[512];
+static int colourExpandMask=0;
+
+static void NVSetupForScanlineScreenToScreenColorExpand(int x,int y,int w,
+                                                        int h,int bg,int fg,
+                                                        int rop,
+                                                        unsigned planemask)
+{
+    if (currentRop!=rop)
+    {
+        NVSetRop(rop);
+    }
+    WaitForSlots(COLOUR_EXPAND_SUBCHANNEL,5);
+    if (bg==-1)
+    {
+        colourExpandChan->method.imageMonochromeFromCpu.color0=0;
+    }
+    else
+    {
+        colourExpandChan->method.imageMonochromeFromCpu.color0=bg|colourExpandMask;
+    }
+    colourExpandChan->method.imageMonochromeFromCpu.color1=fg|colourExpandMask;
+    colourExpandChan->method.imageMonochromeFromCpu.point=PACK_UINT16(y,x);
+    colourExpandChan->method.imageMonochromeFromCpu.size=PACK_UINT16(h,w);
+    colourExpandChan->method.imageMonochromeFromCpu.sizeIn=
+    PACK_UINT16(h,(w+31)&(~31));
+    scanlineWordCount = (w + 31) >> 5;
+    CHECK();
+}
+
+static void NVSubsequentScanlineScreenToScreenColorExpand(int srcAddr)
+{
+    unsigned long *ptr = (unsigned long*)scratchBuffer;
+    int count = scanlineWordCount;
+    int i=0;
+
+    /* This rather simple algorithm seems to perform better than
+     * the more complex variants with loop unrolling that I have tried
+     */
+    for (i=0;i<count;i++)
+    {
+        WaitForSlots(COLOUR_EXPAND_SUBCHANNEL,1);
+        colourExpandChan->method.imageMonochromeFromCpu.monochrome[i%32]=(*(ptr++));
+    }
+    CHECK();
+}
+/*
+ * Subchannel initialization.
+ */
+static void SetupSubChans(void)
+{
+    /* Map subchannels */
+    ropChan=&(chan0->subChannel[ROP_SUBCHANNEL]);
+    rectChan=&(chan0->subChannel[RECT_SUBCHANNEL]);
+    blitChan=&(chan0->subChannel[BLIT_SUBCHANNEL]);
+    clipChan=&(chan0->subChannel[CLIP_SUBCHANNEL]);
+
+#ifdef NV_ENABLE_LINES
+    lineChan=&(chan0->subChannel[LINE_SUBCHANNEL]);
+    linChan=&(chan0->subChannel[LIN_SUBCHANNEL]);
+#endif
+
+    /* Bung the appropriate objects into the subchannels */
+    WaitForSlots(ROP_SUBCHANNEL,1);
+    ropChan->control.object=ROP_OBJECT_ID;
+    WaitForSlots(BLIT_SUBCHANNEL,1);
+    blitChan->control.object=BLIT_OBJECT_ID;
+    WaitForSlots(RECT_SUBCHANNEL,1);
+    rectChan->control.object=RECT_OBJECT_ID;
+    WaitForSlots(CLIP_SUBCHANNEL,1);
+    clipChan->control.object=CLIP_OBJECT_ID;
+    colourExpandChan=&(chan0->subChannel[COLOUR_EXPAND_SUBCHANNEL]);
+    WaitForSlots(COLOUR_EXPAND_SUBCHANNEL,1);
+    colourExpandChan->control.object=COLOUR_EXPAND_OBJECT_ID;
+
+#ifdef NV_ENABLE_LINES
+    lineChan->control.object=LINE_OBJECT_ID;
+    WaitForSlots(LIN_SUBCHANNEL,1);
+    linChan->control.object=LIN_OBJECT_ID;
+#endif
+    CHECK();
+}
+
+
+/* These should really be in a separate file */
+void NV1Sync(void);
+
+int NV1SetupGraphicsEngine(int width,int height,int bpp);
+
+void NVAccelInit(void)
+{
+    int i;
+    int ret;
+
+#ifdef DEBUG
+    if (getenv("NV_NOACCEL")) return;
+#endif
+    ret = NV1SetupGraphicsEngine(vga256InfoRec.virtualX,
+                              vga256InfoRec.virtualY,
+                              vgaBitsPerPixel);
+    if (!ret)
+    {
+        ErrorF("Failed to init graphics engine - no acceleration\n");
+    }
+    switch (vgaBitsPerPixel)
+    {
+        case 8:
+        case 32:
+            colourExpandMask=0xff000000;
+            break;
+        case 15:
+        case 16:
+            colourExpandMask=0xffff8000;
+            break;
+    }
+    CHECK();
+
+    chan0=NvOpenChannel();
+    if (chan0==NULL) return;
+    SetupSubChans();
+    /*
+     * Set up default values.
+     */
+    NVSetRop(3);
+    NVResetClippingRectangle();
+
+    /* There are still some problems with delayed syncing */
+    xf86AccelInfoRec.Flags = BACKGROUND_OPERATIONS/*| DELAYED_SYNC*/;
+    xf86AccelInfoRec.Sync = NV1Sync;
+    /*
+     * Install the low-level functions for drawing solid filled rectangles.
+     */
+    xf86GCInfoRec.PolyFillRectSolidFlags = NO_PLANEMASK | NO_TRANSPARENCY;
+    xf86AccelInfoRec.SetupForFillRectSolid = NVSetupForFillRectSolid;
+    xf86AccelInfoRec.SubsequentFillRectSolid = NVSubsequentFillRectSolid;
+
+    xf86GCInfoRec.CopyAreaFlags = NO_PLANEMASK | NO_TRANSPARENCY;
+    xf86AccelInfoRec.SetupForScreenToScreenCopy = NVSetupForScreenToScreenCopy;
+    xf86AccelInfoRec.SubsequentScreenToScreenCopy = NVSubsequentScreenToScreenCopy;
+#ifdef DEBUG
+    if (getenv("NV_NOCOLOUREXPAND")==NULL)
+#endif
+    /* Colour Expansion */
+    xf86AccelInfoRec.Flags|=NO_SYNC_AFTER_CPU_COLOR_EXPAND |
+                            COP_FRAMEBUFFER_CONCURRENCY;
+
+    xf86AccelInfoRec.ColorExpandFlags = /*NO_TRANSPARENCY | */
+                                        NO_PLANEMASK |
+                                        SCANLINE_PAD_DWORD |
+                                        CPU_TRANSFER_PAD_DWORD |
+                                        BIT_ORDER_IN_BYTE_LSBFIRST |
+                                        VIDEO_SOURCE_GRANULARITY_DWORD;
+
+    xf86AccelInfoRec.ScratchBufferAddr = 1;
+    xf86AccelInfoRec.ScratchBufferSize = 1024;
+    xf86AccelInfoRec.ScratchBufferBase = (void*)scratchBuffer;
+    xf86AccelInfoRec.PingPongBuffers = 1;
+
+    xf86AccelInfoRec.SetupForScanlineScreenToScreenColorExpand =
+    NVSetupForScanlineScreenToScreenColorExpand;
+    xf86AccelInfoRec.SubsequentScanlineScreenToScreenColorExpand =
+    NVSubsequentScanlineScreenToScreenColorExpand;
+#ifdef NV_ENABLE_LINES
+#ifdef DEBUG
+    if (getenv("NV_NOLINES")==NULL)
+#endif
+    {
+        extern int nvMiLineZeroBias;
+
+
+#ifdef DEBUG
+        ErrorF("NV_ZEROBIAS is %s\n",getenv("NV_ZEROBIAS"));
+
+        if (getenv("NV_ZEROBIAS")!=NULL)
+        {
+            nvMiLineZeroBias=atoi((char*)getenv("NV_ZEROBIAS"));
+            ErrorF("Setting bias to %d\n",nvMiLineZeroBias);
+        }
+#endif
+
+        /* Lines and lins */
+        xf86AccelInfoRec.Flags|=HARDWARE_CLIP_LINE|
+                                USE_TWO_POINT_LINE|
+                                TWO_POINT_LINE_NOT_LAST;
+        xf86AccelInfoRec.SubsequentTwoPointLine = NVSubsequentTwoPointLine;
+        xf86AccelInfoRec.SetClippingRectangle =  NVSetClippingRectangle;
+    }
+#endif
+    /*
+     * Finally, we set up the video memory space available to the pixmap
+     * cache. In this case, all memory from the end of the virtual screen
+     * to the end of video memory minus 13K, can be used.
+     */
+#ifdef DEBUG
+    if (getenv("NV_NOPIXMAPCACHE")==NULL)
+#endif
+    {
+        xf86AccelInfoRec.Flags|= PIXMAP_CACHE;
+        xf86InitPixmapCache( &vga256InfoRec,
+                             vga256InfoRec.virtualY * vga256InfoRec.displayWidth *
+                             vga256InfoRec.bitsPerPixel / 8,
+                             (vga256InfoRec.videoRam-65/*(NvKbRamUsedByHW()+1)*/)*1024);
+    }
+}
+
+
Index: xc/programs/Xserver/hw/xfree86/vga256/drivers/nv/nv1cursor.c
diff -u xc/programs/Xserver/hw/xfree86/vga256/drivers/nv/nv1cursor.c:1.1.2.3 xc/programs/Xserver/hw/xfree86/vga256/drivers/nv/nv1cursor.c:1.1.2.4
--- xc/programs/Xserver/hw/xfree86/vga256/drivers/nv/nv1cursor.c:1.1.2.3	Wed Oct 21 20:44:43 1998
+++ xc/programs/Xserver/hw/xfree86/vga256/drivers/nv/nv1cursor.c	Tue Dec 22 18:37:45 1998
@@ -20,7 +20,7 @@
  * SOFTWARE.
  */
 
-/* $XFree86: xc/programs/Xserver/hw/xfree86/vga256/drivers/nv/nv1cursor.c,v 1.1.2.3 1998/10/21 10:44:43 dawes Exp $ */
+/* $XFree86: xc/programs/Xserver/hw/xfree86/vga256/drivers/nv/nv1cursor.c,v 1.1.2.4 1998/12/22 07:37:45 hohndel Exp $ */
 
 #include "X.h"
 #include "Xproto.h"
@@ -33,12 +33,12 @@
 #include "windowstr.h"
 
 #include "compiler.h"
+#include "vga256.h"
 #include "xf86.h"
 #include "mipointer.h"
 #include "xf86Priv.h"
 #include "xf86_Option.h"
 #include "xf86_OSlib.h"
-#include "vga256.h"
 #include "vga.h"
 
 #include "miline.h"
Index: xc/programs/Xserver/hw/xfree86/vga256/drivers/nv/nv3arb.c
diff -u xc/programs/Xserver/hw/xfree86/vga256/drivers/nv/nv3arb.c:1.1.2.3 xc/programs/Xserver/hw/xfree86/vga256/drivers/nv/nv3arb.c:removed
--- xc/programs/Xserver/hw/xfree86/vga256/drivers/nv/nv3arb.c:1.1.2.3	Thu Nov 19 03:38:44 1998
+++ xc/programs/Xserver/hw/xfree86/vga256/drivers/nv/nv3arb.c	Wed Jan  6 00:32:30 1999
@@ -1,476 +0,0 @@
- /***************************************************************************\
-|*                                                                           *|
-|*       Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.      *|
-|*                                                                           *|
-|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
-|*     international laws.  Users and possessors of this source code are     *|
-|*     hereby granted a nonexclusive,  royalty-free copyright license to     *|
-|*     use this code in individual and commercial software.                  *|
-|*                                                                           *|
-|*     Any use of this source code must include,  in the user documenta-     *|
-|*     tion and  internal comments to the code,  notices to the end user     *|
-|*     as follows:                                                           *|
-|*                                                                           *|
-|*       Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.      *|
-|*                                                                           *|
-|*     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY     *|
-|*     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"     *|
-|*     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-     *|
-|*     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,     *|
-|*     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-     *|
-|*     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL     *|
-|*     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-     *|
-|*     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-     *|
-|*     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION     *|
-|*     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF     *|
-|*     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.     *|
-|*                                                                           *|
-|*     U.S. Government  End  Users.   This source code  is a "commercial     *|
-|*     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),     *|
-|*     consisting  of "commercial  computer  software"  and  "commercial     *|
-|*     computer  software  documentation,"  as such  terms  are  used in     *|
-|*     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-     *|
-|*     ment only as  a commercial end item.   Consistent with  48 C.F.R.     *|
-|*     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),     *|
-|*     all U.S. Government End Users  acquire the source code  with only     *|
-|*     those rights set forth herein.                                        *|
-|*                                                                           *|
- \***************************************************************************/
-/* $XFree86: xc/programs/Xserver/hw/xfree86/vga256/drivers/nv/nv3arb.c,v 1.1.2.3 1998/11/18 16:38:44 hohndel Exp $ */
-#include "nv3arb.h"
-#include "nvreg.h"
-static int iterate(fifo_info *res_info, sim_state * state, arb_info *ainfo)
-{
-    int iter = 0;
-    int tmp, t;
-    int vfsize, mfsize, gfsize;
-    int mburst_size = 32;
-    int mmisses, gmisses, vmisses;
-    int misses;
-    int vlwm, glwm, mlwm;
-    int last, next, cur;
-    int max_gfsize ;
-    long ns;
-
-    vlwm = 0;
-    glwm = 0;
-    mlwm = 0;
-    vfsize = 0;
-    gfsize = 0;
-    cur = ainfo->cur;
-    mmisses = 2;
-    gmisses = 2;
-    vmisses = 2;
-    if (ainfo->gburst_size == 128) max_gfsize = 256 ;
-    else  max_gfsize = 320 ;
-    max_gfsize = 320 ;
-    while (1)
-    {
-        if (ainfo->vid_en)
-        {
-            if (ainfo->wcvocc > ainfo->vocc) ainfo->wcvocc = ainfo->vocc;
-            if (ainfo->wcvlwm > vlwm) ainfo->wcvlwm = vlwm ;
-            ns = 1000000 * ainfo->vburst_size/(state->memory_width/8)/state->mclk_khz;
-            vfsize = ns * ainfo->vdrain_rate / 1000000;
-            vfsize =  ainfo->wcvlwm - ainfo->vburst_size + vfsize;
-        }
-        if (state->enable_mp)
-        {
-            if (ainfo->wcmocc > ainfo->mocc) ainfo->wcmocc = ainfo->mocc;
-        }
-        if (ainfo->gr_en)
-        {
-            if (ainfo->wcglwm > glwm) ainfo->wcglwm = glwm ;
-            if (ainfo->wcgocc > ainfo->gocc) ainfo->wcgocc = ainfo->gocc;
-            ns = 1000000 * (ainfo->gburst_size/(state->memory_width/8))/state->mclk_khz;
-            gfsize = ns *ainfo->gdrain_rate/1000000;
-            gfsize = ainfo->wcglwm - ainfo->gburst_size + gfsize;
-        }
-        mfsize = 0;
-        if (!state->gr_during_vid && ainfo->vid_en)
-            if (ainfo->vid_en && (ainfo->vocc < 0) && !ainfo->vid_only_once)
-                next = 0 ;
-            else if (ainfo->mocc < 0)
-                next = 2 ;
-            else if (ainfo->gocc< ainfo->by_gfacc)
-                next = 1 ;
-            else return (0);
-        else switch (ainfo->priority)
-            {
-                case 0 :
-                    if (ainfo->vid_en && ainfo->vocc<0 && !ainfo->vid_only_once)
-                        next = 0 ;
-                    else if (ainfo->gr_en && ainfo->gocc<0 && !ainfo->gr_only_once)
-                        next = 1 ;
-                    else if (ainfo->mocc<0)
-                        next = 2 ;
-                    else    return (0);
-                    break;
-                case 1 :
-                    if (ainfo->gr_en && ainfo->gocc<0 && !ainfo->gr_only_once)
-                        next = 1 ;
-                    else if (ainfo->vid_en && ainfo->vocc<0 && !ainfo->vid_only_once)
-                        next = 0 ;
-                    else if (ainfo->mocc<0)
-                        next = 2 ;
-                    else    return (0);
-                    break;
-                default:
-                    if (ainfo->mocc<0)
-                        next = 2 ;
-                    else if (ainfo->gr_en && ainfo->gocc<0 && !ainfo->gr_only_once)
-                        next = 1 ;
-                    else if (ainfo->vid_en && ainfo->vocc<0 && !ainfo->vid_only_once)
-                        next = 0 ;
-                    else    return (0);
-                    break;
-            }
-        last = cur;
-        cur = next;
-        iter++;
-        switch (cur)
-        {
-            case 0 :
-                if (last==cur)    misses = 0;
-                else if (ainfo->first_vacc)   misses = vmisses;
-                else    misses = 1;
-                ainfo->first_vacc = 0;
-                if (last!=cur)
-                {
-                    ns =  1000000 * (vmisses*state->mem_page_miss + state->mem_latency)/state->mclk_khz; 
-                    vlwm = ns * ainfo->vdrain_rate/ 1000000;
-                    vlwm = ainfo->vocc - vlwm;
-                }
-                ns = 1000000*(misses*state->mem_page_miss + ainfo->vburst_size)/(state->memory_width/8)/state->mclk_khz;
-                ainfo->vocc = ainfo->vocc + ainfo->vburst_size - ns*ainfo->vdrain_rate/1000000;
-                ainfo->gocc = ainfo->gocc - ns*ainfo->gdrain_rate/1000000;
-                ainfo->mocc = ainfo->mocc - ns*ainfo->mdrain_rate/1000000;
-                break;
-            case 1 :
-                if (last==cur)    misses = 0;
-                else if (ainfo->first_gacc)   misses = gmisses;
-                else    misses = 1;
-                ainfo->first_gacc = 0;
-                if (last!=cur)
-                {
-                    ns = 1000000*(gmisses*state->mem_page_miss + state->mem_latency)/state->mclk_khz ;
-                    glwm = ns * ainfo->gdrain_rate/1000000;
-                    glwm = ainfo->gocc - glwm;
-                }
-                ns = 1000000*(misses*state->mem_page_miss + ainfo->gburst_size/(state->memory_width/8))/state->mclk_khz;
-                ainfo->vocc = ainfo->vocc + 0 - ns*ainfo->vdrain_rate/1000000;
-                ainfo->gocc = ainfo->gocc + ainfo->gburst_size - ns*ainfo->gdrain_rate/1000000;
-                ainfo->mocc = ainfo->mocc + 0 - ns*ainfo->mdrain_rate/1000000;
-                break;
-            default:
-                if (last==cur)    misses = 0;
-                else if (ainfo->first_macc)   misses = mmisses;
-                else    misses = 1;
-                ainfo->first_macc = 0;
-                ns = 1000000*(misses*state->mem_page_miss + mburst_size/(state->memory_width/8))/state->mclk_khz;
-                ainfo->vocc = ainfo->vocc + 0 - ns*ainfo->vdrain_rate/1000000;
-                ainfo->gocc = ainfo->gocc + 0 - ns*ainfo->gdrain_rate/1000000;
-                ainfo->mocc = ainfo->mocc + mburst_size - ns*ainfo->mdrain_rate/1000000;
-                break;
-        }
-        if (iter>100)
-        {
-            ainfo->converged = 0;
-            return (1);
-        }
-        ns = 1000000*ainfo->gburst_size/(state->memory_width/8)/state->mclk_khz;
-        tmp = ns * ainfo->gdrain_rate/1000000;
-        if (( ainfo->gburst_size >0? ainfo->gburst_size :- ainfo->gburst_size )  + ((( ainfo->wcglwm >0? ainfo->wcglwm :- ainfo->wcglwm )  + 16 ) & ~0x7)    - tmp > max_gfsize)
-        {
-            ainfo->converged = 0;
-            return (1);
-        }
-        ns = 1000000*ainfo->vburst_size/(state->memory_width/8)/state->mclk_khz;
-        tmp = ns * ainfo->vdrain_rate/1000000;
-        if (( ainfo->vburst_size >0? ainfo->vburst_size :- ainfo->vburst_size )  + (( ainfo->wcvlwm + 32 >0? ainfo->wcvlwm + 32 :- ainfo->wcvlwm + 32 )  & ~0xf)  - tmp> 256 )
-        {
-            ainfo->converged = 0;
-            return (1);
-        }
-        if (( ainfo->gocc >0? ainfo->gocc :- ainfo->gocc )  > max_gfsize)
-        {
-            ainfo->converged = 0;
-            return (1);
-        }
-        if (( ainfo->vocc >0? ainfo->vocc :- ainfo->vocc )  > 256 )
-        {
-            ainfo->converged = 0;
-            return (1);
-        }
-        if (( ainfo->mocc >0? ainfo->mocc :- ainfo->mocc )  > 120 )
-        {
-            ainfo->converged = 0;
-            return (1);
-        }
-        if (( vfsize >0? vfsize :- vfsize )  > 256 )
-        {
-            ainfo->converged = 0;
-            return (1);
-        }
-        if (( gfsize >0? gfsize :- gfsize )  > max_gfsize)
-        {
-            ainfo->converged = 0;
-            return (1);
-        }
-        if (( mfsize >0? mfsize :- mfsize )  > 120 )
-        {
-            ainfo->converged = 0;
-            return (1);
-        }
-    }
-}
-static char arb(fifo_info * res_info, sim_state * state,  arb_info *ainfo) 
-{
-    int  g, v, not_done;
-    long ens, vns, mns, gns;
-    int mmisses, gmisses, vmisses, eburst_size, mburst_size;
-    int refresh_cycle;
-
-    refresh_cycle = 0;
-    refresh_cycle = 2*(state->mclk_khz/state->pclk_khz) + 5;
-    mmisses = 2;
-    if (state->mem_aligned) gmisses = 2;
-    else    gmisses = 3;
-    vmisses = 2;
-    eburst_size = state->memory_width * 1;
-    mburst_size = 32;
-    gns = 1000000 * (gmisses*state->mem_page_miss + state->mem_latency)/state->mclk_khz;
-    ainfo -> by_gfacc = gns*ainfo->gdrain_rate/1000000;
-    ainfo -> wcmocc = 0;
-    ainfo -> wcgocc = 0;
-    ainfo -> wcvocc = 0;
-    ainfo -> wcvlwm = 0;
-    ainfo -> wcglwm = 0;
-    ainfo -> engine_en = 1;
-    ainfo -> converged = 1;
-    if (ainfo->engine_en)
-    {
-        ens =  1000000*(state->mem_page_miss + eburst_size/(state->memory_width/8) +refresh_cycle)/state->mclk_khz;
-        ainfo -> mocc = state->enable_mp ? 0-ens*ainfo->mdrain_rate/1000000 : 0;
-        ainfo -> vocc = ainfo->vid_en ? 0-ens*ainfo->vdrain_rate/1000000 : 0;
-        ainfo -> gocc = ainfo->gr_en ? 0-ens*ainfo->gdrain_rate/1000000 : 0;
-        ainfo -> cur = 3 ;
-        ainfo -> first_vacc = 1;
-        ainfo -> first_gacc = 1;
-        ainfo -> first_macc = 1;
-        iterate(res_info, state,ainfo);
-    }
-    if (state->enable_mp)
-    {
-        mns = 1000000 * (mmisses*state->mem_page_miss + mburst_size/(state->memory_width/8) + refresh_cycle)/state->mclk_khz;
-        ainfo -> mocc = state->enable_mp ? 0 : mburst_size - mns*ainfo->mdrain_rate/1000000;
-        ainfo -> vocc = ainfo->vid_en ? 0 : 0- mns*ainfo->vdrain_rate/1000000;
-        ainfo -> gocc = ainfo->gr_en ? 0: 0- mns*ainfo->gdrain_rate/1000000;
-        ainfo -> cur = 2 ;
-        ainfo -> first_vacc = 1;
-        ainfo -> first_gacc = 1;
-        ainfo -> first_macc = 0;
-        iterate(res_info, state,ainfo);
-    }
-    if (ainfo->gr_en)
-    {
-        ainfo->first_vacc = 1;
-        ainfo->first_gacc = 0;
-        ainfo->first_macc = 1;
-        gns = 1000000*(gmisses*state->mem_page_miss + ainfo->gburst_size/(state->memory_width/8) + refresh_cycle)/state->mclk_khz;
-        ainfo->gocc = ainfo->gburst_size - gns*ainfo->gdrain_rate/1000000;
-        ainfo->vocc = ainfo->vid_en? 0-gns*ainfo->vdrain_rate/1000000 : 0;
-        ainfo->mocc = state->enable_mp ?  0-gns*ainfo->mdrain_rate/1000000: 0;
-        ainfo->cur = 1 ;
-        iterate(res_info, state,ainfo);
-    }
-    if (ainfo->vid_en)
-    {
-        ainfo->first_vacc = 0;
-        ainfo->first_gacc = 1;
-        ainfo->first_macc = 1;
-        vns = 1000000*(vmisses*state->mem_page_miss + ainfo->vburst_size/(state->memory_width/8) + refresh_cycle)/state->mclk_khz;
-        ainfo->vocc = ainfo->vburst_size - vns*ainfo->vdrain_rate/1000000;
-        ainfo->gocc = ainfo->gr_en? (0-vns*ainfo->gdrain_rate/1000000) : 0;
-        ainfo->mocc = state->enable_mp? 0-vns*ainfo->mdrain_rate/1000000 :0 ;
-        ainfo->cur = 0 ;
-        iterate(res_info, state, ainfo);
-    }
-    if (ainfo->converged)
-    {
-        res_info->graphics_lwm = (int)( ainfo->wcglwm >0? ainfo->wcglwm :- ainfo->wcglwm )  + 16;
-        res_info->video_lwm = (int)( ainfo->wcvlwm >0? ainfo->wcvlwm :- ainfo->wcvlwm )  + 32;
-        res_info->graphics_burst_size = ainfo->gburst_size;
-        res_info->video_burst_size = ainfo->vburst_size;
-        res_info->graphics_hi_priority = (ainfo->priority == 1 );
-        res_info->media_hi_priority = (ainfo->priority == 2 );
-        if (res_info->video_lwm > 160)
-        {
-            res_info->graphics_lwm = 256;
-            res_info->video_lwm = 128;
-            res_info->graphics_burst_size = 64;
-            res_info->video_burst_size = 64;
-            res_info->graphics_hi_priority = 0;
-            res_info->media_hi_priority = 0;
-            ainfo->converged = 0;
-            return (0);
-        }
-        if (res_info->video_lwm > 128)
-        {
-            res_info->video_lwm = 128;
-        }
-        return (1);
-    }
-    else
-    {
-        res_info->graphics_lwm = 256;
-        res_info->video_lwm = 128;
-        res_info->graphics_burst_size = 64;
-        res_info->video_burst_size = 64;
-        res_info->graphics_hi_priority = 0;
-        res_info->media_hi_priority = 0;
-        return (0);
-    }
-}
-static char get_param(fifo_info *res_info, sim_state * state, arb_info *ainfo)
-{
-    int done, g,v, p;
-    int priority, gburst_size, vburst_size, iter;
-    
-    done = 0;
-    if (state->gr_during_vid && ainfo->vid_en)
-        ainfo->priority = 2 ;
-    else
-        ainfo->priority = ainfo->gdrain_rate < ainfo->vdrain_rate ? 0 : 1 ;
-    for (p=0; p < 2 && done != 1; p++)
-    {
-        for (g=128 ; (g > 32) && (done != 1); g= g>> 1)
-        {
-            for (v=128; (v >=32) && (done !=1); v = v>> 1)
-            {
-                ainfo->priority = p;
-                ainfo->gburst_size = g;     
-                ainfo->vburst_size = v;
-                done = arb(res_info, state,ainfo);
-                if (g==128)
-                {
-                    if ((res_info->graphics_lwm + g) > 256)
-                        done = 0;
-                }
-            }
-        }
-    }
-    if (!done)
-        return (0);
-    else
-        return (1);
-}
-static void CalcArbitration 
-(
-    fifo_info * res_info,
-    sim_state * state
-)
-{
-    fifo_info save_info;
-    arb_info ainfo;
-    char   res_gr, res_vid;
-
-    ainfo.gr_en = 1;
-    ainfo.vid_en = state->enable_video;
-    ainfo.vid_only_once = 0;
-    ainfo.gr_only_once = 0;
-    ainfo.gdrain_rate = (int) state->pclk_khz * state -> pix_bpp/8;
-    ainfo.vdrain_rate = (int) state->pclk_khz * 2;
-    if (state->video_scale != 0)
-        ainfo.vdrain_rate = ainfo.vdrain_rate/state->video_scale;
-    ainfo.mdrain_rate = 33000;
-    res_info->rtl_values = 0;
-    if (!state->gr_during_vid && state->enable_video)
-    {
-        ainfo.gr_only_once = 1;
-        ainfo.gr_en = 1;
-        ainfo.gdrain_rate = 0;
-        res_vid = get_param(res_info, state,  &ainfo);
-        res_vid = ainfo.converged;
-        save_info.video_lwm = res_info->video_lwm;
-        save_info.video_burst_size = res_info->video_burst_size;
-        ainfo.vid_en = 1;
-        ainfo.vid_only_once = 1;
-        ainfo.gr_en = 1;
-        ainfo.gdrain_rate = (int) state->pclk_khz * state -> pix_bpp/8;
-        ainfo.vdrain_rate = 0;
-        res_gr = get_param(res_info, state,  &ainfo);
-        res_gr = ainfo.converged;
-        res_info->video_lwm = save_info.video_lwm;
-        res_info->video_burst_size = save_info.video_burst_size;
-        res_info->valid = res_gr & res_vid;
-    }
-    else
-    {
-        if (!ainfo.gr_en) ainfo.gdrain_rate = 0;
-        if (!ainfo.vid_en) ainfo.vdrain_rate = 0;
-        res_gr = get_param(res_info, state,  &ainfo);
-        res_info->valid = ainfo.converged;
-    }
-}
-void nv3UpdateArbitrationSettings
-(
-    unsigned int   VClk, 
-    unsigned int   pixelDepth, 
-    unsigned int   crystal,
-    unsigned char *lwm,
-    unsigned char *burst
-)
-{
-    fifo_info fifo_data;
-    sim_state sim_data;
-    unsigned int M, N, P, pll, MClk, cfg1;
-    
-    pll = nvPRAMDACPort[((0x00680504    )- (0?0x00680FFF:0x00680000    ) )/4]   ;
-    M = (pll >> 0)  & 0xFF;
-    N = (pll >> 8)  & 0xFF;
-    P = (pll >> 16) & 0x0F;
-    MClk  = (N * crystal / M) >> P;
-    cfg1 = nvPFBPort[((0x00100204    )- (0?0x00100FFF:0x00100000    ) )/4]   ;
-    sim_data.pix_bpp        = (char)pixelDepth;
-    sim_data.enable_video   = 0;
-    sim_data.enable_mp      = 0;
-    sim_data.video_scale    = 1;
-    sim_data.memory_width   = (nvPEXTDEVPort[((0x00101000    )- (0?0x00101FFF:0x00101000    ) )/4]    & 0x10) ? 128 : 64;
-    sim_data.mem_latency    = 11 ;
-    sim_data.mem_aligned    = 1;
-    sim_data.mem_page_miss  = 9 ;
-    sim_data.gr_during_vid  = 0;
-    sim_data.pclk_khz       = VClk;
-    sim_data.mclk_khz       = MClk;
-    CalcArbitration(&fifo_data, &sim_data);
-    if (fifo_data.valid)
-    {
-        *lwm = fifo_data.graphics_lwm >> 3;
-        switch (fifo_data.graphics_burst_size)
-        {
-            case 256:
-                *burst = 4;
-                 
-                break;
-            case 128:
-                *burst = 3;
-                break;
-            case 64:
-                *burst = 2;
-                break;
-            case 32:
-                *burst = 1;
-                break;
-            case 16:
-                *burst = 0;
-                break;
-        }
-    }
-    else
-    {
-        *lwm   = 0x24;
-        *burst = 0x02;
-    }
-}
-
Index: xc/programs/Xserver/hw/xfree86/vga256/drivers/nv/nv3arb.h
diff -u xc/programs/Xserver/hw/xfree86/vga256/drivers/nv/nv3arb.h:1.1.2.2 xc/programs/Xserver/hw/xfree86/vga256/drivers/nv/nv3arb.h:removed
--- xc/programs/Xserver/hw/xfree86/vga256/drivers/nv/nv3arb.h:1.1.2.2	Tue Oct 20 06:57:08 1998
+++ xc/programs/Xserver/hw/xfree86/vga256/drivers/nv/nv3arb.h	Wed Jan  6 00:32:30 1999
@@ -1,105 +0,0 @@
- /***************************************************************************\
-|*                                                                           *|
-|*       Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.      *|
-|*                                                                           *|
-|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
-|*     international laws.  Users and possessors of this source code are     *|
-|*     hereby granted a nonexclusive,  royalty-free copyright license to     *|
-|*     use this code in individual and commercial software.                  *|
-|*                                                                           *|
-|*     Any use of this source code must include,  in the user documenta-     *|
-|*     tion and  internal comments to the code,  notices to the end user     *|
-|*     as follows:                                                           *|
-|*                                                                           *|
-|*       Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.      *|
-|*                                                                           *|
-|*     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY     *|
-|*     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"     *|
-|*     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-     *|
-|*     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,     *|
-|*     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-     *|
-|*     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL     *|
-|*     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-     *|
-|*     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-     *|
-|*     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION     *|
-|*     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF     *|
-|*     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.     *|
-|*                                                                           *|
-|*     U.S. Government  End  Users.   This source code  is a "commercial     *|
-|*     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),     *|
-|*     consisting  of "commercial  computer  software"  and  "commercial     *|
-|*     computer  software  documentation,"  as such  terms  are  used in     *|
-|*     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-     *|
-|*     ment only as  a commercial end item.   Consistent with  48 C.F.R.     *|
-|*     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),     *|
-|*     all U.S. Government End Users  acquire the source code  with only     *|
-|*     those rights set forth herein.                                        *|
-|*                                                                           *|
- \***************************************************************************/
-/* $XFree86: xc/programs/Xserver/hw/xfree86/vga256/drivers/nv/nv3arb.h,v 1.1.2.2 1998/10/19 20:57:08 hohndel Exp $ */
-#ifndef _ARB_FIFO_H
-#define _ARB_FIFO_H
-#define DEFAULT_GR_LWM 100
-#define DEFAULT_VID_LWM 100
-#define DEFAULT_GR_BURST_SIZE 256
-#define DEFAULT_VID_BURST_SIZE 128
-typedef struct {
-  int gdrain_rate;
-  int vdrain_rate;
-  int mdrain_rate;
-  int gburst_size;
-  int vburst_size;
-  char vid_en;
-  char gr_en;
-  int wcmocc, wcgocc, wcvocc, wcvlwm, wcglwm;
-  int by_gfacc;
-  char vid_only_once;
-  char gr_only_once;
-  char first_vacc;
-  char first_gacc;
-  char first_macc;
-  int vocc;
-  int gocc;
-  int mocc;
-  char cur;
-  char engine_en;
-  char converged;
-  int priority;
-} arb_info;
-typedef struct {
-  int graphics_lwm;
-  int video_lwm;
-  int graphics_burst_size;
-  int video_burst_size;
-  int graphics_hi_priority;
-  int media_hi_priority;
-  int rtl_values;
-  int valid;
-} fifo_info;
-typedef struct {
-  int pix_bpp;
-  char enable_video;
-  char gr_during_vid;
-  char enable_mp;
-  int memory_width;
-  int video_scale;
-  long pclk_khz;
-  long mclk_khz;
-  int mem_page_miss;
-  int mem_latency;
-  char mem_aligned;
-} sim_state;
-#define VIDEO		0
-#define GRAPHICS	1
-#define MPORT		2
-#define ENGINE		3
-#define GFIFO_SIZE	320
-#define GFIFO_SIZE_128	256
-#define MFIFO_SIZE	120
-#define VFIFO_SIZE	256
-#ifndef ABS
-#define	ABS(a)	(a>0?a:-a)
-#endif
-void nv3UpdateArbitrationSettings(unsigned int, unsigned int, unsigned int, unsigned char *, unsigned char *);
-#endif
-
Index: xc/programs/Xserver/hw/xfree86/vga256/drivers/nv/nv3cursor.c
diff -u xc/programs/Xserver/hw/xfree86/vga256/drivers/nv/nv3cursor.c:1.1.2.5 xc/programs/Xserver/hw/xfree86/vga256/drivers/nv/nv3cursor.c:removed
--- xc/programs/Xserver/hw/xfree86/vga256/drivers/nv/nv3cursor.c:1.1.2.5	Thu Nov 19 03:38:44 1998
+++ xc/programs/Xserver/hw/xfree86/vga256/drivers/nv/nv3cursor.c	Wed Jan  6 00:32:31 1999
@@ -1,422 +0,0 @@
-/*
- * Copyright 1996-1997  David J. McKay
- *
- * Permission is hereby granted, free of charge, to any person obtaining a 
- * copy of this software and associated documentation files (the "Software"), 
- * to deal in the Software without restriction, including without limitation 
- * the rights to use, copy, modify, merge, publish, distribute, sublicense, 
- * and/or sell copies of the Software, and to permit persons to whom the 
- * Software is furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- * 
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL 
- * DAVID J. MCKAY BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, 
- * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF 
- * OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE 
- * SOFTWARE.
- */
-
-/* $XFree86: xc/programs/Xserver/hw/xfree86/vga256/drivers/nv/nv3cursor.c,v 1.1.2.5 1998/11/18 16:38:44 hohndel Exp $ */
-
-#include "X.h"
-#include "Xproto.h"
-#include "misc.h"
-#include "input.h"
-#include "cursorstr.h"
-#include "regionstr.h"
-#include "scrnintstr.h"
-#include "servermd.h"
-#include "windowstr.h"
-
-#include "compiler.h"
-#include "xf86.h"
-#include "mipointer.h"
-#include "xf86Priv.h"
-#include "xf86_Option.h"
-#include "xf86_OSlib.h"
-#include "vga256.h"
-#include "vga.h"
-
-#include "miline.h"
-
-#include "nvreg.h"
-#include "nvcursor.h"
-
-
-static Bool NV3RealizeCursor();
-static Bool NV3UnrealizeCursor();
-static void NV3SetCursor();
-static void NV3MoveCursor();
-static void NV3RecolorCursor();
-
-static miPointerSpriteFuncRec NV3PointerSpriteFuncs =
-{
-  NV3RealizeCursor,
-  NV3UnrealizeCursor,
-  NV3SetCursor,
-  NV3MoveCursor,
-};
-
- 
-
-
-extern miPointerScreenFuncRec xf86PointerScreenFuncs;
-extern xf86InfoRec xf86Info;
-
-static int NV3CursorGeneration = -1;
-
- 
-
-
-
-
-static int NV3CursorHotX;
-static int NV3CursorHotY;
-static CursorPtr NV3CursorpCurs;
-
-
- 
-
-
-
-
-
-Bool NV3CursorInit(char *pm,ScreenPtr pScr)
-{
-  unsigned char power;
-
-  NV3CursorHotX = 0;
-  NV3CursorHotY = 0;
-
-
-  if(NV3CursorGeneration != serverGeneration) {
-    if(!(miPointerInitialize(pScr, &NV3PointerSpriteFuncs,
-			     &xf86PointerScreenFuncs, 0 ))) {
-      return 0 ;
-    }
-    pScr->RecolorCursor = NV3RecolorCursor;
-    NV3CursorGeneration = serverGeneration;
-  }
-  return 1 ;
-}
-
- 
-
-
-
-
-static void NV3ShowCursor(void)
-{
-  unsigned char tmp;
-  tmp = (outb(980, 49   ),inb(981))  |1| (( 1    ) << (0))   ;
-  outb(980,( 49   ));outb(981,  tmp  )  ;
-}
-
- 
-
-
-
-void NV3HideCursor(void)
-{
-  unsigned char tmp;
-  tmp = (outb(980, 49   ),inb(981))  &(~(( 1    ) << (0))   );
-  outb(980,( 49   ));outb(981,  tmp  )  ;
-}
-
- 
-
-
-
-
-
-
-
-
- 
-
-
-
-
-
-typedef struct {
-  unsigned short foreColour,  
-                 backColour;
-  unsigned short image[32 * 32 ];  
-  int address;  
-}NV3Cursor;
-  
-  
-static unsigned short ConvertToRGB555(int red,int green,int blue)
-{
-  unsigned short colour;
-
-  colour=((red>>11)&31)<<10;
-  colour|=((green>>11)&31)<<5;
-  colour|=((blue>>11)&31);
-  colour|=1<<15;  
-
-  return colour;
-}
-
-static void RenderCursor(CursorBits *bits,NV3Cursor *cursor)
-{
-  int x,y,i;
-  int byteIndex,bitIndex,maskBit,sourceBit;
-  int height,width;
-  int pad,lineOffset;
-  unsigned char *source,*mask;
-
-  height = bits->height;
-  width=bits->width;
-  source=(unsigned char*)bits->source;
-  pad= ((PixmapWidthPaddingInfo[    1  ].notPower2 ? (((int)(  bits->width  ) * PixmapWidthPaddingInfo[    1  ].bytesPerPixel + PixmapWidthPaddingInfo[    1  ].bytesPerPixel) >> PixmapWidthPaddingInfo[    1  ].padBytesLog2) : ((int)((  bits->width  ) + PixmapWidthPaddingInfo[    1  ].padRoundUp) >> PixmapWidthPaddingInfo[    1  ].padPixelsLog2))  << PixmapWidthPaddingInfo[  1 ].padBytesLog2) ; 
-  mask=(unsigned char*)bits->mask;
-  for(y=0,i=0,lineOffset=0;y< 32 ;y++,lineOffset+=pad) {
-    for(x=0;x< 32 ;x++,i++) {
-      if(x<width && y<height) {
-        byteIndex=lineOffset+(x/8);bitIndex=x%8;
-        maskBit=mask[byteIndex]&(1<<bitIndex);
-        sourceBit=source[byteIndex]&(1<<bitIndex);
-        if(maskBit) {
-	  cursor->image[i]=(sourceBit) ? cursor->foreColour :
-                                         cursor->backColour;
-	}else {
-          cursor->image[i]= 0 ;
-	}        
-      }else {
-        cursor->image[i]= 0 ;
-      }
-    }
-  }
-}
-
-static Bool NV3RealizeCursor(ScreenPtr pScr,CursorPtr pCurs)
-{
-  NV3Cursor *ram;
-  int index = pScr->myNum;
-  pointer *pPriv = &pCurs->bits->devPriv[index];
-  CursorBits *bits = pCurs->bits;
-
-   
-  if(pCurs->bits->refcnt > 1) return 1 ;
-
-  ram = (NV3Cursor*)Xalloc((unsigned long)( sizeof(NV3Cursor) )) ;
-  *pPriv = (pointer) ram;
-  if(!ram) return 0 ;
-
-  ram->foreColour=
-     ConvertToRGB555(pCurs->foreRed,pCurs->foreGreen,pCurs->foreBlue);
-  ram->backColour=
-     ConvertToRGB555(pCurs->backRed,pCurs->backGreen,pCurs->backBlue);
-  
-  RenderCursor(bits,ram);
-
-  return 1 ;
-}
-
- 
-
-
-
-
-static Bool NV3UnrealizeCursor(ScreenPtr pScr,CursorPtr pCurs)
-{
-  pointer priv;
-
-  if(pCurs->bits->refcnt <= 1 &&
-      (priv = pCurs->bits->devPriv[pScr->myNum])) {
-    Xfree((pointer)( priv )) ;
-    pCurs->bits->devPriv[pScr->myNum] = 0;
-  }
-  return 1 ;
-}
-
- 
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-static void NV3LoadCursorToCard(ScreenPtr pScr,CursorPtr pCurs)
-{
-  NV3Cursor *cursor;
-  int index = pScr->myNum;
-  int i;
-  int numInts;
-  int *image;
-  int save;
-
-  if(!xf86VTSema)
-    return;
-
-  cursor=(NV3Cursor*) pCurs->bits->devPriv[index];
-  numInts=sizeof(cursor->image)/sizeof(int);
-  image=(int*)cursor->image;
-
-  save= (outb(980, 49   ),inb(981))  ;
-
-  outb(980,( 49   ));outb(981,  0  )  ;
-
-   
-  for(i=0;i<numInts;i++) {
-    nvPRAMINPort[ ((8192-2048)/4) +i ]=( image[i] ) ;
-  }
-   
-  outb(980,( 48   ));outb(981,  (( (((unsigned)((  ((8192-2048)/4) *4  ) & (((unsigned)(1U << ((( 21)-( 16)+1)))-1)  << ( 16))  )) >> (16) )  ) << (0))    )  ;
-  save&=7;
-  outb(980,( 49   ));outb(981,  save| (( (((unsigned)((  ((8192-2048)/4) *4  ) & (((unsigned)(1U << ((( 15)-( 11)+1)))-1)  << ( 11))  )) >> (11) )  ) << (3))    )  ;
-  
-
-}
-
- 
-
-
-
-
-
-
-
-
-static void NV3LoadCursor(ScreenPtr pScr,CursorPtr pCurs,int x,int y)
-{
- 
-  if(!xf86VTSema)
-    return;
-
-  if(!pCurs)
-    return;
-
-   
-  NV3CursorpCurs = pCurs;
-
-  NV3HideCursor();
-
-  NV3LoadCursorToCard(pScr, pCurs);
-
-   
-  NV3MoveCursor(pScr, x, y);
-
-   
-  NV3ShowCursor();
-}
-
- 
-
-
-
-static void NV3SetCursor(ScreenPtr pScr,CursorPtr pCurs,int x,int y,
-                        Bool generateEvent)
-{
-  if(!pCurs)
-    return;
-
-  NV3CursorHotX = pCurs->bits->xhot;
-  NV3CursorHotY = pCurs->bits->yhot;
-
-  NV3LoadCursor(pScr, pCurs, x, y);
-}
-
- 
-
-
-
-
-void NV3RestoreCursor(ScreenPtr pScr)
-{
-  int x, y;
-
-  miPointerPosition(&x, &y);
-
-  NV3LoadCursor(pScr, NV3CursorpCurs, x, y);
-}
-
- 
-
-
-
-
-static void NV3MoveCursor(ScreenPtr pScr,int x,int y)
-{
-  int xorigin, yorigin;
-
-  if(!xf86VTSema) return;
-
-  x -= vga256InfoRec.frameX0 + NV3CursorHotX;
-  y -= vga256InfoRec.frameY0 + NV3CursorHotY;
-  x&= (((unsigned)(1U << ((( 11)-( 0)+1)))-1)  << ( 0))    ;
-  nvPRAMDACPort[((6816512    )- (6815744) )/4] =(  ((   x   ) << (0))   |
-                                   ((   y   ) << (16))     )  ;
-}
-
- 
-
-
-
-
-
-static void NV3RecolorCursor(ScreenPtr pScr,CursorPtr pCurs,Bool displayed)
-{
-  CursorBits *bits = pCurs->bits;
-  int index = pScr->myNum;
-  NV3Cursor *cursor=(NV3Cursor*) pCurs->bits->devPriv[index];
-  unsigned short fore,back;
-
-  if(!xf86VTSema) return;
-
-  if(!displayed) return;
-
-  fore=ConvertToRGB555(pCurs->foreRed,pCurs->foreGreen,pCurs->foreBlue);
-  back=ConvertToRGB555(pCurs->backRed,pCurs->backGreen,pCurs->backBlue);
-
-  if(cursor->foreColour==fore && cursor->backColour==back) return;
-  
-  NV3LoadCursorToCard(pScr,pCurs);
-
-}
-
- 
-
-
-
-
-void NV3WarpCursor(ScreenPtr pScr,int x,int y)
-{
-  miPointerWarpCursor(pScr, x, y);
-  xf86Info.currentScreen = pScr;
-}
-
- 
-
-
-
-
-
-void NV3QueryBestSize(int class,unsigned short *pwidth, 
-                     unsigned short *pheight,ScreenPtr pScreen)
-{
-  if(*pwidth > 0) {
-    if(class == 0 ) {
-      *pwidth = 32 ;
-      *pheight = 32 ;
-    } else
-      (void)mfbQueryBestSize(class, pwidth, pheight, pScreen);
-  }
-}
-
Index: xc/programs/Xserver/hw/xfree86/vga256/drivers/nv/nv3driver.c
diff -u xc/programs/Xserver/hw/xfree86/vga256/drivers/nv/nv3driver.c:1.1.2.6 xc/programs/Xserver/hw/xfree86/vga256/drivers/nv/nv3driver.c:removed
--- xc/programs/Xserver/hw/xfree86/vga256/drivers/nv/nv3driver.c:1.1.2.6	Thu Nov 19 03:38:45 1998
+++ xc/programs/Xserver/hw/xfree86/vga256/drivers/nv/nv3driver.c	Wed Jan  6 00:32:31 1999
@@ -1,599 +0,0 @@
-/*
- * Copyright 1996-1997  David J. McKay
- *
- * Permission is hereby granted, free of charge, to any person obtaining a 
- * copy of this software and associated documentation files (the "Software"), 
- * to deal in the Software without restriction, including without limitation 
- * the rights to use, copy, modify, merge, publish, distribute, sublicense, 
- * and/or sell copies of the Software, and to permit persons to whom the 
- * Software is furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- * 
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL 
- * DAVID J. MCKAY BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, 
- * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF 
- * OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE 
- * SOFTWARE.
- */
-
-/* $XFree86: xc/programs/Xserver/hw/xfree86/vga256/drivers/nv/nv3driver.c,v 1.1.2.6 1998/11/18 16:38:45 hohndel Exp $ */
- /***************************************************************************\
-|*                                                                           *|
-|*       Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.      *|
-|*                                                                           *|
-|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
-|*     international laws.  Users and possessors of this source code are     *|
-|*     hereby granted a nonexclusive,  royalty-free copyright license to     *|
-|*     use this code in individual and commercial software.                  *|
-|*                                                                           *|
-|*     Any use of this source code must include,  in the user documenta-     *|
-|*     tion and  internal comments to the code,  notices to the end user     *|
-|*     as follows:                                                           *|
-|*                                                                           *|
-|*       Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.      *|
-|*                                                                           *|
-|*     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY     *|
-|*     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"     *|
-|*     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-     *|
-|*     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,     *|
-|*     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-     *|
-|*     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL     *|
-|*     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-     *|
-|*     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-     *|
-|*     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION     *|
-|*     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF     *|
-|*     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.     *|
-|*                                                                           *|
-|*     U.S. Government  End  Users.   This source code  is a "commercial     *|
-|*     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),     *|
-|*     consisting  of "commercial  computer  software"  and  "commercial     *|
-|*     computer  software  documentation,"  as such  terms  are  used in     *|
-|*     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-     *|
-|*     ment only as  a commercial end item.   Consistent with  48 C.F.R.     *|
-|*     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),     *|
-|*     all U.S. Government End Users  acquire the source code  with only     *|
-|*     those rights set forth herein.                                        *|
-|*                                                                           *|
- \***************************************************************************/
-
-#include <math.h>
-#include <stdlib.h>
-
-
-#include "X.h"
-#include "input.h"
-#include "screenint.h"
-
-#include "compiler.h"
-#include "xf86.h"
-#include "xf86Priv.h"
-#include "xf86_OSlib.h"
-#include "xf86_HWlib.h"
-#include "vga.h"
-
-#include "vgaPCI.h"
-
-#define XCONFIG_FLAGS_ONLY
-#include "xf86_Config.h"
-
-
-#ifdef XFreeXDGA
-#include "X.h"
-#include "Xproto.h"
-#include "scrnintstr.h"
-#include "servermd.h"
-#define _XF86DGA_SERVER_
-#include "extensions/xf86dgastr.h"
-#endif
-
-#include "nvcursor.h"
-#include "nvreg.h"
-
-
-#include "nvvga.h"
-
-static unsigned ramType, crystalFreq;
-
-void NV3EnterLeave(Bool enter)
-{
-   unsigned char temp;
-
-  if(enter) {
-    xf86EnableIOPorts(vga256InfoRec.scrnIndex);
-    outb(vgaIOBase + 4, 17); temp = inb(vgaIOBase + 5);
-    outb(vgaIOBase + 5, temp & 127); 
-    outb(964,( 6  ));outb(965, 87  ) ;
-  }else {
-    outb(vgaIOBase + 4, 17); temp = inb(vgaIOBase + 5);
-    outb(vgaIOBase + 5, (temp & 127) | 128);
-    outb(964,( 6  ));outb(965, 153  ) ;
-    xf86DisableIOPorts(vga256InfoRec.scrnIndex);
-  }
-}
-
-
-
-
-
-
-
-
-static void MapNV3Regs(void *regBase,void *frameBase)
-{
-  nvPRAMDACPort=(unsigned*)xf86MapVidMem(vga256InfoRec.scrnIndex, 3 , ((char*)( regBase ))+ (6815744) , ((6819839) - (6815744) +1) ) ;
-  nvPFBPort=(unsigned*)xf86MapVidMem(vga256InfoRec.scrnIndex, 3 , ((char*)( regBase ))+ (1048576) , ((1052671) - (1048576) +1) ) ;
-  nvPFIFOPort=(unsigned*)xf86MapVidMem(vga256InfoRec.scrnIndex, 3 , ((char*)( regBase ))+ (8192) , ((16383) - (8192) +1) ) ;
-  nvPGRAPHPort=(unsigned*)xf86MapVidMem(vga256InfoRec.scrnIndex, 3 , ((char*)( regBase ))+ (4194304) , ((4202495) - (4194304) +1) ) ;
-  nvPTIMERPort=(unsigned*)xf86MapVidMem(vga256InfoRec.scrnIndex, 3 , ((char*)( regBase ))+ (36864) , ((40959) - (36864) +1) ) ;
-  nvPEXTDEVPort=(unsigned*)xf86MapVidMem(vga256InfoRec.scrnIndex, 3 , ((char*)( regBase ))+ (1052672) , ((1056767) - (1052672) +1) ) ;
-  nvPMCPort=(unsigned*)xf86MapVidMem(vga256InfoRec.scrnIndex, 3 , ((char*)( regBase ))+ (0) , ((4095) - (0) +1) ) ;
-  nvCHAN0Port=(unsigned*)xf86MapVidMem(vga256InfoRec.scrnIndex, 3 , ((char*)( regBase ))+ (8388608) , ((8454143) - (8388608) +1) ) ;
-  nvPRAMINPort=(unsigned*)xf86MapVidMem(vga256InfoRec.scrnIndex, 3 , ((char*)( frameBase ))+ (12582912) , ((16777215) - (12582912) +1) ) ;
-}
-
-
-
-static void NV3FlipFunctions(vgaVideoChipRec *nv);
-
-int NV3Probe(vgaVideoChipRec *nv,void *base0,void *base1)
-{
-  int boot0, chipRev, chipSubrev;
-  int noaccel= (( &vga256InfoRec.options )->flag_bits[( 60  )/ (8 * sizeof(CARD32)) ] & (1 << (( 60  )% (8 * sizeof(CARD32)) ))) ;
-
-  MapNV3Regs(base0,base1);
-
-   
-  boot0      = nvPFBPort[((1048576    )- (1048576) )/4]   ;
-  chipRev    = nvPMCPort[((0    )- (0) )/4]    & 240;
-  chipSubrev = nvPMCPort[((0    )- (0) )/4]    & 15;
-  crystalFreq= (nvPEXTDEVPort[((1052672    )- (1052672) )/4]    & (( 1    ) << (6))   ) ? 14318 : 13500;
-
-  if (boot0 & (( 1    ) << (5))   )
-  {
-      if ((chipRev == 32 ) && (chipSubrev >= 2 ))
-      {        
-          ramType = 1 ;
-          switch (boot0 & 3)
-          {
-              case 0 :
-              case 3 :
-                  vga256InfoRec.videoRam = 1024 * 8;
-                  break;
-              case 2 :
-                  vga256InfoRec.videoRam = 1024 * 4;
-                  break;
-              case 1 :
-              default:
-                  vga256InfoRec.videoRam = 1024 * 2;
-                  break;
-          }
-      }            
-      else            
-      {
-          ramType = 0 ;
-          vga256InfoRec.videoRam = 1024 * 8;
-      }            
-  }
-  else
-  {
-      ramType = 0 ;
-  
-      switch (boot0 & 3)
-      {
-          case 0 :
-              vga256InfoRec.videoRam = 1024 * 8;
-              break;
-          case 2 :
-              vga256InfoRec.videoRam = 1024 * 4;
-              break;
-          case 1 :
-          case 3 :
-              vga256InfoRec.videoRam = 1024 * 2;
-              break;
-      }
-  }        
-  
-   
-  vga256InfoRec.maxClock = 230000 ;
-
-  nv->ChipLinearSize=vga256InfoRec.videoRam*1024;
-     
-  nv->ChipLinearBase=(int)base1;  
-  nv->ChipHas32bpp= 1 ;
-   
-  xf86ClearIOPortList (vga256InfoRec.scrnIndex);
-  xf86AddIOPorts(vga256InfoRec.scrnIndex,Num_VGA_IOPorts,VGA_IOPorts);  
-  xf86EnableIOPorts(vga256InfoRec.scrnIndex);
-  vgaIOBase = (inb(972) & 1) ? 976 : 944;
-  NV3EnterLeave(1 );
-
-   
-  if(vgaBitsPerPixel==16 && !noaccel) {
-    ErrorF("%s %s: %s: Setting RGB weight to 555\n","(--)" , 
-                                                    vga256InfoRec.name,
-                                                    vga256InfoRec.chipset);
-    xf86weight.green=xf86weight.blue=xf86weight.red=5;
-  }
-
-  ((  &(nv->ChipOptionFlags) )->flag_bits[( 60  )/ (8 * sizeof(CARD32)) ] |= (1 << (( 60  )% (8 * sizeof(CARD32)) ))) ;
-  ((  &(nv->ChipOptionFlags) )->flag_bits[( 62  )/ (8 * sizeof(CARD32)) ] |= (1 << (( 62  )% (8 * sizeof(CARD32)) ))) ;
-
-  NV3FlipFunctions(nv);
-
-  return 1;    
-}
-
-static int NV3ClockSelect(float clockIn,float *clockOut,int *mOut,int *nOut,int *pOut)
-{
-    unsigned lowM,     highM;
-    unsigned DeltaNew, DeltaOld;
-    unsigned VClk;
-    unsigned Freq;
-    unsigned M;
-    unsigned N;
-    unsigned O;
-    unsigned P;
-    
-     
-
-
-    DeltaOld = -1;
-    VClk     = (unsigned)clockIn;
-    if (crystalFreq == 14318)
-    {
-         
-        lowM  = 8;
-        highM = 13;
-    }
-    else
-    {
-         
-        lowM  = 7;
-        highM = 12;
-    }                      
-     
-
-
-    for (P = 0; P <= 3; P ++)
-    {
-        Freq = VClk << P;
-         
-
-
-        if ((Freq >= 128000) && (Freq <= 230000))
-        {
-            for (M = lowM; M <= highM; M++)
-            {
-                N    = (VClk * M / crystalFreq) << P;
-                Freq = (crystalFreq * N / M) >> P;
-                if (Freq > VClk)
-                    DeltaNew = Freq - VClk;
-                else
-                    DeltaNew = VClk - Freq;
-                if (DeltaNew < DeltaOld)
-                {
-                     
-
-
-                    *mOut     = M;
-                    *nOut     = N;
-                    *pOut     = P;
-                    *clockOut = (float)VClk;
-                    DeltaOld  = DeltaNew;
-                }
-            }
-        }
-    }
-    return (DeltaOld != -1);
-}
-
- 
-
-
-
-
-static int CalculateCRTC(DisplayModePtr mode)
-{
-  int bpp=vgaBitsPerPixel/8,
-      horizDisplay = (mode->CrtcHDisplay/8) - 1,
-      horizStart = (mode->CrtcHSyncStart/8) - 1,
-      horizEnd = (mode->CrtcHSyncEnd/8) - 1,
-      horizTotal = (mode->CrtcHTotal/8)	- 1,
-      vertDisplay = mode->CrtcVDisplay - 1,
-      vertStart = mode->CrtcVSyncStart	- 1,
-      vertEnd = mode->CrtcVSyncEnd - 1,
-      vertTotal = mode->CrtcVTotal - 2;
-        
-   
-  ((vgaNVPtr)vgaNewVideoState)->std.CRTC[19]=((vga256InfoRec.displayWidth/8)*bpp)&255;
-   
-  ((vgaNVPtr)vgaNewVideoState)->regs.nv3.repaint0=
-    (( (((unsigned)((  (vga256InfoRec.displayWidth/8)*bpp  ) & (((unsigned)(1U << ((( 10)-( 8)+1)))-1)  << ( 8))  )) >> (8) )  ) << (5))  ;
-
-   
-
-     
-  ((vgaNVPtr)vgaNewVideoState)->std.CRTC[0]= (( horizTotal - 4 )&255) ;
-  ((vgaNVPtr)vgaNewVideoState)->std.CRTC[1]= (( horizDisplay )&255) ;
-  ((vgaNVPtr)vgaNewVideoState)->std.CRTC[2]= (( horizDisplay )&255) ;
-  ((vgaNVPtr)vgaNewVideoState)->std.CRTC[3]= (( (((unsigned)((  horizTotal  ) & (((unsigned)(1U << ((( 4)-( 0)+1)))-1)  << ( 0))  )) >> (0) )  ) << (0))   | (1<<( 7 )) ;
-  ((vgaNVPtr)vgaNewVideoState)->std.CRTC[4]= (( horizStart )&255) ;
-  ((vgaNVPtr)vgaNewVideoState)->std.CRTC[5]= (( (((unsigned)((  horizTotal  ) & (((unsigned)(1U << ((( 5)-( 5)+1)))-1)  << ( 5))  )) >> (5) )  ) << (7))  |
-                     (( (((unsigned)((  horizEnd  ) & (((unsigned)(1U << ((( 4)-( 0)+1)))-1)  << ( 0))  )) >> (0) )  ) << (0))  ;
-  ((vgaNVPtr)vgaNewVideoState)->std.CRTC[6]= (( (((unsigned)((  vertTotal  ) & (((unsigned)(1U << ((( 7)-( 0)+1)))-1)  << ( 0))  )) >> (0) )  ) << (0))  ;
-
-  ((vgaNVPtr)vgaNewVideoState)->std.CRTC[7]= (( (((unsigned)((  vertTotal  ) & (((unsigned)(1U << ((( 8)-( 8)+1)))-1)  << ( 8))  )) >> (8) )  ) << (0))  |
-		     (( (((unsigned)((  vertDisplay  ) & (((unsigned)(1U << ((( 8)-( 8)+1)))-1)  << ( 8))  )) >> (8) )  ) << (1))  |
-		     (( (((unsigned)((  vertStart  ) & (((unsigned)(1U << ((( 8)-( 8)+1)))-1)  << ( 8))  )) >> (8) )  ) << (2))  |
-		     (( (((unsigned)((  vertDisplay  ) & (((unsigned)(1U << ((( 8)-( 8)+1)))-1)  << ( 8))  )) >> (8) )  ) << (3))  |
-		     (1<<( 4 )) |
-		     (( (((unsigned)((  vertTotal  ) & (((unsigned)(1U << ((( 9)-( 9)+1)))-1)  << ( 9))  )) >> (9) )  ) << (5))  |
-		     (( (((unsigned)((  vertDisplay  ) & (((unsigned)(1U << ((( 9)-( 9)+1)))-1)  << ( 9))  )) >> (9) )  ) << (6))  |
-		     (( (((unsigned)((  vertStart  ) & (((unsigned)(1U << ((( 9)-( 9)+1)))-1)  << ( 9))  )) >> (9) )  ) << (7))  ;
-
-  ((vgaNVPtr)vgaNewVideoState)->std.CRTC[9]= (( (((unsigned)((  vertDisplay  ) & (((unsigned)(1U << ((( 9)-( 9)+1)))-1)  << ( 9))  )) >> (9) )  ) << (5))   | (1<<( 6 )) ;
-  ((vgaNVPtr)vgaNewVideoState)->std.CRTC[16]= (( vertStart )&255) ;
-  ((vgaNVPtr)vgaNewVideoState)->std.CRTC[17]= (( (((unsigned)((  vertEnd  ) & (((unsigned)(1U << ((( 3)-( 0)+1)))-1)  << ( 0))  )) >> (0) )  ) << (0))   | (1<<( 5 )) ;
-  ((vgaNVPtr)vgaNewVideoState)->std.CRTC[18]= (( vertDisplay )&255) ;
-  ((vgaNVPtr)vgaNewVideoState)->std.CRTC[21]= (( vertDisplay )&255) ;
-  ((vgaNVPtr)vgaNewVideoState)->std.CRTC[22]= (( vertTotal + 1 )&255) ;
-
-  ((vgaNVPtr)vgaNewVideoState)->regs.nv3.screenExtra= (( (((unsigned)((  horizTotal  ) & (((unsigned)(1U << ((( 6)-( 6)+1)))-1)  << ( 6))  )) >> (6) )  ) << (4))   |
-                             (( (((unsigned)((  vertDisplay  ) & (((unsigned)(1U << ((( 10)-( 10)+1)))-1)  << ( 10))  )) >> (10) )  ) << (3))   |
-                             (( (((unsigned)((  vertStart  ) & (((unsigned)(1U << ((( 10)-( 10)+1)))-1)  << ( 10))  )) >> (10) )  ) << (2))   |
-                             (( (((unsigned)((  vertDisplay  ) & (((unsigned)(1U << ((( 10)-( 10)+1)))-1)  << ( 10))  )) >> (10) )  ) << (1))   |
-                             (( (((unsigned)((  vertTotal  ) & (((unsigned)(1U << ((( 10)-( 10)+1)))-1)  << ( 10))  )) >> (10) )  ) << (0))  ;
-
-  if(mode->Flags & 32 ) ((vgaNVPtr)vgaNewVideoState)->std.CRTC[9]|=128;
- 
-   
-
-
-  ((vgaNVPtr)vgaNewVideoState)->regs.nv3.horizExtra= (horizTotal < 260 ? 0 : 1);
-  return 1;
-}
-
- 
-
-
-
-
-static void InitPalette(DisplayModePtr mode)
-{
-  int bpp=vgaBitsPerPixel/8;
-  int i;
-
-  if(! (!(vgaBitsPerPixel==8 || xf86weight.green==6)) ) return;
-   
-   
-  for(i=0;i<256;i++) {
-    ((vgaNVPtr)vgaNewVideoState)->std.DAC[i*3]=i>>2;
-    ((vgaNVPtr)vgaNewVideoState)->std.DAC[(i*3)+1]=i>>2;
-    ((vgaNVPtr)vgaNewVideoState)->std.DAC[(i*3)+2]=i>>2;
-  }
-}
-
-static Bool NV3Init(DisplayModePtr mode)
-{
-  int m,n,p;
-  float clockIn=(float)vga256InfoRec.clock[mode->Clock];
-  float clockOut;
-  int time,data; 
-  int i;
-  int pixelDepth;
- 
-   
-  if(!vgaHWInit (mode, sizeof (vgaNVRec))) {
-    return 0;
-  }
-   
-  ((vgaNVPtr)vgaNewVideoState)->vgaValid=1;
-   
-  if(!NV3ClockSelect(clockIn,&clockOut,&m,&n,&p)) {
-    ErrorF("%s %s: %s: Unable to set desired video clock\n",
-           "(--)" , vga256InfoRec.name,vga256InfoRec.chipset);
-    return 0 ;  
-  }
-  ((vgaNVPtr)vgaNewVideoState)->regs.nv3.vpllCoeff= ((   n   ) << (8))    | 
-                          ((   m   ) << (0))    |
-                          ((   p   ) << (16))   ;
-
-  CalculateCRTC(mode);
-  InitPalette(mode);
-     
-  ((vgaNVPtr)vgaNewVideoState)->regs.nv3.repaint1=
-    ((   mode->CrtcHDisplay<1280   ) << (2))    |
-    (( 1    ) << (1))   ;
-   
-
-
-
-  pixelDepth=(vgaBitsPerPixel+1)/8;
-  if(pixelDepth>3) pixelDepth=3;
-  ((vgaNVPtr)vgaNewVideoState)->regs.nv3.pixelFormat=pixelDepth;
-
-  ((vgaNVPtr)vgaNewVideoState)->regs.nv3.generalControl=
-     (( 0    ) << (4))   |
-     ((   xf86weight.green==6   ) << (12))   |
-     (( 0    ) << (17))   |
-     (( 0    ) << (20))   |  
-     (( 1    ) << (8))   ;  
-   
-
-
-  nv3UpdateArbitrationSettings((unsigned int)clockOut,
-                               pixelDepth*8,
-                               crystalFreq,
-                              &(((vgaNVPtr)vgaNewVideoState)->regs.nv3.fifo),
-                              &(((vgaNVPtr)vgaNewVideoState)->regs.nv3.fifoControl));
-   
-
-
-
-
-
-  ((vgaNVPtr)vgaNewVideoState)->regs.nv3.coeffSelect= (( 1    ) << (8))   
-                                                    | (( 1    ) << (16))   
-                                                    | (( 1    ) << (28))   ;
-   
-
-
-   
-
-
-
-  ((vgaNVPtr)vgaNewVideoState)->regs.nv3.config0=
-      ((   ((vga256InfoRec.displayWidth+31)/32)   ) << (0))   |
-      ((   pixelDepth   ) << (8))   |
-      (( 1    ) << (12))   ; 
-
-  return 1 ;
-}  
-
-static void NV3Restore(void *data)
-{
-  vgaNVPtr restore=data;
-  NV3Registers *nv3=&(restore->regs.nv3);
-
-   
-
-
-  vgaProtect(1 ); 
-  vgaHWRestore((vgaHWPtr)restore);  
-  outb(980,( 25   ));outb(981,  nv3->repaint0  )  ;
-  outb(980,( 26   ));outb(981,  nv3->repaint1  )  ;
-  outb(980,( 37   ));outb(981,  nv3->screenExtra  )  ;
-  outb(980,( 40   ));outb(981,  nv3->pixelFormat  )  ;
-  outb(980,( 45   ));outb(981,  nv3->horizExtra  )  ; 
-  outb(980,( 27   ));outb(981,  nv3->fifoControl  )  ;
-  outb(980,( 32   ));outb(981,  nv3->fifo  )  ;
-  nvPFBPort[((1049088    )- (1048576) )/4] =(  nv3->config0  )  ;
-  nvPRAMDACPort[((6817032    )- (6815744) )/4] =(  nv3->vpllCoeff  )  ;
-  nvPRAMDACPort[((6817036    )- (6815744) )/4] =(  nv3->coeffSelect  )  ;
-  nvPRAMDACPort[((6817280    )- (6815744) )/4] =(  nv3->generalControl  )  ;
-  vgaProtect(0 );
-}
-
-static void *NV3Save(void *data)
-{
-  vgaNVPtr save= ((void *)0) ;
-
-  save=(vgaNVPtr)vgaHWSave((vgaHWPtr)data,sizeof(vgaNVRec));  
-  save->regs.nv3.repaint0= (outb(980, 25   ),inb(981))  ;
-  save->regs.nv3.repaint1= (outb(980, 26   ),inb(981))  ;
-  save->regs.nv3.screenExtra= (outb(980, 37   ),inb(981))  ;
-  save->regs.nv3.pixelFormat= (outb(980, 40   ),inb(981))  ;
-  save->regs.nv3.horizExtra= (outb(980, 45   ),inb(981))  ;
-  save->regs.nv3.fifoControl= (outb(980, 27   ),inb(981))  ; 
-  save->regs.nv3.fifo= (outb(980, 32   ),inb(981))  ;
-  save->regs.nv3.config0= nvPFBPort[((1049088    )- (1048576) )/4]   ;
-  save->regs.nv3.vpllCoeff= nvPRAMDACPort[((6817032    )- (6815744) )/4]   ;
-  save->regs.nv3.coeffSelect= nvPRAMDACPort[((6817036    )- (6815744) )/4]   ;
-  save->regs.nv3.generalControl= nvPRAMDACPort[((6817280    )- (6815744) )/4]   ;
-
-  return (void*)save;
-}
-
-static void NV3Adjust(int x,int y) 
-{
-  int bpp=vgaBitsPerPixel/8;
-  int startAddr=(((y*vga256InfoRec.virtualX)+x)*bpp);
-  int offset=startAddr>>2;
-  int pan=(startAddr&3)*2;
-  unsigned char byte;
-  
-   
-  outb(980,( 13 ));outb(981, (( offset )&255)  ) ;
-  outb(980,( 12 ));outb(981, (( (((unsigned)((  offset  ) & (((unsigned)(1U << ((( 15)-( 8)+1)))-1)  << ( 8))  )) >> (8) )  ) << (0))   ) ;
-  byte= (outb(980, 25   ),inb(981))   & ~(((unsigned)(1U << ((( 4)-( 0)+1)))-1)  << ( 0))    ;
-  outb(980,( 25   ));outb(981,  (( (((unsigned)((  offset  ) & (((unsigned)(1U << ((( 20)-( 16)+1)))-1)  << ( 16))  )) >> (16) )  ) << (0))  |byte  )  ;
-   
-  byte=inb(vgaIOBase+10);
-  outb(960,19);
-  outb(960,pan);
-}
- 
- 
-
-
-
-static int NV3ValidMode(DisplayModePtr mode,Bool verbose,int flag)
-{
-    unsigned bw, bwMax, bpp;
-
-    bpp = (vgaBitsPerPixel + 1) / 8;
-     
-
-
-    bwMax = (ramType == 0 ) ? 800000 : 700000;
-     
-
-
-    bw = mode->Clock * bpp;
-    return (bw > bwMax ? 255  : 0 );
-}
-
-
-extern vgaHWCursorRec vgaHWCursor;
-
-static void NV3FbInit(void)
-{
-   
-
-  if(! ((  &vga256InfoRec.options )->flag_bits[( 62  )/ (8 * sizeof(CARD32)) ] & (1 << (( 62  )% (8 * sizeof(CARD32)) ))) ) {
-     
-    vgaHWCursor.Initialized = 1 ;
-    vgaHWCursor.Init = NV3CursorInit;
-    vgaHWCursor.Restore = NV3RestoreCursor;
-    vgaHWCursor.Warp = NV3WarpCursor;
-    vgaHWCursor.QueryBestSize = NV3QueryBestSize;
-    if(xf86Verbose) {
-      ErrorF("%s %s: %s: Using hardware cursor\n","(--)" , 
-             vga256InfoRec.name,vga256InfoRec.chipset);
-    }
-  }
-
-  if(! ((  &vga256InfoRec.options )->flag_bits[( 60  )/ (8 * sizeof(CARD32)) ] & (1 << (( 60  )% (8 * sizeof(CARD32)) ))) ) {
-    NVAccelInit();
-  }
-  
-}
-
-static void NV3DisplayPowerManagementSet(int mode)
-{
-}
-
-static Bool NV3ScreenInit(ScreenPtr pScreen,pointer pbits, 
-                          int xsize,int ysize,int dpix,int dpiy,int width)
-{
-  return 1 ;
-}
-
-static void NV3SaveScreen(int on)
-{
-  vgaHWSaveScreen(on);
-}
-
-static void NV3GetMode(DisplayModePtr display)
-{
-}
-
- 
-
-
-static void NV3FlipFunctions(vgaVideoChipRec *nv)
-{
-  nv->ChipEnterLeave=NV3EnterLeave;
-  nv->ChipInit=NV3Init;
-  nv->ChipValidMode=NV3ValidMode;
-  nv->ChipSave=NV3Save;
-  nv->ChipRestore=NV3Restore;
-  nv->ChipAdjust=NV3Adjust;
-  nv->ChipSaveScreen=NV3SaveScreen;
-  nv->ChipGetMode=(void (*)())NoopDDA;
-  nv->ChipFbInit=NV3FbInit;
-}
Index: xc/programs/Xserver/hw/xfree86/vga256/drivers/nv/nv3setup.c
diff -u xc/programs/Xserver/hw/xfree86/vga256/drivers/nv/nv3setup.c:1.1.2.7 xc/programs/Xserver/hw/xfree86/vga256/drivers/nv/nv3setup.c:removed
--- xc/programs/Xserver/hw/xfree86/vga256/drivers/nv/nv3setup.c:1.1.2.7	Thu Nov 19 03:38:46 1998
+++ xc/programs/Xserver/hw/xfree86/vga256/drivers/nv/nv3setup.c	Wed Jan  6 00:32:31 1999
@@ -1,767 +0,0 @@
- /***************************************************************************\
-|*                                                                           *|
-|*       Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.      *|
-|*                                                                           *|
-|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
-|*     international laws.  Users and possessors of this source code are     *|
-|*     hereby granted a nonexclusive,  royalty-free copyright license to     *|
-|*     use this code in individual and commercial software.                  *|
-|*                                                                           *|
-|*     Any use of this source code must include,  in the user documenta-     *|
-|*     tion and  internal comments to the code,  notices to the end user     *|
-|*     as follows:                                                           *|
-|*                                                                           *|
-|*       Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.      *|
-|*                                                                           *|
-|*     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY     *|
-|*     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"     *|
-|*     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-     *|
-|*     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,     *|
-|*     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-     *|
-|*     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL     *|
-|*     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-     *|
-|*     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-     *|
-|*     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION     *|
-|*     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF     *|
-|*     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.     *|
-|*                                                                           *|
-|*     U.S. Government  End  Users.   This source code  is a "commercial     *|
-|*     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),     *|
-|*     consisting  of "commercial  computer  software"  and  "commercial     *|
-|*     computer  software  documentation,"  as such  terms  are  used in     *|
-|*     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-     *|
-|*     ment only as  a commercial end item.   Consistent with  48 C.F.R.     *|
-|*     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),     *|
-|*     all U.S. Government End Users  acquire the source code  with only     *|
-|*     those rights set forth herein.                                        *|
-|*                                                                           *|
- \***************************************************************************/
-/*
- * Copyright 1996-1997  David J. McKay
- *
- * Permission is hereby granted, free of charge, to any person obtaining a 
- * copy of this software and associated documentation files (the "Software"), 
- * to deal in the Software without restriction, including without limitation 
- * the rights to use, copy, modify, merge, publish, distribute, sublicense, 
- * and/or sell copies of the Software, and to permit persons to whom the 
- * Software is furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- * 
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL 
- * DAVID J. MCKAY BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, 
- * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF 
- * OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE 
- * SOFTWARE.
- */
-/* $XFree86: xc/programs/Xserver/hw/xfree86/vga256/drivers/nv/nv3setup.c,v 1.1.2.7 1998/11/18 16:38:46 hohndel Exp $ */
-
-#include <stdlib.h>
-
-
-#include "nvuser.h"
-#include "nvreg.h"
-
-typedef struct
-{
-    UINT32 id;
-    UINT32 context;
-}HashTableEntry;
-
-typedef struct
-{
-    UINT32 context;  
-    UINT32 dmaNotifyInst;  
-    UINT32 memFormatInst;  
-    UINT32 unknown;  
-}ObjInstEntry;
-
-typedef struct {
-  char patchConfig;   
-  char zwrite;        
-  char chroma;        
-  char plane;         
-  char clip;          
-  char colourFormat;  
-  char alpha;          
-}ObjectProperties;
-
-typedef struct {
-  int chid;                     
-  int id;                       
-  int device;                   
-  int instance;                 
-  ObjectProperties properties;  
-}NVObject;
-
-extern int ErrorF(const char *fmt,...);
-
-
-
-static int graphicsEngineOk;
-
-
-static void EnableOptimisations(void)
-{
-   
-   
-
- nvPGRAPHPort[((4194432    )- (4194304) )/4] =(  (( 1    ) << (4))   |
-                      (( 1    ) << (20))   |
-                      (( 1    ) << (24))     )  ;
-            
- nvPGRAPHPort[((4194436    )- (4194304) )/4] =(  (( 1    ) << (16))   |
-                      (( 1    ) << (20))     )  ;
-
- nvPGRAPHPort[((4194440    )- (4194304) )/4] =(  (( 1    ) << (8))   |
-                      (( 1    ) << (28))   |
-                      (( 1    ) << (0))   |
-                      (( 1    ) << (8))     )  ;
-
- nvPGRAPHPort[((4194444    )- (4194304) )/4] =(  (( 1    ) << (24))     )  ;
-}
-
-static void InitDMAInstance(void)
-{
-  nvPGRAPHPort[((4195968    )- (4194304) )/4] =(  0  )  ;
-  nvPGRAPHPort[((4195972    )- (4194304) )/4] =(  0  )  ;
-}
-
-static void DisableFifo(void)
-{
-   
-  nvPFIFOPort[((9472    )- (8192) )/4] =(  (( 0    ) << (0))     )  ;
-  nvPFIFOPort[((12800    )- (8192) )/4] =(  (( 0    ) << (0))     )  ;
-  nvPFIFOPort[((12864    )- (8192) )/4] =(  (( 0    ) << (0))     )  ;
-  nvPFIFOPort[((12288    )- (8192) )/4] =(  (( 0    ) << (0))     )  ;
-  nvPFIFOPort[((12352    )- (8192) )/4] =(  (( 0    ) << (0))     )  ;
-}
-
-static void EnableFifo(void)
-{
-     
-
-
-    nvPTIMERPort[((37376    )- (36864) )/4] =(   8  )  ;
-    nvPTIMERPort[((37392    )- (36864) )/4] =(   3  )  ;
-     
-
-
-    nvPFIFOPort[((12800    )- (8192) )/4] =(  (( 1    ) << (0))     )  ;
-    nvPFIFOPort[((12864    )- (8192) )/4] =(  (( 1    ) << (0))     )  ;
-    nvPFIFOPort[((9472    )- (8192) )/4] =(  (( 1    ) << (0))     )  ;
-}
-
-
-
-
-
-
-
- 
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
- 
-static void ClearOutFifoContext(void)
-{
-  int i;
-
-  for(i= (4608/4) ;i< (512/4) ;i++) {
-   nvPRAMINPort[ i ]=( 0 ) ;
-  }
-}  
-
-int NV3KbRamUsedByHW(void)
-{
-   return (8192 );
-}
-
-
-
-static void ClearOutContext(void)
-{
-  int i;
-
-   
-  nvPGRAPHPort[((4194688    )- (4194304) )/4] =(  0  )  ;
-  nvPGRAPHPort[((4194708    )- (4194304) )/4] =(  0  )  ;
-
-  ClearOutFifoContext();
-
-   
-  nvPFIFOPort[((12816    )- (8192) )/4] =(  0  )  ;nvPFIFOPort[((12912    )- (8192) )/4] =(  0  )  ;
-
-   
-  nvPFIFOPort[((9232    )- (8192) )/4] =(  0  )  ;
-  nvPFIFOPort[((9248    )- (8192) )/4] =(  0  )  ;
-  nvPFIFOPort[((9216    )- (8192) )/4] =(  0  )  ;
-
-   
-  for(i=0;i< 8 ;i++) {
-    nvPFIFOPort[(((12928+( i )*16)    )- (8192) )/4] =(  0  )  ;
-  }
-  for(i=0;i< 8 ;i++) {
-    nvPGRAPHPort[(((4194720+( i )*4)    )- (4194304) )/4] =(  0  )  ;
-  }
-
-}
-
-static HashTableEntry   localHash[256 ][2 ];
-static HashTableEntry *realHash= ((void *)0) ;
-
-
-
-
-
-
-static void ClearOutHashTables(void)
-{
-  int i,j;
-
-
-   
-
-   
-  for(i=0;i< 256 ;i++) {
-    for(j=0;j< 2 ;j++) {
-      localHash[i][j].id=0;
-      localHash[i][j].context=0;
-      nvPRAMINPort[ (((( i )* 2 )+( j ))*2)  ]=( 0 ) ;
-      nvPRAMINPort[ (((( i )* 2 )+( j ))*2) +1 ]=( 0 ) ;
-    }
-  }
-}
-
- 
-
-
-
-
-static void LoadChannelContext(int screenWidth,int screenHeight,int bpp)
-{
-  int i;
-  UINT32 read;
-  int pitch=((bpp+1)/8)*screenWidth;
-
-
-   
-
-  nvPFIFOPort[((12292    )- (8192) )/4] =(  0  )  ;
-  nvPFIFOPort[((12804    )- (8192) )/4] =(  0  )  ;
-
-   
-  nvPFIFOPort[((12832    )- (8192) )/4] =(  0  )  ;
-  nvPFIFOPort[((8704    )- (8192) )/4] =(  0  )  ;
-
-  nvPFIFOPort[((12880    )- (8192) )/4] =(   0  )  ;
-  read= nvPFIFOPort[((12880    )- (8192) )/4]   ;
-  nvPFIFOPort[((12880    )- (8192) )/4] =(  read| (( 1    ) << (4))     )  ;
-  read= nvPFIFOPort[((12880    )- (8192) )/4]   ;
-   
-
-   
-  nvPGRAPHPort[((4194704    )- (4194304) )/4] =(  (( 2    ) << (0))    |
-		           (( 0    ) << (8))    |
-		           (( 0    ) << (16))    |
-		           (( 0    ) << (24))    |
-		           (( 1    ) << (28))     )  ;
-
-
-   
-  nvPGRAPHPort[((4196004    )- (4194304) )/4] =(  (( 1    ) << (0))     )  ;
- 
-     
-  nvPGRAPHPort[((4195664    )- (4194304) )/4] =(  0  )  ;
-  nvPGRAPHPort[((4195668    )- (4194304) )/4] =(  (((( 65535  )<<16))|( 65535  ))   )  ;
-
-  nvPGRAPHPort[((4195672    )- (4194304) )/4] =(  0  )  ;
-  nvPGRAPHPort[((4195676    )- (4194304) )/4] =(  (((( 65535  )<<16))|( 65535  ))   )  ;
-
-   
-  nvPGRAPHPort[((4195968    )- (4194304) )/4] =(  0  )  ;
-  nvPGRAPHPort[((4195972    )- (4194304) )/4] =(  0  )  ;
-  nvPGRAPHPort[((4195976    )- (4194304) )/4] =(  0  )  ;
-  nvPGRAPHPort[((4195980    )- (4194304) )/4] =(  0  )  ;
-
-   
-   
-
-
-
-
-
-
-  nvPGRAPHPort[((4195888    )- (4194304) )/4] =(  0  )  ;nvPGRAPHPort[((4195892    )- (4194304) )/4] =(  0  )  ;
-  nvPGRAPHPort[((4195896    )- (4194304) )/4] =(  0  )  ;nvPGRAPHPort[((4195900    )- (4194304) )/4] =(  0  )  ;
-
-   
-  nvPGRAPHPort[((4195920    )- (4194304) )/4] =(  pitch  )  ;nvPGRAPHPort[((4195924    )- (4194304) )/4] =(  pitch  )  ;
-  nvPGRAPHPort[((4195928    )- (4194304) )/4] =(  pitch  )  ;nvPGRAPHPort[((4195932    )- (4194304) )/4] =(  pitch  )  ;
-
-
-  switch(bpp) { 
-    case 8:
-      nvPGRAPHPort[((4196008    )- (4194304) )/4] =(  (( 1    ) << (0))   |
-                          (( 1    ) << (4))   |
-                          (( 1    ) << (8))   |
-                          (( 1    ) << (12))     )  ;
-      break;
-    case 15:
-    case 16:
-      nvPGRAPHPort[((4196008    )- (4194304) )/4] =(  (( 2    ) << (0))   |
-                          (( 2    ) << (4))   |
-                          (( 2    ) << (8))   |
-                          (( 2    ) << (12))     )  ;
-      break; 
-    case 32:
-      nvPGRAPHPort[((4196008    )- (4194304) )/4] =(  (( 3    ) << (0))   |
-                          (( 3    ) << (4))   |
-                          (( 3    ) << (8))   |
-                          (( 3    ) << (12))     )  ;
-      break;  
-    default:
-      break;
-  }
-
-
-  nvPGRAPHPort[((4196000    )- (4194304) )/4] =(  0  )  ;
-  nvPGRAPHPort[((4195984    )- (4194304) )/4] =(  0  )  ;
-  nvPGRAPHPort[((4195992    )- (4194304) )/4] =(  0  )  ;
-  nvPGRAPHPort[((4195988    )- (4194304) )/4] =(  0  )  ;
-  nvPGRAPHPort[((4195996    )- (4194304) )/4] =(  0  )  ;
-
-  nvPGRAPHPort[((4195644    )- (4194304) )/4] =(  0  )  ;
-  nvPGRAPHPort[((4195648    )- (4194304) )/4] =(  0  )  ;
-  nvPGRAPHPort[((4195652    )- (4194304) )/4] =(  32767  )  ;
-  nvPGRAPHPort[((4195656    )- (4194304) )/4] =(  32767  )  ;
-
-   
-  nvPGRAPHPort[((4195680    )- (4194304) )/4] =(  0  )  ;
-  nvPGRAPHPort[((4195684    )- (4194304) )/4] =(  0  )  ;
-  nvPGRAPHPort[((4195688    )- (4194304) )/4] =(  0  )  ;
-  nvPGRAPHPort[((4195692    )- (4194304) )/4] =(  0  )  ;
- 
-  nvPGRAPHPort[((4195620    )- (4194304) )/4] =(  0  )  ;
-  nvPGRAPHPort[((4195624    )- (4194304) )/4] =(  0  )  ;
-  nvPGRAPHPort[((4195628    )- (4194304) )/4] =(  0  )  ;
-  nvPGRAPHPort[((4195632    )- (4194304) )/4] =(  0  )  ;
-
-  nvPGRAPHPort[((4195596    )- (4194304) )/4] =(  0  )  ;
-   
-
-
-
-
-  nvPGRAPHPort[((4195884    )- (4194304) )/4] =(  0  )  ;
-    
-  nvPGRAPHPort[((4195908    )- (4194304) )/4] =(  0  )  ;
- 
-   
-  nvPGRAPHPort[((4195880    )- (4194304) )/4] =(  -1  )  ;
-  nvPGRAPHPort[((4195904    )- (4194304) )/4] =(  0  )  ;
-
-  for(i=0;i< 32 ;i++) {
-    nvPGRAPHPort[(((4195328+( i )*4)    )- (4194304) )/4] =(  0  )  ;
-
-  }
-  for(i=0;i< 32 ;i++) {
-    nvPGRAPHPort[(((4195456+( i )*4)    )- (4194304) )/4] =(  0  )  ;
-  }
-
-  nvPGRAPHPort[((4195636    )- (4194304) )/4] =(  0  )  ;nvPGRAPHPort[((4195640    )- (4194304) )/4] =(  0  )  ;
-
-  nvPGRAPHPort[((4195604    )- (4194304) )/4] =(  0  )  ;nvPGRAPHPort[((4195608    )- (4194304) )/4] =(  0  )  ;
-  nvPGRAPHPort[((4195612    )- (4194304) )/4] =(  0  )  ;nvPGRAPHPort[((4195616    )- (4194304) )/4] =(  0  )  ;
-  nvPGRAPHPort[((4195584    )- (4194304) )/4] =(  0  )  ;nvPGRAPHPort[((4195588    )- (4194304) )/4] =(  0  )  ;
-
-   
-  nvPGRAPHPort[((4195840    )- (4194304) )/4] =(  0  )  ;nvPGRAPHPort[((4195844    )- (4194304) )/4] =(  255  )  ;
-  nvPGRAPHPort[((4195848    )- (4194304) )/4] =(  1  )  ;nvPGRAPHPort[((4195852    )- (4194304) )/4] =(  255  )  ;
-  nvPGRAPHPort[(((4195856+( 0 )*4)    )- (4194304) )/4] =(  -1  )  ;nvPGRAPHPort[(((4195856+( 1 )*4)    )- (4194304) )/4] =(  -1  )  ;
-  nvPGRAPHPort[((4195864    )- (4194304) )/4] =(  0  )  ;
-
-   
-  nvPGRAPHPort[((4195876    )- (4194304) )/4] =(  204  )  ;
-
-  nvPGRAPHPort[((4195592    )- (4194304) )/4] =(  0  )  ;
-
-}
-
- 
-
-
-
-
-
-
-
-  
- 
- 
-
-
- 
-
-
-static NVObject ropObject;
-static NVObject clipObject;
-static NVObject patternObject;
-static NVObject rectObject;
-static NVObject blitObject;
-static NVObject colourExpandObject;
-static NVObject lineObject;
-static NVObject linObject;
-static NVObject glyphObject;
-
-
-static void PlaceObjectInHashTable(NVObject *object)
-{
-  UINT32 hash;
-  UINT32 context;
-  int i;
-
-   
-   
-  hash= (((( object->id )^(( object->id )>>8)^(( object->id )>>16)^(( object->id )>>24))&255)^(( object->chid )&127)) ;
-  
-  for(i=0;i< 2 ;i++) {
-    if(localHash[hash][i].id==0) break;  
-     
-    if(localHash[hash][i].context==object->id) return;
-  }
-  if(i== 2 ) {
-     
-
-
-    ErrorF ("**** NO ROOM FOR OBJECT %08lx IN HASH TABLE ****\n",object->id);
-    graphicsEngineOk=0;  
-    return;
-  }
-
-  context=((object->device)<<16)| (( 1 ) << (23)) | (( object->instance ) << (0)) |
-          (( object->chid ) << (24)) ;
-
-
-
-   
-  localHash[hash][i].id=object->id;
-  localHash[hash][i].context=context;
-  nvPRAMINPort[ (((( hash )* 2 )+( i ))*2)  ]=( object->id ) ;
-  nvPRAMINPort[ (((( hash )* 2 )+( i ))*2) +1 ]=( context ) ;
-}
-
-
-
-
-static void PlaceObjectInInstTable(NVObject *object)
-{
-  ObjectProperties *p=&(object->properties);
-  UINT32 context;
-
-   
-  context= (( p->patchConfig ) << (24)) | (( p->chroma ) << (13)) |
-          (( p->plane ) << (14)) | (( p->clip ) << (15)) |
-          (( p->colourFormat ) << (0)) | (( p->alpha ) << (3)) |(1<<20);
-
-
-
-
-
-  nvPRAMINPort[ (object->instance<<2)+0 ]=( context ) ;
-  nvPRAMINPort[ (object->instance<<2)+1 ]=( 0 ) ;
-  nvPRAMINPort[ (object->instance<<2)+2 ]=( 0 ) ;
-  nvPRAMINPort[ (object->instance<<2)+3 ]=( 0 ) ;
-  
-}
-
-
- 
-
-
-static int AllocateFreeInstance(void)
-{
-  static int freeInstance= ((5120/4) /16) ;
-
-  return freeInstance++;
-}
-
-static int defaultColourFormat= 1 ;
-
-static void InitObject(NVObject *o,int id,int device)
-{
-  ObjectProperties *p=&(o->properties);
-
-  o->id=id;
-  o->chid=0;
-  o->instance=AllocateFreeInstance();
-  o->device=device;
-
-  p->patchConfig= 16 ;
-  p->zwrite=0; 
-  p->chroma=0; 
-  p->plane=0;
-  p->clip=1;
-  p->colourFormat=defaultColourFormat;
-  p->alpha=0;
-}
-
-
-
-
-static void SetUpObjects(int bpp)
-{
-  defaultColourFormat=(bpp==16) ? 0  : 1 ;
-
-  InitObject(&ropObject,-1728053248 ,(((4325376) &8323072)>>16) );
-  PlaceObjectInHashTable(&ropObject);
-  PlaceObjectInInstTable(&ropObject);
-
-  InitObject(&clipObject,-1728053247 ,(((4521984) &8323072)>>16) );
-  PlaceObjectInHashTable(&clipObject);
-  PlaceObjectInInstTable(&clipObject);
-
-  InitObject(&rectObject,-2013265920 ,(((4653056) &8323072)>>16) );
-  PlaceObjectInHashTable(&rectObject);
-  PlaceObjectInInstTable(&rectObject);
-
-  InitObject(&blitObject,-2013265919 ,(((5242880) &8323072)>>16) );
-  PlaceObjectInHashTable(&blitObject);
-  PlaceObjectInInstTable(&blitObject);
-
-  InitObject(&colourExpandObject,-2013265918 ,
-             (((5373952) &8323072)>>16) );
-  colourExpandObject.properties.alpha=1;  
-  PlaceObjectInHashTable(&colourExpandObject);
-  PlaceObjectInInstTable(&colourExpandObject);
-
-  InitObject(&glyphObject,-2013265915 ,(((4980736) &8323072)>>16) );
-  glyphObject.properties.clip = 0;  
-  PlaceObjectInHashTable(&glyphObject);
-  PlaceObjectInInstTable(&glyphObject);
-
-  InitObject(&lineObject,-2013265917 ,(((4784128) &8323072)>>16) );
-  PlaceObjectInHashTable(&lineObject);
-  PlaceObjectInInstTable(&lineObject);
-
-  InitObject(&linObject,-2013265916 ,(((4849664) &8323072)>>16) );
-  PlaceObjectInHashTable(&linObject);
-  PlaceObjectInInstTable(&linObject);
-
-}
-
-
-
-static void ClearAndEnableInterrupts(void)
-{
-
-  nvPGRAPHPort[((4194560    )- (4194304) )/4] =(  (( 1    ) << (0))   |
-                      (( 1    ) << (4))   |
-                      (( 1    ) << (8))   |
-                      (( 1    ) << (12))   |
-                      (( 1    ) << (16))   |
-                      (( 1    ) << (20))   |
-                      (( 1    ) << (24))   |
-                      (( 1    ) << (28))     )  ;
-    
-  nvPGRAPHPort[((4194624    )- (4194304) )/4] =(  -1  )  ;
-
-  nvPGRAPHPort[((4194564    )- (4194304) )/4] =(  (( 1    ) << (0))   |
-                      (( 1    ) << (4))   |
-                      (( 1    ) << (12))   |
-                      (( 1    ) << (16))     )  ;
-
-   
-  nvPGRAPHPort[((4194628    )- (4194304) )/4] =(  -1  )  ;
-
-  nvPGRAPHPort[((4198656    )- (4194304) )/4] =(  -1  )  ;
-  nvPGRAPHPort[((4198720    )- (4194304) )/4] =(  -1  )  ;
-
-  
-   
-  nvPFIFOPort[((8448    )- (8192) )/4] =(   (( 1    ) << (0))   |
-                      (( 1    ) << (4))   |
-                      (( 1    ) << (8))   |
-                      (( 1    ) << (12))   |
-                      (( 1    ) << (16))     )  ;
-
-  nvPFIFOPort[((8512    )- (8192) )/4] =(   (( 1    ) << (0))   |
-                         (( 1    ) << (4))   |
-                         (( 1    ) << (8))     )  ;
-
-   
-  nvPMCPort[((512    )- (0) )/4] =(  -1  )  ;
-
-   
-
-
-
-}
-
-static void ResetEngine(void)
-{
-  nvPMCPort[((512    )- (0) )/4] =(  -65281  )  ;
-  nvPMCPort[((512    )- (0) )/4] =(  -1  )  ;
-   
-  nvPGRAPHPort[((4194436    )- (4194304) )/4] =(  (( 1    ) << (0))     )  ;
-  nvPGRAPHPort[((4194432    )- (4194304) )/4] =(  (( 1    ) << (0))     )  ;
-
-}  
-
-static void EnableChannel(void)
-{
-
-   
-  nvPGRAPHPort[((4194704    )- (4194304) )/4] =(  (( 2    ) << (0))    |
-		           (( 0    ) << (8))    |
-		           (( 1    ) << (16))    |
-		           (( 0    ) << (24))    |
-		           (( 1    ) << (28))     )  ;
-}  
-
- 
-
-
-
-static void InitInstanceMemory(void)
-{
-  int i;
-   
-
-
-  nvPFIFOPort[((8720    )- (8192) )/4] =(  ((   0   ) << (12))   | 
-                    (( 0    ) << (16))     )  ;
-  
-   
-  nvPFIFOPort[((8728    )- (8192) )/4] =(  ((   16   ) << (9))   |
-                    (( 0    ) << (16))     )  ;
-                      
-   
-
-
-  nvPFIFOPort[((8724    )- (8192) )/4] =(  ((   17   ) << (9))     )  ;
-  
-   
-
-   
-  for(i=0;i<(1024*1024)/4;i++) {
-     nvPRAMINPort[ i ]=( 0 ) ;
-  }
-}
-
-  
-
-
-int NV3SetupGraphicsEngine(int screenWidth,int screenHeight,int bpp)
-{
-  graphicsEngineOk=1;
-
-  DisableFifo();
-
-  ResetEngine();
-
-  EnableOptimisations();
-
-  InitDMAInstance();
-
-  ClearAndEnableInterrupts();
-
-  InitInstanceMemory();
-
-  ClearOutContext();
-
-  ClearOutHashTables();
-
-  LoadChannelContext(screenWidth,screenHeight,bpp);
-
-  SetUpObjects(bpp);
-
-  EnableChannel();
-
-  EnableFifo();
-
-  return graphicsEngineOk;
-
-}
-
-
-void NV3Sync(void)
-{
-  while(nvPGRAPHPort[((4196016    )- (4194304) )/4]   &1) ;
-}
-
- 
-
-
-
-
-
-
-
-
-
-
-
-void NV3CheckForErrors(char *fileName,int lineNo) 
-{
-  UINT32 val= nvPMCPort[((256    )- (0) )/4]   ;
-     
-   
-   
-  if( val  &  (((unsigned)(1U << ((( 0)-( 0)+1)))-1)  << ( 0))    ) { ErrorF ("<%s %d> ""PMC""_""INTR_0_PAUDIO"" Set\n",fileName,lineNo);} ;
-  if( val  &  (((unsigned)(1U << ((( 8)-( 8)+1)))-1)  << ( 8))    ) { ErrorF ("<%s %d> ""PMC""_""INTR_0_PFIFO"" Set\n",fileName,lineNo);} ;
-  if( val  &  (((unsigned)(1U << ((( 12)-( 12)+1)))-1)  << ( 12))    ) { ErrorF ("<%s %d> ""PMC""_""INTR_0_PGRAPH0"" Set\n",fileName,lineNo);} ;
-  if( val  &  (((unsigned)(1U << ((( 13)-( 13)+1)))-1)  << ( 13))    ) { ErrorF ("<%s %d> ""PMC""_""INTR_0_PGRAPH1"" Set\n",fileName,lineNo);} ;
-  if( val  &  (((unsigned)(1U << ((( 16)-( 16)+1)))-1)  << ( 16))    ) { ErrorF ("<%s %d> ""PMC""_""INTR_0_PVIDEO"" Set\n",fileName,lineNo);} ;
-  if( val  &  (((unsigned)(1U << ((( 20)-( 20)+1)))-1)  << ( 20))    ) { ErrorF ("<%s %d> ""PMC""_""INTR_0_PTIMER"" Set\n",fileName,lineNo);} ;
-  if( val  &  (((unsigned)(1U << ((( 24)-( 24)+1)))-1)  << ( 24))    ) { ErrorF ("<%s %d> ""PMC""_""INTR_0_PFB"" Set\n",fileName,lineNo);} ;
-  if( val  &  (((unsigned)(1U << ((( 28)-( 28)+1)))-1)  << ( 28))    ) { ErrorF ("<%s %d> ""PMC""_""INTR_0_PBUS"" Set\n",fileName,lineNo);} ;
-  if( val  &  (((unsigned)(1U << ((( 31)-( 31)+1)))-1)  << ( 31))    ) { ErrorF ("<%s %d> ""PMC""_""INTR_0_SOFTWARE"" Set\n",fileName,lineNo);} ;
-
-  val= nvPGRAPHPort[((4194560    )- (4194304) )/4]   ;
-  if( val  &  (((unsigned)(1U << ((( 0)-( 0)+1)))-1)  << ( 0))    ) { ErrorF ("<%s %d> ""PGRAPH""_""INTR_0_RESERVED"" Set\n",fileName,lineNo);} ;
-  if( val  &  (((unsigned)(1U << ((( 4)-( 4)+1)))-1)  << ( 4))    ) { ErrorF ("<%s %d> ""PGRAPH""_""INTR_0_CONTEXT_SWITCH"" Set\n",fileName,lineNo);} ;
-  if( val  &  (((unsigned)(1U << ((( 8)-( 8)+1)))-1)  << ( 8))    ) { ErrorF ("<%s %d> ""PGRAPH""_""INTR_0_VBLANK"" Set\n",fileName,lineNo);} ;
-  if( val  &  (((unsigned)(1U << ((( 12)-( 12)+1)))-1)  << ( 12))    ) { ErrorF ("<%s %d> ""PGRAPH""_""INTR_0_RANGE"" Set\n",fileName,lineNo);} ;
-  if( val  &  (((unsigned)(1U << ((( 16)-( 16)+1)))-1)  << ( 16))    ) { ErrorF ("<%s %d> ""PGRAPH""_""INTR_0_METHOD_COUNT"" Set\n",fileName,lineNo);} ;
-  if( val  &  (((unsigned)(1U << ((( 24)-( 24)+1)))-1)  << ( 24))    ) { ErrorF ("<%s %d> ""PGRAPH""_""INTR_0_COMPLEX_CLIP"" Set\n",fileName,lineNo);} ;
-  if( val  &  (((unsigned)(1U << ((( 28)-( 28)+1)))-1)  << ( 28))    ) { ErrorF ("<%s %d> ""PGRAPH""_""INTR_0_NOTIFY"" Set\n",fileName,lineNo);} ;
-
-  val= nvPGRAPHPort[((4194564    )- (4194304) )/4]   ;
-  if( val  &  (((unsigned)(1U << ((( 0)-( 0)+1)))-1)  << ( 0))    ) { ErrorF ("<%s %d> ""PGRAPH""_""INTR_1_METHOD"" Set\n",fileName,lineNo);} ;
-  if( val  &  (((unsigned)(1U << ((( 4)-( 4)+1)))-1)  << ( 4))    ) { ErrorF ("<%s %d> ""PGRAPH""_""INTR_1_DATA"" Set\n",fileName,lineNo);} ;
-  if( val  &  (((unsigned)(1U << ((( 12)-( 12)+1)))-1)  << ( 12))    ) { ErrorF ("<%s %d> ""PGRAPH""_""INTR_1_DOUBLE_NOTIFY"" Set\n",fileName,lineNo);} ;
-  if( val  &  (((unsigned)(1U << ((( 16)-( 16)+1)))-1)  << ( 16))    ) { ErrorF ("<%s %d> ""PGRAPH""_""INTR_1_CTXSW_NOTIFY"" Set\n",fileName,lineNo);} ;
-
-  val= nvPFIFOPort[((8448    )- (8192) )/4]   ;
-  if( val  &  (((unsigned)(1U << ((( 0)-( 0)+1)))-1)  << ( 0))    ) { ErrorF ("<%s %d> ""PFIFO""_""INTR_0_CACHE_ERROR"" Set\n",fileName,lineNo);} ;
-  if( val  &  (((unsigned)(1U << ((( 4)-( 4)+1)))-1)  << ( 4))    ) { ErrorF ("<%s %d> ""PFIFO""_""INTR_0_RUNOUT"" Set\n",fileName,lineNo);} ;
-  if( val  &  (((unsigned)(1U << ((( 8)-( 8)+1)))-1)  << ( 8))    ) { ErrorF ("<%s %d> ""PFIFO""_""INTR_0_RUNOUT_OVERFLOW"" Set\n",fileName,lineNo);} ;
-  if( val  &  (((unsigned)(1U << ((( 12)-( 12)+1)))-1)  << ( 12))    ) { ErrorF ("<%s %d> ""PFIFO""_""INTR_0_DMA_PUSHER"" Set\n",fileName,lineNo);} ;
-  if( val  &  (((unsigned)(1U << ((( 16)-( 16)+1)))-1)  << ( 16))    ) { ErrorF ("<%s %d> ""PFIFO""_""INTR_0_DMA_PTE"" Set\n",fileName,lineNo);} ;
-
-
-  val= nvPGRAPHPort[((4198656    )- (4194304) )/4]   ;
-  if( val  &  (((unsigned)(1U << ((( 0)-( 0)+1)))-1)  << ( 0))    ) { ErrorF ("<%s %d> ""PGRAPH""_""DMA_INTR_0_INSTANCE"" Set\n",fileName,lineNo);} ;
-  if( val  &  (((unsigned)(1U << ((( 4)-( 4)+1)))-1)  << ( 4))    ) { ErrorF ("<%s %d> ""PGRAPH""_""DMA_INTR_0_PRESENT"" Set\n",fileName,lineNo);} ;
-  if( val  &  (((unsigned)(1U << ((( 8)-( 8)+1)))-1)  << ( 8))    ) { ErrorF ("<%s %d> ""PGRAPH""_""DMA_INTR_0_PROTECTION"" Set\n",fileName,lineNo);} ;
-  if( val  &  (((unsigned)(1U << ((( 12)-( 12)+1)))-1)  << ( 12))    ) { ErrorF ("<%s %d> ""PGRAPH""_""DMA_INTR_0_LINEAR"" Set\n",fileName,lineNo);} ;
-  if( val  &  (((unsigned)(1U << ((( 16)-( 16)+1)))-1)  << ( 16))    ) { ErrorF ("<%s %d> ""PGRAPH""_""DMA_INTR_0_NOTIFY"" Set\n",fileName,lineNo);} ;
-
-
-}
Index: xc/programs/Xserver/hw/xfree86/vga256/drivers/nv/nv4arb.c
diff -u xc/programs/Xserver/hw/xfree86/vga256/drivers/nv/nv4arb.c:1.1.2.3 xc/programs/Xserver/hw/xfree86/vga256/drivers/nv/nv4arb.c:removed
--- xc/programs/Xserver/hw/xfree86/vga256/drivers/nv/nv4arb.c:1.1.2.3	Thu Nov 19 03:38:47 1998
+++ xc/programs/Xserver/hw/xfree86/vga256/drivers/nv/nv4arb.c	Wed Jan  6 00:32:32 1999
@@ -1,246 +0,0 @@
- /***************************************************************************\
-|*                                                                           *|
-|*       Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.      *|
-|*                                                                           *|
-|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
-|*     international laws.  Users and possessors of this source code are     *|
-|*     hereby granted a nonexclusive,  royalty-free copyright license to     *|
-|*     use this code in individual and commercial software.                  *|
-|*                                                                           *|
-|*     Any use of this source code must include,  in the user documenta-     *|
-|*     tion and  internal comments to the code,  notices to the end user     *|
-|*     as follows:                                                           *|
-|*                                                                           *|
-|*       Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.      *|
-|*                                                                           *|
-|*     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY     *|
-|*     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"     *|
-|*     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-     *|
-|*     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,     *|
-|*     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-     *|
-|*     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL     *|
-|*     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-     *|
-|*     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-     *|
-|*     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION     *|
-|*     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF     *|
-|*     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.     *|
-|*                                                                           *|
-|*     U.S. Government  End  Users.   This source code  is a "commercial     *|
-|*     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),     *|
-|*     consisting  of "commercial  computer  software"  and  "commercial     *|
-|*     computer  software  documentation,"  as such  terms  are  used in     *|
-|*     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-     *|
-|*     ment only as  a commercial end item.   Consistent with  48 C.F.R.     *|
-|*     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),     *|
-|*     all U.S. Government End Users  acquire the source code  with only     *|
-|*     those rights set forth herein.                                        *|
-|*                                                                           *|
- \***************************************************************************/
-/* $XFree86: xc/programs/Xserver/hw/xfree86/vga256/drivers/nv/nv4arb.c,v 1.1.2.3 1998/11/18 16:38:47 hohndel Exp $ */
-#include "nv4arb.h"
-#include "nvreg.h"
-
-static void CalcArbitration 
-(
-    fifo_info *fifo,
-    sim_state *arb
-)
-{
-    int data, m,n,p, pagemiss, cas,width, video_enable, color_key_enable, bpp, align;
-    int nvclks, mclks, pclks, vpagemiss, crtpagemiss, vbs;
-    int found, mclk_extra, mclk_loop, cbs, m1, p1;
-    int xtal_freq, mclk_freq, pclk_freq, nvclk_freq, mp_enable;
-    int us_m, us_n, us_p, video_drain_rate, crtc_drain_rate;
-    int vpm_us, us_video, vlwm, video_fill_us, cpm_us, us_crt,clwm;
-    int craw, vraw;
-
-    fifo->valid = 1;
-    pclk_freq = arb->pclk_khz;
-    mclk_freq = arb->mclk_khz;
-    nvclk_freq = arb->nvclk_khz;
-    pagemiss = arb->mem_page_miss;
-    cas = arb->mem_latency;
-    width = arb->memory_width >> 6;
-    video_enable = arb->enable_video;
-    color_key_enable = arb->gr_during_vid;
-    bpp = arb->pix_bpp;
-    align = arb->mem_aligned;
-    mp_enable = arb->enable_mp;
-    clwm = 0;
-    vlwm = 0;
-    cbs = 128;
-    pclks = 2;
-    nvclks = 2;
-    nvclks += 2;
-    nvclks += 1;
-    mclks = 5;
-    mclks += 3;
-    mclks += 1;
-    mclks += cas;
-    mclks += 1;
-    mclks += 1;
-    mclks += 1;
-    mclks += 1;
-    mclk_extra = 3;
-    nvclks += 2;
-    nvclks += 1;
-    nvclks += 1;
-    nvclks += 1;
-    if (mp_enable)
-        mclks+=4;
-    nvclks += 0;
-    pclks += 0;
-    found = 0;
-    while (found != 1)
-    {
-        fifo->valid = 1;
-        found = 1;
-        mclk_loop = mclks+mclk_extra;
-        us_m = mclk_loop *1000*1000 / mclk_freq;
-        us_n = nvclks*1000*1000 / nvclk_freq;
-        us_p = nvclks*1000*1000 / pclk_freq;
-        if (video_enable)
-        {
-            video_drain_rate = pclk_freq * 2;
-            crtc_drain_rate = pclk_freq * bpp/8;
-            vpagemiss = 2;
-            vpagemiss += 1;
-            crtpagemiss = 2;
-            vpm_us = (vpagemiss * pagemiss)*1000*1000/mclk_freq;
-            if (nvclk_freq * 2 > mclk_freq * width)
-                video_fill_us = cbs*1000*1000 / 16 / nvclk_freq ;
-            else
-                video_fill_us = cbs*1000*1000 / (8 * width) / mclk_freq;
-            us_video = vpm_us + us_m + us_n + us_p + video_fill_us;
-            vlwm = us_video * video_drain_rate/(1000*1000);
-            vlwm++;
-            vbs = 128;
-            if (vlwm > 128) vbs = 64;
-            if (vlwm > (256-64)) vbs = 32;
-            if (nvclk_freq * 2 > mclk_freq * width)
-                video_fill_us = vbs *1000*1000/ 16 / nvclk_freq ;
-            else
-                video_fill_us = vbs*1000*1000 / (8 * width) / mclk_freq;
-            cpm_us = crtpagemiss  * pagemiss *1000*1000/ mclk_freq;
-            us_crt =
-            us_video
-            +video_fill_us
-            +cpm_us
-            +us_m + us_n +us_p
-            ;
-            clwm = us_crt * crtc_drain_rate/(1000*1000);
-            clwm++;
-        }
-        else
-        {
-            crtc_drain_rate = pclk_freq * bpp/8;
-            crtpagemiss = 2;
-            crtpagemiss += 1;
-            cpm_us = crtpagemiss  * pagemiss *1000*1000/ mclk_freq;
-            us_crt =  cpm_us + us_m + us_n + us_p ;
-            clwm = us_crt * crtc_drain_rate/(1000*1000);
-            clwm++;
-        }
-        m1 = clwm + cbs - 512;
-        p1 = m1 * pclk_freq / mclk_freq;
-        p1 = p1 * bpp / 8;
-        if ((p1 < m1) && (m1 > 0))
-        {
-            fifo->valid = 0;
-            found = 0;
-            if (mclk_extra ==0)   found = 1;
-            mclk_extra--;
-        }
-        else if (video_enable)
-        {
-            if ((clwm > 511) || (vlwm > 255))
-            {
-                fifo->valid = 0;
-                found = 0;
-                if (mclk_extra ==0)   found = 1;
-                mclk_extra--;
-            }
-        }
-        else
-        {
-            if (clwm > 519)
-            {
-                fifo->valid = 0;
-                found = 0;
-                if (mclk_extra ==0)   found = 1;
-                mclk_extra--;
-            }
-        }
-        craw = clwm;
-        vraw = vlwm;
-        if (clwm < 384) clwm = 384;
-        if (vlwm < 128) vlwm = 128;
-        data = (int)(clwm);
-        fifo->graphics_lwm = data;
-        fifo->graphics_burst_size = 128;
-        data = (int)((vlwm+15));
-        fifo->video_lwm = data;
-        fifo->video_burst_size = vbs;
-    }
-}
-void nv4UpdateArbitrationSettings
-(
-    unsigned int   VClk, 
-    unsigned int   pixelDepth, 
-    unsigned int   crystal,
-    unsigned char *lwm,
-    unsigned char *burst
-)
-{
-    fifo_info fifo_data;
-    sim_state sim_data;
-    unsigned int M, N, P, pll, MClk, NVClk, cfg1;
-
-    pll = nvPRAMDACPort[((6817028    )- (6815744) )/4]   ;
-    M = (pll >> 0)  & 255;
-    N = (pll >> 8)  & 255;
-    P = (pll >> 16) & 15;
-    MClk  = (N * crystal / M) >> P;
-    pll = nvPRAMDACPort[((6817024    )- (6815744) )/4]   ;
-    M = (pll >> 0)  & 255;
-    N = (pll >> 8)  & 255;
-    P = (pll >> 16) & 15;
-    NVClk  = (N * crystal / M) >> P;
-    cfg1 = nvPFBPort[((1049092    )- (1048576) )/4]   ;
-    sim_data.pix_bpp        = (char)pixelDepth;
-    sim_data.enable_video   = 0;
-    sim_data.enable_mp      = 0;
-    sim_data.memory_width   = (nvPEXTDEVPort[((1052672    )- (1052672) )/4]    & 16) ? 128 : 64;
-    sim_data.mem_latency    = (char)cfg1 & 15;
-    sim_data.mem_aligned    = 1;
-    sim_data.mem_page_miss  = (char)(((cfg1 >> 4) &15) + ((cfg1 >> 31) &1));
-    sim_data.gr_during_vid  = 0;
-    sim_data.pclk_khz       = VClk;
-    sim_data.mclk_khz       = MClk;
-    sim_data.nvclk_khz      = NVClk;
-    CalcArbitration(&fifo_data, &sim_data);
-    if (fifo_data.valid)
-    {
-        *lwm = fifo_data.graphics_lwm >> 3;
-        switch (fifo_data.graphics_burst_size)
-        {
-            case 256:
-                *burst = 4;
- 
-                break;
-            case 128:
-                *burst = 3;
-                break;
-            case 64:
-                *burst = 2;
-                break;
-            case 32:
-                *burst = 1;
-                break;
-            case 16:
-                *burst = 0;
-                break;
-        }
-    }
-}
-
Index: xc/programs/Xserver/hw/xfree86/vga256/drivers/nv/nv4arb.h
diff -u xc/programs/Xserver/hw/xfree86/vga256/drivers/nv/nv4arb.h:1.1.2.2 xc/programs/Xserver/hw/xfree86/vga256/drivers/nv/nv4arb.h:removed
--- xc/programs/Xserver/hw/xfree86/vga256/drivers/nv/nv4arb.h:1.1.2.2	Tue Oct 20 06:57:09 1998
+++ xc/programs/Xserver/hw/xfree86/vga256/drivers/nv/nv4arb.h	Wed Jan  6 00:32:32 1999
@@ -1,79 +0,0 @@
- /***************************************************************************\
-|*                                                                           *|
-|*       Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.      *|
-|*                                                                           *|
-|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
-|*     international laws.  Users and possessors of this source code are     *|
-|*     hereby granted a nonexclusive,  royalty-free copyright license to     *|
-|*     use this code in individual and commercial software.                  *|
-|*                                                                           *|
-|*     Any use of this source code must include,  in the user documenta-     *|
-|*     tion and  internal comments to the code,  notices to the end user     *|
-|*     as follows:                                                           *|
-|*                                                                           *|
-|*       Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.      *|
-|*                                                                           *|
-|*     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY     *|
-|*     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"     *|
-|*     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-     *|
-|*     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,     *|
-|*     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-     *|
-|*     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL     *|
-|*     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-     *|
-|*     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-     *|
-|*     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION     *|
-|*     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF     *|
-|*     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.     *|
-|*                                                                           *|
-|*     U.S. Government  End  Users.   This source code  is a "commercial     *|
-|*     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),     *|
-|*     consisting  of "commercial  computer  software"  and  "commercial     *|
-|*     computer  software  documentation,"  as such  terms  are  used in     *|
-|*     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-     *|
-|*     ment only as  a commercial end item.   Consistent with  48 C.F.R.     *|
-|*     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),     *|
-|*     all U.S. Government End Users  acquire the source code  with only     *|
-|*     those rights set forth herein.                                        *|
-|*                                                                           *|
- \***************************************************************************/
-/* $XFree86: xc/programs/Xserver/hw/xfree86/vga256/drivers/nv/nv4arb.h,v 1.1.2.2 1998/10/19 20:57:09 hohndel Exp $ */
-#ifndef _ARB_FIFO_H
-#define _ARB_FIFO_H
-#define DEFAULT_GR_LWM 100
-#define DEFAULT_VID_LWM 100
-#define DEFAULT_GR_BURST_SIZE 256
-#define DEFAULT_VID_BURST_SIZE 128
-typedef struct {
-  int graphics_lwm;
-  int video_lwm;
-  int graphics_burst_size;
-  int video_burst_size;
-  int valid;
-} fifo_info;
-typedef struct {
-  int pclk_khz;
-  int mclk_khz;
-  int nvclk_khz;
-  char mem_page_miss;
-  char mem_latency;
-  int memory_width;
-  char enable_video;
-  char gr_during_vid;
-  char pix_bpp;
-  char mem_aligned;
-  char enable_mp;
-} sim_state;
-#define VIDEO		0
-#define GRAPHICS	1
-#define MPORT		2
-#define ENGINE		3
-#define GFIFO_SIZE	320
-#define GFIFO_SIZE_128	256
-#define MFIFO_SIZE	120
-#define VFIFO_SIZE	256
-#ifndef ABS
-#define	ABS(a)	(a>0?a:-a)
-#endif
-void nv4UpdateArbitrationSettings(unsigned int, unsigned int, unsigned int, unsigned char *, unsigned char *);
-#endif
-
Index: xc/programs/Xserver/hw/xfree86/vga256/drivers/nv/nv4cursor.c
diff -u xc/programs/Xserver/hw/xfree86/vga256/drivers/nv/nv4cursor.c:1.1.2.4 xc/programs/Xserver/hw/xfree86/vga256/drivers/nv/nv4cursor.c:removed
--- xc/programs/Xserver/hw/xfree86/vga256/drivers/nv/nv4cursor.c:1.1.2.4	Thu Nov 19 03:38:47 1998
+++ xc/programs/Xserver/hw/xfree86/vga256/drivers/nv/nv4cursor.c	Wed Jan  6 00:32:33 1999
@@ -1,341 +0,0 @@
- /***************************************************************************\
-|*                                                                           *|
-|*       Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.      *|
-|*                                                                           *|
-|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
-|*     international laws.  Users and possessors of this source code are     *|
-|*     hereby granted a nonexclusive,  royalty-free copyright license to     *|
-|*     use this code in individual and commercial software.                  *|
-|*                                                                           *|
-|*     Any use of this source code must include,  in the user documenta-     *|
-|*     tion and  internal comments to the code,  notices to the end user     *|
-|*     as follows:                                                           *|
-|*                                                                           *|
-|*       Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.      *|
-|*                                                                           *|
-|*     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY     *|
-|*     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"     *|
-|*     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-     *|
-|*     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,     *|
-|*     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-     *|
-|*     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL     *|
-|*     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-     *|
-|*     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-     *|
-|*     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION     *|
-|*     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF     *|
-|*     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.     *|
-|*                                                                           *|
-|*     U.S. Government  End  Users.   This source code  is a "commercial     *|
-|*     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),     *|
-|*     consisting  of "commercial  computer  software"  and  "commercial     *|
-|*     computer  software  documentation,"  as such  terms  are  used in     *|
-|*     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-     *|
-|*     ment only as  a commercial end item.   Consistent with  48 C.F.R.     *|
-|*     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),     *|
-|*     all U.S. Government End Users  acquire the source code  with only     *|
-|*     those rights set forth herein.                                        *|
-|*                                                                           *|
- \***************************************************************************/
-/* $XFree86: xc/programs/Xserver/hw/xfree86/vga256/drivers/nv/nv4cursor.c,v 1.1.2.4 1998/11/18 16:38:47 hohndel Exp $ */
-/*
- * Copyright 1996-1997  David J. McKay
- *
- * Permission is hereby granted, free of charge, to any person obtaining a 
- * copy of this software and associated documentation files (the "Software"), 
- * to deal in the Software without restriction, including without limitation 
- * the rights to use, copy, modify, merge, publish, distribute, sublicense, 
- * and/or sell copies of the Software, and to permit persons to whom the 
- * Software is furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- * 
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL 
- * DAVID J. MCKAY BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, 
- * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF 
- * OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE 
- * SOFTWARE.
- */
-
-/* $XFree86: xc/programs/Xserver/hw/xfree86/vga256/drivers/nv/nv4cursor.c,v 1.1.2.4 1998/11/18 16:38:47 hohndel Exp $ */
-
-#include "X.h"
-#include "Xproto.h"
-#include "misc.h"
-#include "input.h"
-#include "cursorstr.h"
-#include "regionstr.h"
-#include "scrnintstr.h"
-#include "servermd.h"
-#include "windowstr.h"
-
-#include "compiler.h"
-#include "xf86.h"
-#include "mipointer.h"
-#include "xf86Priv.h"
-#include "xf86_Option.h"
-#include "xf86_OSlib.h"
-#include "vga256.h"
-#include "vga.h"
-
-#include "miline.h"
-
-#include "nvreg.h"
-#include "nvcursor.h"
-
-
-static Bool NV4RealizeCursor();
-static Bool NV4UnrealizeCursor();
-static void NV4SetCursor();
-static void NV4MoveCursor();
-static void NV4RecolorCursor();
-
-static miPointerSpriteFuncRec NV4PointerSpriteFuncs =
-{
-    NV4RealizeCursor,
-    NV4UnrealizeCursor,
-    NV4SetCursor,
-    NV4MoveCursor,
-};
-
-extern miPointerScreenFuncRec xf86PointerScreenFuncs;
-extern xf86InfoRec xf86Info;
-static int NV4CursorGeneration = -1;
-static int NV4CursorHotX;
-static int NV4CursorHotY;
-static CursorPtr NV4CursorpCurs;
-
-Bool NV4CursorInit(char *pm,ScreenPtr pScr)
-{
-    unsigned char power;
-
-    NV4CursorHotX = 0;
-    NV4CursorHotY = 0;
-
-    if (NV4CursorGeneration != serverGeneration)
-    {
-        if (!(miPointerInitialize(pScr, &NV4PointerSpriteFuncs,
-                                  &xf86PointerScreenFuncs, 0 )))
-        {
-            return 0 ;
-        }
-        pScr->RecolorCursor = NV4RecolorCursor;
-        NV4CursorGeneration = serverGeneration;
-    }
-    return 1 ;
-}
-
-static void NV4ShowCursor(void)
-{
-    unsigned char tmp;
-    tmp = (outb(980, 49  ),inb(981)) |1| (( 1    ) << (0))   ;
-    outb(980,( 49  ));outb(981, tmp ) ;
-}
-
-void NV4HideCursor(void)
-{
-    unsigned char tmp;
-    tmp = (outb(980, 49  ),inb(981)) &(~(( 1    ) << (0))   );
-    outb(980,( 49  ));outb(981, tmp ) ;
-}
-
-typedef struct
-{
-    unsigned short foreColour,  
-    backColour;
-    unsigned short image[32 * 32 ];  
-    int address;  
-}NV4Cursor;
-
-static unsigned short ConvertToRGB555(int red,int green,int blue)
-{
-    unsigned short colour;
-
-    colour=((red>>11)&31)<<10;
-    colour|=((green>>11)&31)<<5;
-    colour|=((blue>>11)&31);
-    colour|=1<<15;  
-    return colour;
-}
-
-static void RenderCursor(CursorBits *bits,NV4Cursor *cursor)
-{
-    int x,y,i;
-    int byteIndex,bitIndex,maskBit,sourceBit;
-    int height,width;
-    int pad,lineOffset;
-    unsigned char *source,*mask;
-
-    height = bits->height;
-    width=bits->width;
-    source=(unsigned char*)bits->source;
-    pad= ((PixmapWidthPaddingInfo[    1  ].notPower2 ? (((int)(  bits->width  ) * PixmapWidthPaddingInfo[    1  ].bytesPerPixel + PixmapWidthPaddingInfo[    1  ].bytesPerPixel) >> PixmapWidthPaddingInfo[    1  ].padBytesLog2) : ((int)((  bits->width  ) + PixmapWidthPaddingInfo[    1  ].padRoundUp) >> PixmapWidthPaddingInfo[    1  ].padPixelsLog2))  << PixmapWidthPaddingInfo[  1 ].padBytesLog2) ; 
-    mask=(unsigned char*)bits->mask;
-    for (y=0,i=0,lineOffset=0;y< 32 ;y++,lineOffset+=pad)
-    {
-        for (x=0;x< 32 ;x++,i++)
-        {
-            if (x<width && y<height)
-            {
-                byteIndex=lineOffset+(x/8);bitIndex=x%8;
-                maskBit=mask[byteIndex]&(1<<bitIndex);
-                sourceBit=source[byteIndex]&(1<<bitIndex);
-                if (maskBit)
-                {
-                    cursor->image[i]=(sourceBit) ? cursor->foreColour :
-                                     cursor->backColour;
-                }
-                else
-                {
-                    cursor->image[i]= 0 ;
-                }
-            }
-            else
-            {
-                cursor->image[i]= 0 ;
-            }
-        }
-    }
-}
-
-static Bool NV4RealizeCursor(ScreenPtr pScr,CursorPtr pCurs)
-{
-    NV4Cursor *ram;
-    int index = pScr->myNum;
-    pointer *pPriv = &pCurs->bits->devPriv[index];
-    CursorBits *bits = pCurs->bits;
-
-     
-    if (pCurs->bits->refcnt > 1) return 1 ;
-
-    ram = (NV4Cursor*)Xalloc((unsigned long)( sizeof(NV4Cursor) )) ;
-    *pPriv = (pointer) ram;
-    if (!ram) return 0 ;
-    ram->foreColour=
-    ConvertToRGB555(pCurs->foreRed,pCurs->foreGreen,pCurs->foreBlue);
-    ram->backColour=
-    ConvertToRGB555(pCurs->backRed,pCurs->backGreen,pCurs->backBlue);
-    RenderCursor(bits,ram);
-    return 1 ;
-}
-
-static Bool NV4UnrealizeCursor(ScreenPtr pScr,CursorPtr pCurs)
-{
-    pointer priv;
-
-    if (pCurs->bits->refcnt <= 1 &&
-        (priv = pCurs->bits->devPriv[pScr->myNum]))
-    {
-        Xfree((pointer)( priv )) ;
-        pCurs->bits->devPriv[pScr->myNum] = 0;
-    }
-    return 1 ;
-}
-
-static void NV4LoadCursorToCard(ScreenPtr pScr,CursorPtr pCurs)
-{
-    NV4Cursor *cursor;
-    int index = pScr->myNum;
-    int i;
-    int numInts;
-    int *image;
-    int save;
-
-    if (!xf86VTSema)
-        return;
-    cursor=(NV4Cursor*) pCurs->bits->devPriv[index];
-    numInts=sizeof(cursor->image)/sizeof(int);
-    image=(int*)cursor->image;
-    save= (outb(980, 49  ),inb(981)) ;
-    outb(980,( 49  ));outb(981, 0 ) ;
-    for (i=0;i<numInts;i++)
-    {
-        nvPRAMINPort[ ((65536)/4) +i ]=( image[i] ) ;
-    }
-    outb(980,( 48  ));outb(981, (( (((unsigned)((  ((65536)/4) *4+65536  ) & (((unsigned)(1U << ((( 23)-( 17)+1)))-1)  << ( 17))  )) >> (17) )  ) << (0))   ) ;
-    save&=3;
-    outb(980,( 49  ));outb(981, save| (( (((unsigned)((  ((65536)/4) *4+65536  ) & (((unsigned)(1U << ((( 16)-( 11)+1)))-1)  << ( 11))  )) >> (11) )  ) << (2))   ) ;
-}
-
-static void NV4LoadCursor(ScreenPtr pScr,CursorPtr pCurs,int x,int y)
-{
-
-    if (!xf86VTSema)
-        return;
-    if (!pCurs)
-        return;
-    NV4CursorpCurs = pCurs;
-    NV4HideCursor();
-    NV4LoadCursorToCard(pScr, pCurs);
-    NV4MoveCursor(pScr, x, y);
-    NV4ShowCursor();
-}
-
-static void NV4SetCursor(ScreenPtr pScr,CursorPtr pCurs,int x,int y,
-                         Bool generateEvent)
-{
-    if (!pCurs)
-        return;
-    NV4CursorHotX = pCurs->bits->xhot;
-    NV4CursorHotY = pCurs->bits->yhot;
-    NV4LoadCursor(pScr, pCurs, x, y);
-}
-
-void NV4RestoreCursor(ScreenPtr pScr)
-{
-    int x, y;
-
-    miPointerPosition(&x, &y);
-    NV4LoadCursor(pScr, NV4CursorpCurs, x, y);
-}
-
-static void NV4MoveCursor(ScreenPtr pScr,int x,int y)
-{
-    int xorigin, yorigin;
-
-    if (!xf86VTSema) return;
-    x -= vga256InfoRec.frameX0 + NV4CursorHotX;
-    y -= vga256InfoRec.frameY0 + NV4CursorHotY;
-    x &= (((unsigned)(1U << ((( 11)-( 0)+1)))-1)  << ( 0))    ;
-    nvPRAMDACPort[((6816512    )- (6815744) )/4] =(  
-                  ((   x   ) << (0))   | ((   y   ) << (16))     )  ;
-}
-
-static void NV4RecolorCursor(ScreenPtr pScr,CursorPtr pCurs,Bool displayed)
-{
-    CursorBits *bits = pCurs->bits;
-    int index = pScr->myNum;
-    NV4Cursor *cursor=(NV4Cursor*) pCurs->bits->devPriv[index];
-    unsigned short fore,back;
-
-    if (!xf86VTSema) return;
-    if (!displayed) return;
-    fore=ConvertToRGB555(pCurs->foreRed,pCurs->foreGreen,pCurs->foreBlue);
-    back=ConvertToRGB555(pCurs->backRed,pCurs->backGreen,pCurs->backBlue);
-    if (cursor->foreColour==fore && cursor->backColour==back) return;
-    NV4LoadCursorToCard(pScr,pCurs);
-}
-
-void NV4WarpCursor(ScreenPtr pScr,int x,int y)
-{
-    miPointerWarpCursor(pScr, x, y);
-    xf86Info.currentScreen = pScr;
-}
-
-void NV4QueryBestSize(int class,unsigned short *pwidth,
-                      unsigned short *pheight,ScreenPtr pScreen)
-{
-    if (*pwidth > 0)
-    {
-        if (class == 0 )
-        {
-            *pwidth = 32 ;
-            *pheight = 32 ;
-        }
-        else
-            (void)mfbQueryBestSize(class, pwidth, pheight, pScreen);
-    }
-}
-
Index: xc/programs/Xserver/hw/xfree86/vga256/drivers/nv/nv4driver.c
diff -u xc/programs/Xserver/hw/xfree86/vga256/drivers/nv/nv4driver.c:1.1.2.4 xc/programs/Xserver/hw/xfree86/vga256/drivers/nv/nv4driver.c:removed
--- xc/programs/Xserver/hw/xfree86/vga256/drivers/nv/nv4driver.c:1.1.2.4	Thu Nov 19 03:38:48 1998
+++ xc/programs/Xserver/hw/xfree86/vga256/drivers/nv/nv4driver.c	Wed Jan  6 00:32:33 1999
@@ -1,480 +0,0 @@
- /***************************************************************************\
-|*                                                                           *|
-|*       Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.      *|
-|*                                                                           *|
-|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
-|*     international laws.  Users and possessors of this source code are     *|
-|*     hereby granted a nonexclusive,  royalty-free copyright license to     *|
-|*     use this code in individual and commercial software.                  *|
-|*                                                                           *|
-|*     Any use of this source code must include,  in the user documenta-     *|
-|*     tion and  internal comments to the code,  notices to the end user     *|
-|*     as follows:                                                           *|
-|*                                                                           *|
-|*       Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.      *|
-|*                                                                           *|
-|*     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY     *|
-|*     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"     *|
-|*     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-     *|
-|*     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,     *|
-|*     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-     *|
-|*     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL     *|
-|*     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-     *|
-|*     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-     *|
-|*     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION     *|
-|*     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF     *|
-|*     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.     *|
-|*                                                                           *|
-|*     U.S. Government  End  Users.   This source code  is a "commercial     *|
-|*     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),     *|
-|*     consisting  of "commercial  computer  software"  and  "commercial     *|
-|*     computer  software  documentation,"  as such  terms  are  used in     *|
-|*     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-     *|
-|*     ment only as  a commercial end item.   Consistent with  48 C.F.R.     *|
-|*     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),     *|
-|*     all U.S. Government End Users  acquire the source code  with only     *|
-|*     those rights set forth herein.                                        *|
-|*                                                                           *|
- \***************************************************************************/
-/* $XFree86: xc/programs/Xserver/hw/xfree86/vga256/drivers/nv/nv4driver.c,v 1.1.2.4 1998/11/18 16:38:48 hohndel Exp $ */
-/*
- * Copyright 1996-1997  David J. McKay
- *
- * Permission is hereby granted, free of charge, to any person obtaining a
- * copy of this software and associated documentation files (the "Software"),
- * to deal in the Software without restriction, including without limitation
- * the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the
- * Software is furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
- * DAVID J. MCKAY BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
- * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF
- * OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
- * SOFTWARE.
- */
-
-#include <math.h>
-#include <stdlib.h>
-
-
-#include "X.h"
-#include "input.h"
-#include "screenint.h"
-
-#include "compiler.h"
-#include "xf86.h"
-#include "xf86Priv.h"
-#include "xf86_OSlib.h"
-#include "xf86_HWlib.h"
-#include "vga.h"
-
-#include "vgaPCI.h"
-
-#define XCONFIG_FLAGS_ONLY
-#include "xf86_Config.h"
-
-
-#ifdef XFreeXDGA
-#include "X.h"
-#include "Xproto.h"
-#include "scrnintstr.h"
-#include "servermd.h"
-#define _XF86DGA_SERVER_
-#include "extensions/xf86dgastr.h"
-#endif
-
-#include "nvcursor.h"
-#include "nvreg.h"
-
-#include "nvvga.h"
-
-static unsigned ramType, crystalFreq;
-
-void NV4EnterLeave(Bool enter)
-{
-    unsigned char temp;
-
-    if (enter)
-    {
-        xf86EnableIOPorts(vga256InfoRec.scrnIndex);
-        outb(vgaIOBase + 4, 17); temp = inb(vgaIOBase + 5);
-        outb(vgaIOBase + 5, temp & 127);
-        outb(980,( 31  ));outb(981,  87  ) ;
-    }
-    else
-    {
-        outb(vgaIOBase + 4, 17); temp = inb(vgaIOBase + 5);
-        outb(vgaIOBase + 5, (temp & 127) | 128);
-        outb(980,( 31  ));outb(981,  153  ) ;
-        xf86DisableIOPorts(vga256InfoRec.scrnIndex);
-    }
-}
-
-static void MapNV4Regs(void *regBase,void *frameBase)
-{
-    nvPRAMDACPort=(unsigned*)xf86MapVidMem(vga256InfoRec.scrnIndex, 3 , ((char*)( regBase ))+ (6815744) , ((6819839) - (6815744) +1) ) ;
-    nvPFBPort=(unsigned*)xf86MapVidMem(vga256InfoRec.scrnIndex, 3 , ((char*)( regBase ))+ (1048576) , ((1052671) - (1048576) +1) ) ;
-    nvPFIFOPort=(unsigned*)xf86MapVidMem(vga256InfoRec.scrnIndex, 3 , ((char*)( regBase ))+ (8192) , ((16383) - (8192) +1) ) ;
-    nvPGRAPHPort=(unsigned*)xf86MapVidMem(vga256InfoRec.scrnIndex, 3 , ((char*)( regBase ))+ (4194304) , ((4202495) - (4194304) +1) ) ;
-    nvPEXTDEVPort=(unsigned*)xf86MapVidMem(vga256InfoRec.scrnIndex, 3 , ((char*)( regBase ))+ (1052672) , ((1056767) - (1052672) +1) ) ;
-    nvPTIMERPort=(unsigned*)xf86MapVidMem(vga256InfoRec.scrnIndex, 3 , ((char*)( regBase ))+ (36864) , ((40959) - (36864) +1) ) ;
-    nvPMCPort=(unsigned*)xf86MapVidMem(vga256InfoRec.scrnIndex, 3 , ((char*)( regBase ))+ (0) , ((4095) - (0) +1) ) ;
-    nvCHAN0Port=(unsigned*)xf86MapVidMem(vga256InfoRec.scrnIndex, 3 , ((char*)( regBase ))+ (8388608) , ((8454143) - (8388608) +1) ) ;
-    nvPRAMINPort = (unsigned *)xf86MapVidMem(vga256InfoRec.scrnIndex,
-                                             3 ,
-                                             ((char *)regBase+ (7340032) +65536),
-                                             67584);
-}
-
-static void NV4FlipFunctions(vgaVideoChipRec *nv);
-
-int NV4Probe(vgaVideoChipRec *nv,void *base0,void *base1)
-{
-    int noaccel= (( &vga256InfoRec.options )->flag_bits[( 60  )/ (8 * sizeof(CARD32)) ] & (1 << (( 60  )% (8 * sizeof(CARD32)) ))) ;
-
-    MapNV4Regs(base0,base1);
-    crystalFreq= (nvPEXTDEVPort[((1052672    )- (1052672) )/4]    & (( 1    ) << (6))   ) ? 14318 : 13500;
-     
-    switch (nvPFBPort[((1048576    )- (1048576) )/4]    & (((unsigned)(1U << ((( 1)-( 0)+1)))-1)  << ( 0))    )
-    {
-        case 0 :
-            vga256InfoRec.videoRam = 1024 * 32;
-            break;
-        case 1 :
-            vga256InfoRec.videoRam = 1024 * 4;
-            break;
-        case 2 :
-            vga256InfoRec.videoRam = 1024 * 8;
-            break;
-        case 3 :
-        default:
-            vga256InfoRec.videoRam = 1024 * 16;
-            break;
-    }
-    switch ((nvPFBPort[((1048576    )- (1048576) )/4]    & (((unsigned)(1U << ((( 4)-( 3)+1)))-1)  << ( 3))    ) >> 3)
-    {
-        case 3 :
-            ramType = 1 ;
-            break;
-        default:
-            ramType = 0 ;
-            break;
-    }
-    nv->ChipLinearSize=vga256InfoRec.videoRam * 1024;
-    vga256InfoRec.maxClock = 250000 ;
-    nv->ChipLinearBase=(int)base1;
-    nv->ChipHas32bpp= 1 ;
-    xf86ClearIOPortList (vga256InfoRec.scrnIndex);
-    xf86AddIOPorts(vga256InfoRec.scrnIndex,Num_VGA_IOPorts,VGA_IOPorts);
-    xf86EnableIOPorts(vga256InfoRec.scrnIndex);
-    vgaIOBase = (inb(972) & 1) ? 976 : 944;
-    NV4EnterLeave(1 );
-    if (vgaBitsPerPixel==16 && !noaccel)
-    {
-        ErrorF("%s %s: %s: Setting RGB weight to 555\n","(--)" ,
-               vga256InfoRec.name,
-               vga256InfoRec.chipset);
-        xf86weight.green=xf86weight.blue=xf86weight.red=5;
-    }
-    ((  &(nv->ChipOptionFlags) )->flag_bits[( 60  )/ (8 * sizeof(CARD32)) ] |= (1 << (( 60  )% (8 * sizeof(CARD32)) ))) ;
-    ((  &(nv->ChipOptionFlags) )->flag_bits[( 62  )/ (8 * sizeof(CARD32)) ] |= (1 << (( 62  )% (8 * sizeof(CARD32)) ))) ;
-    NV4FlipFunctions(nv);
-    return (1);
-}
-
-static int NV4ClockSelect(float clockIn,float *clockOut,int *mOut,int *nOut,int *pOut)
-{
-    unsigned lowM,     highM;
-    unsigned DeltaNew, DeltaOld;
-    unsigned VClk;
-    unsigned Freq;
-    unsigned M;
-    unsigned N;
-    unsigned O;
-    unsigned P;
-    
-    DeltaOld = -1;
-    VClk     = (unsigned)clockIn;
-
-    if (crystalFreq == 14318)
-    {
-        lowM  = 8;
-        highM = 14;
-    }
-    else
-    {
-        lowM  = 7;
-        highM = 13;
-    }                      
-    for (P = 0; P <= 4; P ++)
-    {
-        Freq = VClk << P;
-        if ((Freq >= 128000) && (Freq <= 256000))
-        {
-            for (M = lowM; M <= highM; M++)
-            {
-                N    = (VClk * M / crystalFreq) << P;
-                Freq = (crystalFreq * N / M) >> P;
-                if (Freq > VClk)
-                    DeltaNew = Freq - VClk;
-                else
-                    DeltaNew = VClk - Freq;
-                if (DeltaNew < DeltaOld)
-                {
-                    *mOut     = M;
-                    *nOut     = N;
-                    *pOut     = P;
-                    *clockOut = (float)VClk;
-                    DeltaOld  = DeltaNew;
-                }
-            }
-        }
-    }
-    return (DeltaOld != -1);
-}
-
-static int CalculateCRTC(DisplayModePtr mode)
-{
-    int bpp          = vgaBitsPerPixel/8;
-    int horizDisplay = (mode->CrtcHDisplay/8) - 1;
-    int horizStart   = (mode->CrtcHSyncStart/8) - 1;
-    int horizEnd     = (mode->CrtcHSyncEnd/8) - 1;
-    int horizTotal   = (mode->CrtcHTotal/8) - 1;
-    int vertDisplay  = mode->CrtcVDisplay - 1;
-    int vertStart    = mode->CrtcVSyncStart  - 1;
-    int vertEnd      = mode->CrtcVSyncEnd - 1;
-    int vertTotal    = mode->CrtcVTotal - 2;
-
-    ((vgaNVPtr)vgaNewVideoState)->std.CRTC[19]=((vga256InfoRec.displayWidth/8)*bpp)&255;
-    ((vgaNVPtr)vgaNewVideoState)->regs.nv4.repaint0=
-        (( (((unsigned)((  (vga256InfoRec.displayWidth/8)*bpp  ) & (((unsigned)(1U << ((( 10)-( 8)+1)))-1)  << ( 8))  )) >> (8) )  ) << (5))  ;
-    ((vgaNVPtr)vgaNewVideoState)->std.CRTC[0]  = (( horizTotal - 4 )&255) ;
-    ((vgaNVPtr)vgaNewVideoState)->std.CRTC[1]  = (( horizDisplay )&255) ;
-    ((vgaNVPtr)vgaNewVideoState)->std.CRTC[2]  = (( horizDisplay )&255) ;
-    ((vgaNVPtr)vgaNewVideoState)->std.CRTC[3]  = (( (((unsigned)((  horizTotal  ) & (((unsigned)(1U << ((( 4)-( 0)+1)))-1)  << ( 0))  )) >> (0) )  ) << (0))   | (1<<( 7 )) ;
-    ((vgaNVPtr)vgaNewVideoState)->std.CRTC[4]  = (( horizStart )&255) ;
-    ((vgaNVPtr)vgaNewVideoState)->std.CRTC[5]  = (( (((unsigned)((  horizTotal  ) & (((unsigned)(1U << ((( 5)-( 5)+1)))-1)  << ( 5))  )) >> (5) )  ) << (7))  |
-                                                 (( (((unsigned)((  horizEnd  ) & (((unsigned)(1U << ((( 4)-( 0)+1)))-1)  << ( 0))  )) >> (0) )  ) << (0))  ;
-    ((vgaNVPtr)vgaNewVideoState)->std.CRTC[6]  = (( (((unsigned)((  vertTotal  ) & (((unsigned)(1U << ((( 7)-( 0)+1)))-1)  << ( 0))  )) >> (0) )  ) << (0))  ;
-    ((vgaNVPtr)vgaNewVideoState)->std.CRTC[7]  = (( (((unsigned)((  vertTotal  ) & (((unsigned)(1U << ((( 8)-( 8)+1)))-1)  << ( 8))  )) >> (8) )  ) << (0))  |
-                                                 (( (((unsigned)((  vertDisplay  ) & (((unsigned)(1U << ((( 8)-( 8)+1)))-1)  << ( 8))  )) >> (8) )  ) << (1))  |
-                                                 (( (((unsigned)((  vertStart  ) & (((unsigned)(1U << ((( 8)-( 8)+1)))-1)  << ( 8))  )) >> (8) )  ) << (2))  |
-                                                 (( (((unsigned)((  vertDisplay  ) & (((unsigned)(1U << ((( 8)-( 8)+1)))-1)  << ( 8))  )) >> (8) )  ) << (3))  |
-                                                 (1<<( 4 )) |
-                                                 (( (((unsigned)((  vertTotal  ) & (((unsigned)(1U << ((( 9)-( 9)+1)))-1)  << ( 9))  )) >> (9) )  ) << (5))  |
-                                                 (( (((unsigned)((  vertDisplay  ) & (((unsigned)(1U << ((( 9)-( 9)+1)))-1)  << ( 9))  )) >> (9) )  ) << (6))  |
-                                                 (( (((unsigned)((  vertStart  ) & (((unsigned)(1U << ((( 9)-( 9)+1)))-1)  << ( 9))  )) >> (9) )  ) << (7))  ;
-    ((vgaNVPtr)vgaNewVideoState)->std.CRTC[9]  = (( (((unsigned)((  vertDisplay  ) & (((unsigned)(1U << ((( 9)-( 9)+1)))-1)  << ( 9))  )) >> (9) )  ) << (5))   | (1<<( 6 )) ;
-    ((vgaNVPtr)vgaNewVideoState)->std.CRTC[10]  = 0;
-    ((vgaNVPtr)vgaNewVideoState)->std.CRTC[11]  = 0;
-    ((vgaNVPtr)vgaNewVideoState)->std.CRTC[12]  = 0;
-    ((vgaNVPtr)vgaNewVideoState)->std.CRTC[13]  = 0;
-    ((vgaNVPtr)vgaNewVideoState)->std.CRTC[14]  = 0;
-    ((vgaNVPtr)vgaNewVideoState)->std.CRTC[15]  = 0;
-    ((vgaNVPtr)vgaNewVideoState)->std.CRTC[16] = (( vertStart )&255) ;
-    ((vgaNVPtr)vgaNewVideoState)->std.CRTC[17] = (( (((unsigned)((  vertEnd  ) & (((unsigned)(1U << ((( 3)-( 0)+1)))-1)  << ( 0))  )) >> (0) )  ) << (0))   | (1<<( 5 )) ;
-    ((vgaNVPtr)vgaNewVideoState)->std.CRTC[18] = (( vertDisplay )&255) ;
-    ((vgaNVPtr)vgaNewVideoState)->std.CRTC[21] = (( vertDisplay )&255) ;
-    ((vgaNVPtr)vgaNewVideoState)->std.CRTC[22] = (( vertTotal + 1 )&255) ;
-    ((vgaNVPtr)vgaNewVideoState)->regs.nv4.screenExtra = (( (((unsigned)((  horizTotal  ) & (((unsigned)(1U << ((( 6)-( 6)+1)))-1)  << ( 6))  )) >> (6) )  ) << (4))   |
-                                                       (( (((unsigned)((  vertDisplay  ) & (((unsigned)(1U << ((( 10)-( 10)+1)))-1)  << ( 10))  )) >> (10) )  ) << (3))   |
-                                                       (( (((unsigned)((  vertStart  ) & (((unsigned)(1U << ((( 10)-( 10)+1)))-1)  << ( 10))  )) >> (10) )  ) << (2))   |
-                                                       (( (((unsigned)((  vertDisplay  ) & (((unsigned)(1U << ((( 10)-( 10)+1)))-1)  << ( 10))  )) >> (10) )  ) << (1))   |
-                                                       (( (((unsigned)((  vertTotal  ) & (((unsigned)(1U << ((( 10)-( 10)+1)))-1)  << ( 10))  )) >> (10) )  ) << (0))  ;
-    if (mode->Flags & 32 ) ((vgaNVPtr)vgaNewVideoState)->std.CRTC[9] |= 128;
-    ((vgaNVPtr)vgaNewVideoState)->regs.nv4.horizExtra = (horizTotal < 260 ? 0 : 1);
-    return (1);
-}
-
-
-static void InitPalette(DisplayModePtr mode)
-{
-    int bpp=vgaBitsPerPixel/8;
-    int i;
-
-    if(! (!(vgaBitsPerPixel==8 || xf86weight.green==6)) ) return;
-    for (i=0;i<256;i++)
-    {
-        ((vgaNVPtr)vgaNewVideoState)->std.DAC[i*3]=i>>2;
-        ((vgaNVPtr)vgaNewVideoState)->std.DAC[(i*3)+1]=i>>2;
-        ((vgaNVPtr)vgaNewVideoState)->std.DAC[(i*3)+2]=i>>2;
-    }
-}
-
-static Bool NV4Init(DisplayModePtr mode)
-{
-    int m,n,p;
-    float clockIn=(float)vga256InfoRec.clock[mode->Clock];
-    float clockOut;
-    int time,data;
-    int i;
-    int pixelDepth;
-
-    if (!vgaHWInit (mode, sizeof (vgaNVRec)))
-        return (0);
-    ((vgaNVPtr)vgaNewVideoState)->vgaValid=1;
-    InitPalette(mode);
-    ((vgaNVPtr)vgaNewVideoState)->regs.nv4.config0 = 285217044;
-    pixelDepth = (vgaBitsPerPixel+1)/8;
-    if (pixelDepth > 3) pixelDepth = 3;
-    ((vgaNVPtr)vgaNewVideoState)->regs.nv4.pixelFormat=pixelDepth;
-    CalculateCRTC(mode);
-    ((vgaNVPtr)vgaNewVideoState)->regs.nv4.repaint1 =
-        ((   mode->CrtcHDisplay<1280   ) << (2))   ;
-    ((vgaNVPtr)vgaNewVideoState)->regs.nv4.generalControl=
-        (( 0    ) << (4))   |
-        ((   xf86weight.green==6   ) << (12))   |
-        (( 0    ) << (17))   |
-        (( 0    ) << (20))   |
-        (( 1    ) << (8))   ;
-    if (!NV4ClockSelect(clockIn,&clockOut,&m,&n,&p))
-    {
-        ErrorF("%s %s: %s: Unable to set desired video clock\n",
-               "(--)" , vga256InfoRec.name,vga256InfoRec.chipset);
-        return (0 );
-    }
-    ((vgaNVPtr)vgaNewVideoState)->regs.nv4.vpllCoeff=
-        ((   n   ) << (8))    |
-        ((   m   ) << (0))    |
-        ((   p   ) << (16))   ;
-    nv4UpdateArbitrationSettings((unsigned int)clockOut, 
-                                 pixelDepth*8, 
-                                 crystalFreq,
-                                &(((vgaNVPtr)vgaNewVideoState)->regs.nv4.fifo),
-                                &(((vgaNVPtr)vgaNewVideoState)->regs.nv4.fifoControl));
-    ((vgaNVPtr)vgaNewVideoState)->regs.nv4.coeffSelect = 268437248;
-    return (1 );
-}
-
-static void NV4Restore(void *data)
-{
-    int i, j;
-    vgaNVPtr restore=data;
-    NV4Registers *nv4=&(restore->regs.nv4);
-
-    vgaProtect(1 );
-    outb(980,( 25  ));outb(981, nv4->repaint0 ) ;
-    outb(980,( 26  ));outb(981, nv4->repaint1 ) ;
-    outb(980,( 37  ));outb(981, nv4->screenExtra ) ;
-    outb(980,( 40  ));outb(981, nv4->pixelFormat ) ;
-    outb(980,( 45  ));outb(981, nv4->horizExtra ) ;
-    outb(980,( 27  ));outb(981, nv4->fifoControl ) ;
-    outb(980,( 32  ));outb(981, nv4->fifo ) ;
-    nvPFBPort[((1049088    )- (1048576) )/4] =(  nv4->config0  )  ;
-    nvPRAMDACPort[((6817032    )- (6815744) )/4] =(  nv4->vpllCoeff  )  ;
-    nvPRAMDACPort[((6817036    )- (6815744) )/4] =(  nv4->coeffSelect  )  ;
-    nvPRAMDACPort[((6817280    )- (6815744) )/4] =(  nv4->generalControl  )  ;
-    vgaHWRestore((vgaHWPtr)restore);
-    vgaProtect(0 );
-}
-
-static void *NV4Save(void *data)
-{
-    vgaNVPtr save= ((void *)0) ;
-
-    save=(vgaNVPtr)vgaHWSave((vgaHWPtr)data,sizeof(vgaNVRec));
-    save->regs.nv4.repaint0= (outb(980, 25  ),inb(981)) ;
-    save->regs.nv4.repaint1= (outb(980, 26  ),inb(981)) ;
-    save->regs.nv4.screenExtra= (outb(980, 37  ),inb(981)) ;
-    save->regs.nv4.pixelFormat= (outb(980, 40  ),inb(981)) ;
-    save->regs.nv4.horizExtra= (outb(980, 45  ),inb(981)) ;
-    save->regs.nv4.fifoControl= (outb(980, 27  ),inb(981)) ;
-    save->regs.nv4.fifo= (outb(980, 32  ),inb(981)) ;
-    save->regs.nv4.config0= nvPFBPort[((1049088    )- (1048576) )/4]   ;
-    save->regs.nv4.vpllCoeff= nvPRAMDACPort[((6817032    )- (6815744) )/4]   ;
-    save->regs.nv4.coeffSelect= nvPRAMDACPort[((6817036    )- (6815744) )/4]   ;
-    save->regs.nv4.generalControl= nvPRAMDACPort[((6817280    )- (6815744) )/4]   ;
-    return (void*)save;
-}
-
-static void NV4Adjust(int x,int y)
-{
-    int bpp=vgaBitsPerPixel/8;
-    int startAddr=(((y*vga256InfoRec.virtualX)+x)*bpp);
-    int offset=startAddr>>2;
-    int pan=(startAddr&3)*2;
-    unsigned char byte;
-
-    outb(980,( 31  ));outb(981,  87  ) ;
-     
-    outb(980,( 13 ));outb(981, (( offset )&255)  ) ;
-    outb(980,( 12 ));outb(981, (( (((unsigned)((  offset  ) & (((unsigned)(1U << ((( 15)-( 8)+1)))-1)  << ( 8))  )) >> (8) )  ) << (0))   ) ;
-    byte= (outb(980, 25  ),inb(981))  & ~(((unsigned)(1U << ((( 4)-( 0)+1)))-1)  << ( 0))    ;
-    outb(980,( 25  ));outb(981, (( (((unsigned)((  offset  ) & (((unsigned)(1U << ((( 20)-( 16)+1)))-1)  << ( 16))  )) >> (16) )  ) << (0))  |byte ) ;
-     
-    byte=inb(vgaIOBase+10);
-    outb(960,19);
-    outb(960,pan);
-}
-
-static int NV4ValidMode(DisplayModePtr mode,Bool verbose,int flag)
-{
-    unsigned bw, bwMax, bpp;
-
-    bpp = (vgaBitsPerPixel + 1) / 8;
-    bwMax = (ramType == 0 ) ? 1000000 : 800000;
-    bw = mode->Clock * bpp;
-    return (bw > bwMax ? 255  : 0 );
-}
-
-extern vgaHWCursorRec vgaHWCursor;
-
-static void NV4FbInit(void)
-{
-    if (! ((  &vga256InfoRec.options )->flag_bits[( 62  )/ (8 * sizeof(CARD32)) ] & (1 << (( 62  )% (8 * sizeof(CARD32)) ))) )
-    {
-        vgaHWCursor.Initialized = 1 ;
-        vgaHWCursor.Init = NV4CursorInit;
-        vgaHWCursor.Restore = NV4RestoreCursor;
-        vgaHWCursor.Warp = NV4WarpCursor;
-        vgaHWCursor.QueryBestSize = NV4QueryBestSize;
-        if (xf86Verbose)
-        {
-            ErrorF("%s %s: %s: Using hardware cursor\n","(--)" ,
-                   vga256InfoRec.name,vga256InfoRec.chipset);
-        }
-    }
-    if (! ((  &vga256InfoRec.options )->flag_bits[( 60  )/ (8 * sizeof(CARD32)) ] & (1 << (( 60  )% (8 * sizeof(CARD32)) ))) )
-    {
-        NVAccelInit();
-    }
-}
-
-static void NV4DisplayPowerManagementSet(int mode)
-{
-}
-
-static Bool NV4ScreenInit(ScreenPtr pScreen,pointer pbits,
-                          int xsize,int ysize,int dpix,int dpiy,int width)
-{
-    return (1 );
-}
-
-static void NV4SaveScreen(int on)
-{
-    vgaHWSaveScreen(on);
-}
-
-static void NV4GetMode(DisplayModePtr display)
-{
-    
-}
-
-static void NV4FlipFunctions(vgaVideoChipRec *nv)
-{
-    nv->ChipEnterLeave=NV4EnterLeave;
-    nv->ChipInit=NV4Init;
-    nv->ChipValidMode=NV4ValidMode;
-    nv->ChipSave=NV4Save;
-    nv->ChipRestore=NV4Restore;
-    nv->ChipAdjust=NV4Adjust;
-    nv->ChipSaveScreen=NV4SaveScreen;
-    nv->ChipGetMode=(void (*)())NoopDDA;
-    nv->ChipFbInit=NV4FbInit;
-}
Index: xc/programs/Xserver/hw/xfree86/vga256/drivers/nv/nv4setup.c
diff -u xc/programs/Xserver/hw/xfree86/vga256/drivers/nv/nv4setup.c:1.1.2.3 xc/programs/Xserver/hw/xfree86/vga256/drivers/nv/nv4setup.c:removed
--- xc/programs/Xserver/hw/xfree86/vga256/drivers/nv/nv4setup.c:1.1.2.3	Thu Nov 19 03:38:49 1998
+++ xc/programs/Xserver/hw/xfree86/vga256/drivers/nv/nv4setup.c	Wed Jan  6 00:32:33 1999
@@ -1,551 +0,0 @@
- /***************************************************************************\
-|*                                                                           *|
-|*       Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.      *|
-|*                                                                           *|
-|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
-|*     international laws.  Users and possessors of this source code are     *|
-|*     hereby granted a nonexclusive,  royalty-free copyright license to     *|
-|*     use this code in individual and commercial software.                  *|
-|*                                                                           *|
-|*     Any use of this source code must include,  in the user documenta-     *|
-|*     tion and  internal comments to the code,  notices to the end user     *|
-|*     as follows:                                                           *|
-|*                                                                           *|
-|*       Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.      *|
-|*                                                                           *|
-|*     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY     *|
-|*     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"     *|
-|*     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-     *|
-|*     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,     *|
-|*     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-     *|
-|*     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL     *|
-|*     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-     *|
-|*     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-     *|
-|*     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION     *|
-|*     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF     *|
-|*     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.     *|
-|*                                                                           *|
-|*     U.S. Government  End  Users.   This source code  is a "commercial     *|
-|*     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),     *|
-|*     consisting  of "commercial  computer  software"  and  "commercial     *|
-|*     computer  software  documentation,"  as such  terms  are  used in     *|
-|*     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-     *|
-|*     ment only as  a commercial end item.   Consistent with  48 C.F.R.     *|
-|*     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),     *|
-|*     all U.S. Government End Users  acquire the source code  with only     *|
-|*     those rights set forth herein.                                        *|
-|*                                                                           *|
- \***************************************************************************/
-/* $XFree86: xc/programs/Xserver/hw/xfree86/vga256/drivers/nv/nv4setup.c,v 1.1.2.3 1998/11/18 16:38:49 hohndel Exp $ */
-/*
- * Copyright 1996-1997  David J. McKay
- *
- * Permission is hereby granted, free of charge, to any person obtaining a
- * copy of this software and associated documentation files (the "Software"),
- * to deal in the Software without restriction, including without limitation
- * the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the
- * Software is furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
- * DAVID J. MCKAY BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
- * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF
- * OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
- * SOFTWARE.
- */
-
-#include <stdlib.h>
-
-#include "nvuser.h"
-#include "nvreg.h"
-
-
-typedef struct
-{
-    UINT32 id;
-    UINT32 context;
-}HashTableEntry;
-
-typedef struct
-{
-    UINT32 context;  
-    UINT32 dmaNotifyInst;  
-    UINT32 memFormatInst;  
-    UINT32 unknown;  
-}ObjInstEntry;
-
-typedef struct
-{
-    char patchConfig;   
-    char zwrite;        
-    char chroma;        
-    char plane;         
-    char clip;          
-    char colourFormat;  
-    char alpha;         
-}ObjectProperties;
-
-typedef struct
-{
-    int chid;                     
-    int id;                       
-    int device;                   
-    int instance;                 
-    ObjectProperties properties;  
-}NVObject;
-
-extern int ErrorF(const char *fmt,...);
-static int graphicsEngineOk;
-
-static void EnableOptimisations(void)
-{
-    nvPGRAPHPort[((4194432    )- (4194304) )/4] =(   305250305  )  ;
-    nvPGRAPHPort[((4194436    )- (4194304) )/4] =(   1913721089  )  ;
-    nvPGRAPHPort[((4194440    )- (4194304) )/4] =(   299233393  )  ;
-    nvPGRAPHPort[((4194444    )- (4194304) )/4] =(   282394417  )  ;
-}
-
-static void InitDMAInstance(void)
-{
-    
-}
-
-static void DisableFifo(void)
-{
-
-    nvPFIFOPort[((9472    )- (8192) )/4] =(  (( 0    ) << (0))     )  ;
-    nvPFIFOPort[((12800    )- (8192) )/4] =(  (( 0    ) << (0))     )  ;
-    nvPFIFOPort[((12880    )- (8192) )/4] =(  (( 0    ) << (0))     )  ;
-    nvPFIFOPort[((12288    )- (8192) )/4] =(  (( 0    ) << (0))     )  ;
-    nvPFIFOPort[((12368    )- (8192) )/4] =(  (( 0    ) << (0))     )  ;
-}
-
-static void EnableFifo(void)
-{
-    nvPTIMERPort[((37376    )- (36864) )/4] =(   8  )  ;
-    nvPTIMERPort[((37392    )- (36864) )/4] =(   3  )  ;
-    nvPTIMERPort[((37120    )- (36864) )/4] =(   -1  )  ;
-    nvPTIMERPort[((37184    )- (36864) )/4] =(   0  )  ;
-    nvPFIFOPort[((12800    )- (8192) )/4] =(  (( 1    ) << (0))     )  ;
-    nvPFIFOPort[((12880    )- (8192) )/4] =(  (( 1    ) << (0))     )  ;
-    nvPFIFOPort[((9472    )- (8192) )/4] =(  (( 1    ) << (0))     )  ;
-}
-
-static void ClearOutFifoContext(void)
-{
-    int i;
-
-    for (i= ((0 + (4096/4) ) + (512/4) ) ;i< (512/4) ;i++)
-    {
-        nvPRAMINPort[ i ]=( 0 ) ;
-    }
-}
-
-int NV4KbRamUsedByHW(void)
-{
-    return (65536 );
-}
-
-static void ClearOutContext(void)
-{
-    int i;
-
-    ClearOutFifoContext();
-    nvPFIFOPort[((12304    )- (8192) )/4] =(  0  )  ;
-    nvPFIFOPort[((12400    )- (8192) )/4] =(  0  )  ;
-    nvPFIFOPort[((12816    )- (8192) )/4] =(  0  )  ;
-    nvPFIFOPort[((12912    )- (8192) )/4] =(  0  )  ;
-    nvPFIFOPort[((12864    )- (8192) )/4] =(  0  )  ;
-    nvPFIFOPort[((12868    )- (8192) )/4] =(  0  )  ;
-    nvPFIFOPort[((12840    )- (8192) )/4] =(  0  )  ;
-    nvPFIFOPort[((9232    )- (8192) )/4] =(  0  )  ;
-    nvPFIFOPort[((9248    )- (8192) )/4] =(  0  )  ;
-    nvPFIFOPort[((9216    )- (8192) )/4] =(  0  )  ;
-    for (i = 0; i < 8 ; i++)
-    {
-        nvPGRAPHPort[(((4194688+( i )*4)    )- (4194304) )/4] =(  0  )  ;
-        nvPGRAPHPort[(((4194720+( i )*4)    )- (4194304) )/4] =(  0  )  ;
-        nvPGRAPHPort[(((4194752+( i )*4)    )- (4194304) )/4] =(  0  )  ;
-        nvPGRAPHPort[(((4194784+( i )*4)    )- (4194304) )/4] =(  0  )  ;
-    }
-}
-
-static HashTableEntry  localHash[512 ];
-static HashTableEntry *realHash= ((void *)0) ;
-
-static void ClearOutHashTables(void)
-{
-    int i,j;
-
-    for (j=0;j< 512 ;j++)
-    {
-        localHash[j].id=0;
-        localHash[j].context=0;
-        nvPRAMINPort[ (0 +( j )*2)  ]=( 0 ) ;
-        nvPRAMINPort[ (0 +( j )*2) +1 ]=( 0 ) ;
-    }
-    nvPFIFOPort[((12888    )- (8192) )/4] =(  65535  )  ;
-}
-
-static void LoadChannelContext(int screenWidth,int screenHeight,int bpp)
-{
-    int i;
-    UINT32 read;
-    int pitch=((bpp+1)/8)*screenWidth;
-
-    nvPFIFOPort[((12292    )- (8192) )/4] =(  0  )  ;
-    nvPFIFOPort[((12804    )- (8192) )/4] =(  0  )  ;
-    nvPFIFOPort[((12832    )- (8192) )/4] =(  0  )  ;
-    nvPFIFOPort[((9480    )- (8192) )/4] =(   0  )  ;
-    nvPFIFOPort[((9476    )- (8192) )/4] =(  0  )  ;
-    nvPFIFOPort[((9484    )- (8192) )/4] =(  65535  )  ;
-    nvPFIFOPort[((12372    )- (8192) )/4] =(   1  )  ;
-    nvPFIFOPort[((12884    )- (8192) )/4] =(   1  )  ;
-    nvPGRAPHPort[((4194656    )- (4194304) )/4] =(   0  )  ;
-    nvPGRAPHPort[((4194660    )- (4194304) )/4] =(   0  )  ;
-    nvPGRAPHPort[((4194664    )- (4194304) )/4] =(   0  )  ;
-    nvPGRAPHPort[((4194668    )- (4194304) )/4] =(   0  )  ;
-    for (i = 0; i < 8; i++)
-    {
-        nvPGRAPHPort[(((4194688+( i )*4)    )- (4194304) )/4] =(   0  )  ;
-        nvPGRAPHPort[(((4194720+( i )*4)    )- (4194304) )/4] =(   0  )  ;
-        nvPGRAPHPort[(((4194752+( i )*4)    )- (4194304) )/4] =(   0  )  ;
-        nvPGRAPHPort[(((4194784+( i )*4)    )- (4194304) )/4] =(   0  )  ;
-    }
-    nvPGRAPHPort[((4194676    )- (4194304) )/4] =(      0  )  ;
-    nvPGRAPHPort[((4198400    )- (4194304) )/4] =(   0  )  ;
-    nvPGRAPHPort[((4198404    )- (4194304) )/4] =(   0  )  ;
-    nvPGRAPHPort[((4198408    )- (4194304) )/4] =(    0  )  ;
-    nvPGRAPHPort[((4198412    )- (4194304) )/4] =(      0  )  ;
-    nvPGRAPHPort[((4196192    )- (4194304) )/4] =(     0  )  ;
-    for (i = 0; i < 6; i++)
-    {
-        nvPGRAPHPort[(((4195904+( i )*4)    )- (4194304) )/4] =(    0  )  ;
-        nvPGRAPHPort[(((4195928+( i )*4)    )- (4194304) )/4] =(      0  )  ;
-        nvPGRAPHPort[(((4195972+( i )*4)    )- (4194304) )/4] =(     16777215  )  ;
-    }
-    for (i = 0; i < 5; i++)
-        nvPGRAPHPort[(((4195952+( i )*4)    )- (4194304) )/4] =(     pitch  )  ;
-    nvPGRAPHPort[((4195856    )- (4194304) )/4] =(    0  )  ;
-    nvPGRAPHPort[((4195860    )- (4194304) )/4] =(      0  )  ;
-    nvPGRAPHPort[((4196108    )- (4194304) )/4] =(           0  )  ;
-    nvPGRAPHPort[((4196112    )- (4194304) )/4] =(             -1  )  ;
-    nvPGRAPHPort[((4195996    )- (4194304) )/4] =(         0  )  ;
-    nvPGRAPHPort[((4196000    )- (4194304) )/4] =(         0  )  ;
-    switch (bpp)
-    {
-        case 8:
-            nvPGRAPHPort[((4196132    )- (4194304) )/4] =(  (( 1    ) << (0))   |
-                                                                                   (( 1    ) << (4))   |
-                                                                                   (( 1    ) << (8))   |
-                                                                                   (( 1    ) << (12))   |
-                                                                                   (( 1    ) << (16))   |
-                                                                                   (( 1    ) << (20))     )  ;
-            nvPGRAPHPort[((4195864    )- (4194304) )/4] =(  (( 0    ) << (0))   |
-                                                                                   (( 1    ) << (4))   |
-                                                                                   (( 1    ) << (12))     )  ;
-            nvPGRAPHPort[((4196400    )- (4194304) )/4] =(  ((    1   ) << (0))    |
-                                                                                   ((    1   ) << (8))    |
-                                                                                   ((    1   ) << (16))    |
-                                                                                   ((   1   ) << (24))     )  ;
-            break;
-        case 15:
-            nvPGRAPHPort[((4196132    )- (4194304) )/4] =(  (( 2    ) << (0))   |
-                                                                                   (( 2    ) << (4))   |
-                                                                                   (( 2    ) << (8))   |
-                                                                                   (( 2    ) << (12))   |
-                                                                                   (( 2    ) << (16))   |
-                                                                                   (( 2    ) << (20))     )  ;
-            nvPGRAPHPort[((4195864    )- (4194304) )/4] =(  (( 1    ) << (0))   |
-                                                                                   (( 7    ) << (4))   |
-                                                                                   (( 2    ) << (12))     )  ;
-            nvPGRAPHPort[((4196400    )- (4194304) )/4] =(  ((    9   ) << (0))    |
-                                                                                   ((    9   ) << (8))    |
-                                                                                   ((    9   ) << (16))    |
-                                                                                   ((   9   ) << (24))     )  ;
-            break;
-        case 16:
-            nvPGRAPHPort[((4196132    )- (4194304) )/4] =(  (( 5    ) << (0))   |
-                                                                                   (( 5    ) << (4))   |
-                                                                                   (( 5    ) << (8))   |
-                                                                                   (( 5    ) << (12))   |
-                                                                                   (( 5    ) << (16))   |
-                                                                                   (( 5    ) << (20))     )  ;
-            nvPGRAPHPort[((4195864    )- (4194304) )/4] =(  (( 2    ) << (0))   |
-                                                                                   ((   12   ) << (4))   |
-                                                                                   (( 5    ) << (12))     )  ;
-            nvPGRAPHPort[((4196400    )- (4194304) )/4] =(  ((    12   ) << (0))    |
-                                                                                   ((    12   ) << (8))    |
-                                                                                   ((    12   ) << (16))    |
-                                                                                   ((   12   ) << (24))     )  ;
-            break;
-        case 32:
-            nvPGRAPHPort[((4196132    )- (4194304) )/4] =(  (( 7    ) << (0))   |
-                                                                                   (( 7    ) << (4))   |
-                                                                                   (( 7    ) << (8))   |
-                                                                                   (( 7    ) << (12))   |
-                                                                                   (( 7    ) << (16))   |
-                                                                                   (( 7    ) << (20))     )  ;
-            nvPGRAPHPort[((4195864    )- (4194304) )/4] =(  (( 5    ) << (0))   |
-                                                                                   (( 14    ) << (4))   |
-                                                                                   (( 7    ) << (12))     )  ;
-            nvPGRAPHPort[((4196400    )- (4194304) )/4] =(  ((    7   ) << (0))    |
-                                                                                   ((    7   ) << (8))    |
-                                                                                   ((    7   ) << (16))    |
-                                                                                   ((   7   ) << (24))     )  ;
-            break;
-    }
-    nvPGRAPHPort[((4196116    )- (4194304) )/4] =(            0  )  ;
-    nvPGRAPHPort[((4196352    )- (4194304) )/4] =(       -1  )  ;
-    nvPGRAPHPort[((4196356    )- (4194304) )/4] =(       -1  )  ;
-    nvPGRAPHPort[(((4196360+( 0 )*4)    )- (4194304) )/4] =(        0  )  ;
-    nvPGRAPHPort[(((4196360+( 1 )*4)    )- (4194304) )/4] =(        0  )  ;
-    nvPGRAPHPort[((4196368    )- (4194304) )/4] =(     0  )  ;
-    nvPGRAPHPort[((4195840    )- (4194304) )/4] =(       -1  )  ;
-    nvPGRAPHPort[((4195844    )- (4194304) )/4] =(              204  )  ;
-    nvPGRAPHPort[((4196372    )- (4194304) )/4] =(            0  )  ;
-    nvPGRAPHPort[((4195848    )- (4194304) )/4] =(          0  )  ;
-    nvPGRAPHPort[((4195852    )- (4194304) )/4] =(      0  )  ;
-    nvPGRAPHPort[((4196376    )- (4194304) )/4] =(          0  )  ;
-    nvPGRAPHPort[((4196380    )- (4194304) )/4] =(          0  )  ;
-    nvPGRAPHPort[((4196384    )- (4194304) )/4] =(          0  )  ;
-    nvPGRAPHPort[((4196388    )- (4194304) )/4] =(             0  )  ;
-    nvPGRAPHPort[((4195596    )- (4194304) )/4] =(      0  )  ;
-    for (i = 0; i < 32; i++)
-    {
-        nvPGRAPHPort[(((4195328+( i )*4)    )- (4194304) )/4] =(   0  )  ;
-        nvPGRAPHPort[(((4195456+( i )*4)    )- (4194304) )/4] =(   0  )  ;
-    }        
-    nvPGRAPHPort[((4195604    )- (4194304) )/4] =(    0  )  ;
-    nvPGRAPHPort[((4195608    )- (4194304) )/4] =(    0  )  ;
-    nvPGRAPHPort[((4195612    )- (4194304) )/4] =(    0  )  ;
-    nvPGRAPHPort[((4195616    )- (4194304) )/4] =(    0  )  ;
-    nvPGRAPHPort[((4195620    )- (4194304) )/4] =(           0  )  ;
-    nvPGRAPHPort[((4195624    )- (4194304) )/4] =(           0  )  ;
-    nvPGRAPHPort[((4195628    )- (4194304) )/4] =(           0  )  ;
-    nvPGRAPHPort[((4195632    )- (4194304) )/4] =(           0  )  ;
-    for (i = 0; i < 16; i++)
-    {
-        nvPGRAPHPort[(((4197632+( i )*4)    )- (4194304) )/4] =(      0  )  ;
-        nvPGRAPHPort[(((4197696+( i )*4)    )- (4194304) )/4] =(      0  )  ;
-        nvPGRAPHPort[(((4197760+( i )*4)    )- (4194304) )/4] =(      0  )  ;
-    }
-    nvPGRAPHPort[((4195708    )- (4194304) )/4] =(        0  )  ;
-    nvPGRAPHPort[((4195712    )- (4194304) )/4] =(        0  )  ;
-    nvPGRAPHPort[((4195716    )- (4194304) )/4] =(        0  )  ;
-    nvPGRAPHPort[((4196196    )- (4194304) )/4] =(      0  )  ;
-    nvPGRAPHPort[((4196200    )- (4194304) )/4] =(     0  )  ;
-    nvPGRAPHPort[((4195600    )- (4194304) )/4] =(          0  )  ;
-    nvPGRAPHPort[((4195696    )- (4194304) )/4] =(          0  )  ;
-    nvPGRAPHPort[((4195700    )- (4194304) )/4] =(          0  )  ;
-    nvPGRAPHPort[((4195584    )- (4194304) )/4] =(            0  )  ;
-    nvPGRAPHPort[((4195588    )- (4194304) )/4] =(            0  )  ;
-    nvPGRAPHPort[((4195644    )- (4194304) )/4] =(    0  )  ;
-    nvPGRAPHPort[((4195648    )- (4194304) )/4] =(    0  )  ;
-    nvPGRAPHPort[((4195652    )- (4194304) )/4] =(    262143  )  ;
-    nvPGRAPHPort[((4195656    )- (4194304) )/4] =(    262143  )  ;
-    nvPGRAPHPort[((4195680    )- (4194304) )/4] =(   0  )  ;
-    nvPGRAPHPort[((4195684    )- (4194304) )/4] =(   0  )  ;
-    nvPGRAPHPort[((4195688    )- (4194304) )/4] =(   262143  )  ;
-    nvPGRAPHPort[((4195692    )- (4194304) )/4] =(   262143  )  ;
-    nvPGRAPHPort[((4195636    )- (4194304) )/4] =(    0  )  ;
-    nvPGRAPHPort[((4195640    )- (4194304) )/4] =(    0  )  ;
-    nvPGRAPHPort[((4195592    )- (4194304) )/4] =(            -1  )  ;
-    nvPGRAPHPort[((4195704    )- (4194304) )/4] =(            -1  )  ;
-    nvPGRAPHPort[((4194672    )- (4194304) )/4] =(   (( 0    ) << (0))   
-                                                                            | (( 1    ) << (8))   
-                                                                            | (( 1    ) << (16))   
-                                                                            | (( 0    ) << (24))   
-                                                                            | (( 1    ) << (28))     )  ;
-    nvPGRAPHPort[((4196128    )- (4194304) )/4] =(  (( 1    ) << (0))     )  ;
-}
-
-static NVObject ropObject;
-static NVObject clipObject;
-static NVObject patternObject;
-static NVObject rectObject;
-static NVObject blitObject;
-static NVObject colourExpandObject;
-static NVObject lineObject;
-static NVObject linObject;
-static NVObject glyphObject;
-
-static int PlaceObjectInHashTable(NVObject *object)
-{
-    UINT32 hash;
-    UINT32 context;
-    int i;
-
-    hash = ((((unsigned)( object->id ))^(((unsigned)( object->id ))>>9)^(((unsigned)( object->id ))>>18)^(((unsigned)( object->id ))>>27))&511) ;
-    if (localHash[hash].id != 0)
-    {
-        if (localHash[hash].id==object->id)
-            return (1);
-        else
-        {
-            ErrorF ("**** NO ROOM FOR OBJECT %08lx IN HASH TABLE ****\n",object->id);
-            graphicsEngineOk=0;  
-            return (0);
-        }
-    }
-    context = (( 1 ) << (31)) 
-              | (( 1 ) << (16)) 
-              | (( (object->instance + 65536/16) ) << (0)) 
-              | (( object->chid ) << (24)) ;
-    localHash[hash].id      = object->id;
-    localHash[hash].context = context;
-    nvPRAMINPort[ (0 +( hash )*2)  ]=( object->id ) ;
-    nvPRAMINPort[ (0 +( hash )*2) +1 ]=( context ) ;
-    return (1);
-}
-
-static void PlaceObjectInInstTable(NVObject *object)
-{
-    ObjectProperties *p=&(object->properties);
-    UINT32 context0, context1;
-
-    context0 = (( object->device ) << (0)) 
-               | (( p->chroma ) << (12)) 
-               | (( p->clip ) << (13)) 
-               | (( p->patchConfig ) << (15)) 
-               | (( 1 ) << (24))    
-               ; 
-    context1 = (( 1 ) << (0))      
-               | (( p->colourFormat ) << (8)) ;
-    nvPRAMINPort[ (object->instance<<2)+0 ]=( context0 ) ;
-    nvPRAMINPort[ (object->instance<<2)+1 ]=( context1 ) ;
-    nvPRAMINPort[ (object->instance<<2)+2 ]=( 0 ) ;
-    nvPRAMINPort[ (object->instance<<2)+3 ]=( 0 ) ;
-}
-
-static int AllocateFreeInstance(void)
-{
-    static int freeInstance= (((4096/4) + (512/4) + (512/4) ) /4) ;
-
-    return (freeInstance++);
-}
-
-static int defaultColourFormat= 14 ;
-
-static void InitObject(NVObject *o,int id,int device)
-{
-    ObjectProperties *p=&(o->properties);
-
-    o->id=id;
-    o->chid=0;
-    o->instance=AllocateFreeInstance();
-    o->device=device;
-    p->patchConfig= 1 ;
-    p->zwrite=0;
-    p->chroma=0;
-    p->plane=0;
-    p->clip=1;
-    p->colourFormat=defaultColourFormat;
-    p->alpha=0;
-}
-
-static void SetUpObjects(int bpp)
-{
-    switch (bpp)
-    {
-        case 8:
-            defaultColourFormat = 3 ;
-            break;
-        case 15:
-            defaultColourFormat = 9 ;
-            break;
-        case 16:
-            defaultColourFormat = 12 ;
-            break;
-        case 24:
-            defaultColourFormat = 14 ;
-            break;
-    } 
-
-    InitObject(&ropObject,-1728053248 ,(67  ) );
-    PlaceObjectInHashTable(&ropObject);
-    PlaceObjectInInstTable(&ropObject);
-
-    InitObject(&clipObject,-1728053247 ,(25  ) );
-    PlaceObjectInHashTable(&clipObject);
-    PlaceObjectInInstTable(&clipObject);
-
-    InitObject(&rectObject,-2013265920 ,(94  ) );
-    PlaceObjectInHashTable(&rectObject);
-    PlaceObjectInInstTable(&rectObject);
-
-    InitObject(&blitObject,-2013265919 ,(95  ) );
-    PlaceObjectInHashTable(&blitObject);
-    PlaceObjectInInstTable(&blitObject);
-
-    InitObject(&glyphObject,-2013265915 ,(75  ) );
-    glyphObject.properties.clip = 0;  
-    PlaceObjectInHashTable(&glyphObject);
-    PlaceObjectInInstTable(&glyphObject);
-}
-
-static void ClearAndEnableInterrupts(void)
-{
-    nvPGRAPHPort[((4194560    )- (4194304) )/4] =(        -1  )  ;
-    nvPGRAPHPort[((4194624    )- (4194304) )/4] =(     -1  )  ;
-    nvPFIFOPort[((8448    )- (8192) )/4] =(       -1  )  ;
-    nvPFIFOPort[((8512    )- (8192) )/4] =(    -1  )  ;
-    nvPMCPort[((512    )- (0) )/4] =(         -1  )  ;
-}
-
-static void ResetEngine(void)
-{
-    nvPMCPort[((512    )- (0) )/4] =(  -65281  )  ;
-    nvPMCPort[((512    )- (0) )/4] =(  -1  )  ;
-}
-
-static void EnableChannel(void)
-{
-    
-}
-
-static void InitInstanceMemory(void)
-{
-    int i;
-
-    nvPFIFOPort[((8720    )- (8192) )/4] =(  (( 16    ) << (4))   |
-                                                                          (( 0    ) << (16))   |
-                                                                          (( 3    ) << (24))     )  ;
-    nvPFIFOPort[((8724    )- (8192) )/4] =(  (( 136    ) << (1))     )  ;
-    nvPFIFOPort[((8728    )- (8192) )/4] =(  (( 137    ) << (1))   |
-                                                                          (( 0    ) << (16))     )  ;
-    nvPFBPort[((1049088    )- (1048576) )/4] =(  4372  )  ;
-    for (i = 0; i < (65536  + 2048 )/4; i++)
-    {
-        nvPRAMINPort[ i ]=( 0 ) ;
-    }
-}
-
-int NV4SetupGraphicsEngine(int screenWidth,int screenHeight,int bpp)
-{
-    graphicsEngineOk=1;
-
-    DisableFifo();
-    ResetEngine();
-    EnableOptimisations();
-    InitDMAInstance();
-    ClearAndEnableInterrupts();
-    InitInstanceMemory();
-    ClearOutContext();
-    ClearOutHashTables();
-    LoadChannelContext(screenWidth,screenHeight,bpp);
-    SetUpObjects(bpp);
-    EnableChannel();
-    EnableFifo();
-    return (graphicsEngineOk);
-}
-
-void NV4Sync(void)
-{
-    while (nvPGRAPHPort[((4196096    )- (4194304) )/4]   &1) ;
-}
Index: xc/programs/Xserver/hw/xfree86/vga256/drivers/nv/nv_driver.c
diff -u xc/programs/Xserver/hw/xfree86/vga256/drivers/nv/nv_driver.c:3.5.2.6 xc/programs/Xserver/hw/xfree86/vga256/drivers/nv/nv_driver.c:3.5.2.8
--- xc/programs/Xserver/hw/xfree86/vga256/drivers/nv/nv_driver.c:3.5.2.6	Mon Oct 19 17:33:48 1998
+++ xc/programs/Xserver/hw/xfree86/vga256/drivers/nv/nv_driver.c	Tue Dec 22 23:39:13 1998
@@ -21,7 +21,7 @@
  * SOFTWARE.
  */
 
-/* $XFree86: xc/programs/Xserver/hw/xfree86/vga256/drivers/nv/nv_driver.c,v 3.5.2.6 1998/10/19 07:33:48 hohndel Exp $ */
+/* $XFree86: xc/programs/Xserver/hw/xfree86/vga256/drivers/nv/nv_driver.c,v 3.5.2.8 1998/12/22 12:39:13 hohndel Exp $ */
 
 #include <math.h>
 #include <stdlib.h>
Index: xc/programs/Xserver/hw/xfree86/vga256/drivers/nv/nvaccel.c
diff -u xc/programs/Xserver/hw/xfree86/vga256/drivers/nv/nvaccel.c:1.1.2.4 xc/programs/Xserver/hw/xfree86/vga256/drivers/nv/nvaccel.c:removed
--- xc/programs/Xserver/hw/xfree86/vga256/drivers/nv/nvaccel.c:1.1.2.4	Mon Oct 19 17:33:49 1998
+++ xc/programs/Xserver/hw/xfree86/vga256/drivers/nv/nvaccel.c	Wed Jan  6 00:32:34 1999
@@ -1,563 +0,0 @@
- /***************************************************************************\
-|*                                                                           *|
-|*       Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.      *|
-|*                                                                           *|
-|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
-|*     international laws.  Users and possessors of this source code are     *|
-|*     hereby granted a nonexclusive,  royalty-free copyright license to     *|
-|*     use this code in individual and commercial software.                  *|
-|*                                                                           *|
-|*     Any use of this source code must include,  in the user documenta-     *|
-|*     tion and  internal comments to the code,  notices to the end user     *|
-|*     as follows:                                                           *|
-|*                                                                           *|
-|*       Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.      *|
-|*                                                                           *|
-|*     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY     *|
-|*     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"     *|
-|*     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-     *|
-|*     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,     *|
-|*     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-     *|
-|*     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL     *|
-|*     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-     *|
-|*     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-     *|
-|*     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION     *|
-|*     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF     *|
-|*     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.     *|
-|*                                                                           *|
-|*     U.S. Government  End  Users.   This source code  is a "commercial     *|
-|*     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),     *|
-|*     consisting  of "commercial  computer  software"  and  "commercial     *|
-|*     computer  software  documentation,"  as such  terms  are  used in     *|
-|*     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-     *|
-|*     ment only as  a commercial end item.   Consistent with  48 C.F.R.     *|
-|*     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),     *|
-|*     all U.S. Government End Users  acquire the source code  with only     *|
-|*     those rights set forth herein.                                        *|
-|*                                                                           *|
- \***************************************************************************/
-/*
- * Copyright 1996-1997  David J. McKay
- *
- * Permission is hereby granted, free of charge, to any person obtaining a
- * copy of this software and associated documentation files (the "Software"),
- * to deal in the Software without restriction, including without limitation
- * the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the
- * Software is furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
- * DAVID J. MCKAY BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
- * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF
- * OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
- * SOFTWARE.
- */
-
-/* $XFree86: xc/programs/Xserver/hw/xfree86/vga256/drivers/nv/nvaccel.c,v 1.1.2.4 1998/10/19 07:33:49 hohndel Exp $ */
-
-#include <stdlib.h>
-
-#include "vga256.h"
-#include "xf86.h"
-#include "vga.h"
-#include "xf86xaa.h"
-#include "miline.h"
-
-#define XCONFIG_FLAGS_ONLY
-#include "xf86_Config.h"
-
-#include "nvuser.h"
-#include "nvreg.h"
-
-#ifdef DEBUG
-#define CHECK()
-#else
-#define CHECK()
-#endif
-
-/* These are the subchannels where the various objects are */
-
-#define ROP_SUBCHANNEL           0
-#define BLIT_SUBCHANNEL          1
-#define PATTERN_SUBCHANNEL       2
-#define RECT_SUBCHANNEL          3
-#define CLIP_SUBCHANNEL          4
-#define COLOUR_EXPAND_SUBCHANNEL 5
-#define GLYPH_SUBCHANNEL         6
-#define LINE_SUBCHANNEL          6
-#define LIN_SUBCHANNEL           7
-
-
-/* This is the pointer to the channel */
-static NvChannel *chan0=NULL;
-/* Pointers to fixed subchannels */
-static NvSubChannel *ropChan=NULL;
-static NvSubChannel *rectChan=NULL;
-static NvSubChannel *blitChan=NULL;
-static NvSubChannel *clipChan=NULL;
-static NvSubChannel *colourExpandChan=NULL;
-static NvSubChannel *glyphChan=NULL;
-
-/*#define NV_ENABLE_LINES*/
-
-/* Lines are disables at the moment. I have been unable to get the
- * lines produced by the NV1 hardware to match the software routines.
- * The NV1 draws lines a la windows, which is different to what X wants
- * Even fiddling with the zero bias does not get it correct. Will need a
- * lot of work to get it to work
- */
-#ifdef NV_ENABLE_LINES
-static NvSubChannel *lineChan=NULL;
-static NvSubChannel *linChan=NULL;
-#endif
-
-/* Holds number of free slots in fifo. Means we don't have to re-read
- * the fifo count every time we want to write to the chip.  Should do something useful if chip
- * is busy (like keep the cursor updated). Calling sched_yield() is nice for the other apps running,
- * but it really makes the server sluggish.
- */
-static int freeSlots=0;
-
-#if 1
-#define WaitForSlots(n,words) \
-  while((freeSlots-=((words)*4))<0){\
-    freeSlots=chan0->subChannel[n].control.free;\
-  }
-#else
-#define WaitForSlots(n,words) while((volatile)(chan0->subChannel[n].control.free)<((words)*4)){ sched_yield(); }
-#endif
-
-static int currentRop=-1;
-
-static void NVSetRop(int rop)
-{
-    static int ropTrans[16] = {
-        0x0,  /* GXclear */
-        0x88, /* Gxand */
-        0x44, /* GXandReverse */
-        0xcc, /* GXcopy */
-        0x22, /* GXandInverted */
-        0xaa, /* GXnoop */
-        0x66, /* GXxor */
-        0xee, /* GXor */
-        0x11, /* GXnor */
-        0x99, /* GXequiv */
-        0x55, /* GXinvert */
-        0xdd, /* GXorReverse */
-        0x33, /* GXcopyInverted */
-        0xbb, /* GXorInverted */
-        0x77, /* GXnand */
-        0xff  /* GXset */
-    };
-    currentRop=rop;
-    WaitForSlots(ROP_SUBCHANNEL,1);
-    ropChan->method.ropSolid.setRop=ropTrans[rop];
-    CHECK();
-}
-
-/* I haven't figured out how Patterns work yet, so this code is
- * not used at present
- */
-#if 0
-static NVSetPatternRop(int rop)
-{
-    static int ropTrans[16]={
-        0x00, /* GXclear */
-        0xa0, /* Gxand */
-        0x0a, /* GXandReverse */
-        0xf0, /* GXcopy */
-        0x30, /* GXandInverted */
-        0xaa, /* GXnoop */
-        0x3a, /* GXxor */
-        0xfa, /* GXor */
-        0x03, /* GXnor */
-        0xa0, /* Gxequiv */
-        0x0f, /* GXinvert */
-        0xaf, /* GXorReverse */
-        0x33, /* GXcopyInverted */
-        0xbb, /* GXorInverted */
-        0xf3, /* GXnand */
-        0xff  /* GXset */
-    };
-    currentRop=rop+16; /* +16 is important */
-    WaitForSlots(ROP_SUBCHANNEL,1);
-    ropChan->method.ropSolid.setRop=ropTrans[rop];
-    CHECK();
-
-}
-
-#endif
-
-/*
- * Due to the fact that the SetupForFillRectSolid() is also used
- * to setup for lines we have to record the colour in a static
- * variable and write it out every time we do a drawing operation.
- * This costs some performance and is IMHO wrong anyway. Why should
- * you call a routine for filled rectangles when you are drawing lines?
- * Will get round to "fixing" this if I ever get lines on the NV1 to work
- * correctly
- */
-
-#if 1
-static int currentColor;
-#endif
-
-static void NVSetupForFillRectSolid(int color,int rop,unsigned planemask)
-{
-    if (currentRop!=rop)
-    {
-        NVSetRop(rop);
-    }
-#if 1
-    currentColor=color;
-#else
-    WaitForSlots(RECT_SUBCHANNEL,1);
-    rectChan->method.renderSolidRectangle.color=color;
-#endif
-
-    CHECK();
-}
-
-static void NVSubsequentFillRectSolid(int x,int y,int w,int h)
-{
-
-#if 1
-    WaitForSlots(RECT_SUBCHANNEL,3);
-    rectChan->method.renderSolidRectangle.color=currentColor;
-#else
-    WaitForSlots(RECT_SUBCHANNEL,2);
-#endif
-
-    rectChan->method.renderSolidRectangle.rectangle[0].yx=PACK_UINT16(y,x);
-    rectChan->method.renderSolidRectangle.rectangle[0].heightWidth=
-    PACK_UINT16(h,w);
-    CHECK();
-}
-
-
-
-
-static int clippingOn=0;
-
-static void NVSetClippingRectangle(int x1,int y1,int x2,int y2)
-{
-    int height,width;
-
-    width=x2-x1+1;height=y2-y1+1;
-    WaitForSlots(CLIP_SUBCHANNEL,2);
-    clipChan->method.clip.setRectangle.yx=PACK_INT16(y1,x1);
-    clipChan->method.clip.setRectangle.heightWidth=PACK_UINT16(height,width);
-    clippingOn=1;
-    CHECK();
-}
-
-
-#define NVResetClippingRectangle() \
-  { NVSetClippingRectangle(0,0,MAX_INT16,MAX_INT16);\
-  clippingOn=0;}
-
-#ifdef NV_ENABLE_LINES
-static void NVSubsequentTwoPointLine(int x1,int y1,int x2,int y2,int bias)
-{
-    NvRenderSolidLine *line;
-
-    line = (bias&0x0100) ?  &(linChan->method.line) : &(lineChan->method.line);
-    /* We should really check appropriate subchannel here */
-    WaitForSlots(LINE_SUBCHANNEL,3);
-    line->color=currentColor;
-    line->line[0].y0_x0=PACK_INT16(y1,x1);
-    line->line[0].y1_x1=PACK_INT16(y2,x2);
-    /* Reset clipping rectangle to normal */
-    if (clippingOn)
-    {
-        NVResetClippingRectangle();
-    }
-}
-
-#endif
-
-static void NVSetupForScreenToScreenCopy(int xdir,int ydir,int rop,
-                                         unsigned planemask,
-                                         int transparency_color)
-{
-    if (rop!=currentRop)
-    {
-        NVSetRop(rop);
-    }
-
-    /* When transparency is implemented, will have to flip object */
-}
-
-static void NVSubsequentScreenToScreenCopy(int x1,int y1,
-                                           int x2,int y2,int w,int h)
-{
-    WaitForSlots(BLIT_SUBCHANNEL,3);
-    blitChan->method.blit.yxIn=PACK_UINT16(y1,x1);
-    blitChan->method.blit.yxOut=PACK_UINT16(y2,x2);
-    blitChan->method.blit.heightWidth=PACK_UINT16(h,w);
-    CHECK();
-}
-
-
-/* How much date to transfer */
-static int scanlineWordCount;
-static unsigned char scratchBuffer[512];
-static int colourExpandMask=0;
-
-static void NVSetupForScanlineScreenToScreenColorExpand(int x,int y,int w,
-                                                        int h,int bg,int fg,
-                                                        int rop,
-                                                        unsigned planemask)
-{
-    if (currentRop!=rop)
-    {
-        NVSetRop(rop);
-    }
-    WaitForSlots(COLOUR_EXPAND_SUBCHANNEL,5);
-    if (bg==-1)
-    {
-        colourExpandChan->method.imageMonochromeFromCpu.color0=0;
-    }
-    else
-    {
-        colourExpandChan->method.imageMonochromeFromCpu.color0=bg|colourExpandMask;
-    }
-    colourExpandChan->method.imageMonochromeFromCpu.color1=fg|colourExpandMask;
-    colourExpandChan->method.imageMonochromeFromCpu.point=PACK_UINT16(y,x);
-    colourExpandChan->method.imageMonochromeFromCpu.size=PACK_UINT16(h,w);
-    colourExpandChan->method.imageMonochromeFromCpu.sizeIn=
-    PACK_UINT16(h,(w+31)&(~31));
-    scanlineWordCount = (w + 31) >> 5;
-    CHECK();
-}
-
-static void NVSubsequentScanlineScreenToScreenColorExpand(int srcAddr)
-{
-    unsigned long *ptr = (unsigned long*)scratchBuffer;
-    int count = scanlineWordCount;
-    int i=0;
-
-    /* This rather simple algorithm seems to perform better than
-     * the more complex variants with loop unrolling that I have tried
-     */
-    for (i=0;i<count;i++)
-    {
-        WaitForSlots(COLOUR_EXPAND_SUBCHANNEL,1);
-        colourExpandChan->method.imageMonochromeFromCpu.monochrome[i%32]=(*(ptr++));
-    }
-    CHECK();
-}
-/*
- * Subchannel initialization.
- */
-static void SetupSubChans(void)
-{
-    /* Map subchannels */
-    ropChan=&(chan0->subChannel[ROP_SUBCHANNEL]);
-    rectChan=&(chan0->subChannel[RECT_SUBCHANNEL]);
-    blitChan=&(chan0->subChannel[BLIT_SUBCHANNEL]);
-    clipChan=&(chan0->subChannel[CLIP_SUBCHANNEL]);
-
-#ifdef NV_ENABLE_LINES
-    lineChan=&(chan0->subChannel[LINE_SUBCHANNEL]);
-    linChan=&(chan0->subChannel[LIN_SUBCHANNEL]);
-#endif
-
-    /* Bung the appropriate objects into the subchannels */
-    WaitForSlots(ROP_SUBCHANNEL,1);
-    ropChan->control.object=ROP_OBJECT_ID;
-    WaitForSlots(BLIT_SUBCHANNEL,1);
-    blitChan->control.object=BLIT_OBJECT_ID;
-    WaitForSlots(RECT_SUBCHANNEL,1);
-    rectChan->control.object=RECT_OBJECT_ID;
-    WaitForSlots(CLIP_SUBCHANNEL,1);
-    clipChan->control.object=CLIP_OBJECT_ID;
-    if (GetChipType() != NV4)
-    {
-        colourExpandChan=&(chan0->subChannel[COLOUR_EXPAND_SUBCHANNEL]);
-        WaitForSlots(COLOUR_EXPAND_SUBCHANNEL,1);
-        colourExpandChan->control.object=COLOUR_EXPAND_OBJECT_ID;
-    }
-
-#ifdef NV_ENABLE_LINES
-    if (GetChipType() != NV4)
-    {
-        lineChan->control.object=LINE_OBJECT_ID;
-        WaitForSlots(LIN_SUBCHANNEL,1);
-        linChan->control.object=LIN_OBJECT_ID;
-    }
-#endif
-    if (GetChipType() == NV3 || GetChipType() == NV4)
-    {
-        glyphChan=&(chan0->subChannel[GLYPH_SUBCHANNEL]);
-        WaitForSlots(GLYPH_SUBCHANNEL,1);
-        glyphChan->control.object=GLYPH_OBJECT_ID;
-    }
-    CHECK();
-}
-
-
-/* These should really be in a separate file */
-void NV4Sync(void);
-void NV3Sync(void);
-void NV1Sync(void);
-
-int NV4SetupGraphicsEngine(int width,int height,int bpp);
-int NV3SetupGraphicsEngine(int width,int height,int bpp);
-int NV1SetupGraphicsEngine(int width,int height,int bpp);
-
-void NVAccelInit(void)
-{
-    int i;
-    int ret;
-
-#ifdef DEBUG
-    if (getenv("NV_NOACCEL")) return;
-#endif
-    switch (GetChipType())
-    {
-        case NV1:
-            ret = NV1SetupGraphicsEngine(vga256InfoRec.virtualX,
-                                      vga256InfoRec.virtualY,
-                                      vgaBitsPerPixel);
-            break;
-        case NV3:
-            ret = NV3SetupGraphicsEngine(vga256InfoRec.virtualX,
-                                     vga256InfoRec.virtualY,
-                                     vgaBitsPerPixel);
-            break;
-        case NV4:
-            ret = NV4SetupGraphicsEngine(vga256InfoRec.virtualX,
-                                     vga256InfoRec.virtualY,
-                                     vgaBitsPerPixel);
-            break;
-    }
-    if (!ret)
-    {
-        ErrorF("Failed to init graphics engine - no acceleration\n");
-    }
-    switch (vgaBitsPerPixel)
-    {
-        case 8:
-        case 32:
-            colourExpandMask=0xff000000;
-            break;
-        case 15:
-        case 16:
-            colourExpandMask=0xffff8000;
-            break;
-    }
-    CHECK();
-
-    chan0=NvOpenChannel();
-    if (chan0==NULL) return;
-    SetupSubChans();
-    /*
-     * Set up default values.
-     */
-    NVSetRop(3);
-    NVResetClippingRectangle();
-
-    /* There are still some problems with delayed syncing */
-    xf86AccelInfoRec.Flags = BACKGROUND_OPERATIONS/*| DELAYED_SYNC*/;
-
-    switch (GetChipType())
-    {
-        case NV1:
-            xf86AccelInfoRec.Sync = NV1Sync;
-            break;
-        case NV3:
-            xf86AccelInfoRec.Sync = NV3Sync;
-            break;
-        case NV4:
-            xf86AccelInfoRec.Sync = NV4Sync;
-            break;
-    }
-    /*
-     * Install the low-level functions for drawing solid filled rectangles.
-     */
-    xf86GCInfoRec.PolyFillRectSolidFlags = NO_PLANEMASK | NO_TRANSPARENCY;
-    xf86AccelInfoRec.SetupForFillRectSolid = NVSetupForFillRectSolid;
-    xf86AccelInfoRec.SubsequentFillRectSolid = NVSubsequentFillRectSolid;
-
-    xf86GCInfoRec.CopyAreaFlags = NO_PLANEMASK | NO_TRANSPARENCY;
-    xf86AccelInfoRec.SetupForScreenToScreenCopy = NVSetupForScreenToScreenCopy;
-    xf86AccelInfoRec.SubsequentScreenToScreenCopy = NVSubsequentScreenToScreenCopy;
-#ifdef DEBUG
-    if (getenv("NV_NOCOLOUREXPAND")==NULL)
-#endif
-    /* This isn't a very efficient way to do color expansion (FB reads are slow) */
-    if (GetChipType() != NV3 && GetChipType() != NV4)
-    {
-        /* Colour Expansion */
-        xf86AccelInfoRec.Flags|=NO_SYNC_AFTER_CPU_COLOR_EXPAND |
-                                COP_FRAMEBUFFER_CONCURRENCY;
-
-        xf86AccelInfoRec.ColorExpandFlags = /*NO_TRANSPARENCY | */
-                                            NO_PLANEMASK |
-                                            SCANLINE_PAD_DWORD |
-                                            CPU_TRANSFER_PAD_DWORD |
-                                            BIT_ORDER_IN_BYTE_LSBFIRST |
-                                            VIDEO_SOURCE_GRANULARITY_DWORD;
-
-        xf86AccelInfoRec.ScratchBufferAddr = 1;
-        xf86AccelInfoRec.ScratchBufferSize = 1024;
-        xf86AccelInfoRec.ScratchBufferBase = (void*)scratchBuffer;
-        xf86AccelInfoRec.PingPongBuffers = 1;
-
-        xf86AccelInfoRec.SetupForScanlineScreenToScreenColorExpand =
-        NVSetupForScanlineScreenToScreenColorExpand;
-        xf86AccelInfoRec.SubsequentScanlineScreenToScreenColorExpand =
-        NVSubsequentScanlineScreenToScreenColorExpand;
-    }
-#ifdef NV_ENABLE_LINES
-#ifdef DEBUG
-    if (getenv("NV_NOLINES")==NULL)
-#endif
-    if (GetChipType() != NV4)
-    {
-        extern int nvMiLineZeroBias;
-
-
-#ifdef DEBUG
-        ErrorF("NV_ZEROBIAS is %s\n",getenv("NV_ZEROBIAS"));
-
-        if (getenv("NV_ZEROBIAS")!=NULL)
-        {
-            nvMiLineZeroBias=atoi((char*)getenv("NV_ZEROBIAS"));
-            ErrorF("Setting bias to %d\n",nvMiLineZeroBias);
-        }
-#endif
-
-        /* Lines and lins */
-        xf86AccelInfoRec.Flags|=HARDWARE_CLIP_LINE|
-                                USE_TWO_POINT_LINE|
-                                TWO_POINT_LINE_NOT_LAST;
-        xf86AccelInfoRec.SubsequentTwoPointLine = NVSubsequentTwoPointLine;
-        xf86AccelInfoRec.SetClippingRectangle =  NVSetClippingRectangle;
-    }
-#endif
-
-    /*
-     * Finally, we set up the video memory space available to the pixmap
-     * cache. In this case, all memory from the end of the virtual screen
-     * to the end of video memory minus 13K, can be used.
-     */
-#ifdef DEBUG
-    if (getenv("NV_NOPIXMAPCACHE")==NULL)
-#endif
-    {
-        xf86AccelInfoRec.Flags|= PIXMAP_CACHE;
-        xf86InitPixmapCache( &vga256InfoRec,
-                             vga256InfoRec.virtualY * vga256InfoRec.displayWidth *
-                             vga256InfoRec.bitsPerPixel / 8,
-                             (vga256InfoRec.videoRam-65/*(NvKbRamUsedByHW()+1)*/)*1024);
-    }
-}
-
-
Index: xc/programs/Xserver/hw/xfree86/vga256/drivers/nv/nvcursor.h
diff -u xc/programs/Xserver/hw/xfree86/vga256/drivers/nv/nvcursor.h:1.1.2.3 xc/programs/Xserver/hw/xfree86/vga256/drivers/nv/nvcursor.h:1.1.2.5
--- xc/programs/Xserver/hw/xfree86/vga256/drivers/nv/nvcursor.h:1.1.2.3	Mon Oct 19 17:33:49 1998
+++ xc/programs/Xserver/hw/xfree86/vga256/drivers/nv/nvcursor.h	Tue Dec 22 23:39:14 1998
@@ -21,7 +21,7 @@
  * SOFTWARE.
  */
 
-/* $XFree86: xc/programs/Xserver/hw/xfree86/vga256/drivers/nv/nvcursor.h,v 1.1.2.3 1998/10/19 07:33:49 hohndel Exp $ */
+/* $XFree86: xc/programs/Xserver/hw/xfree86/vga256/drivers/nv/nvcursor.h,v 1.1.2.5 1998/12/22 12:39:14 hohndel Exp $ */
 
 #ifndef _NVCURSOR_H_
 #define _NVCURSOR_H_
@@ -32,17 +32,5 @@
 void NVQueryBestSize(int class,unsigned short *pwidth,
                      unsigned short *pheight,ScreenPtr pScreen);
 
-
-Bool NV3CursorInit(char *pm,ScreenPtr pScr);
-void NV3RestoreCursor(ScreenPtr pScr);
-void NV3WarpCursor(ScreenPtr pScr,int x,int y);
-void NV3QueryBestSize(int class,unsigned short *pwidth,
-                     unsigned short *pheight,ScreenPtr pScreen);
-
-Bool NV4CursorInit(char *pm,ScreenPtr pScr);
-void NV4RestoreCursor(ScreenPtr pScr);
-void NV4WarpCursor(ScreenPtr pScr,int x,int y);
-void NV4QueryBestSize(int class,unsigned short *pwidth,
-                     unsigned short *pheight,ScreenPtr pScreen);
 
 #endif
Index: xc/programs/Xserver/hw/xfree86/vga256/drivers/nv/nvreg.h
diff -u xc/programs/Xserver/hw/xfree86/vga256/drivers/nv/nvreg.h:3.2.2.2 xc/programs/Xserver/hw/xfree86/vga256/drivers/nv/nvreg.h:3.2.2.3
--- xc/programs/Xserver/hw/xfree86/vga256/drivers/nv/nvreg.h:3.2.2.2	Mon Oct 19 17:33:50 1998
+++ xc/programs/Xserver/hw/xfree86/vga256/drivers/nv/nvreg.h	Tue Dec 22 18:37:49 1998
@@ -21,7 +21,7 @@
  * SOFTWARE.
  */
 
-/* $XFree86: xc/programs/Xserver/hw/xfree86/vga256/drivers/nv/nvreg.h,v 3.2.2.2 1998/10/19 07:33:50 hohndel Exp $ */
+/* $XFree86: xc/programs/Xserver/hw/xfree86/vga256/drivers/nv/nvreg.h,v 3.2.2.3 1998/12/22 07:37:49 hohndel Exp $ */
 
 #ifndef __NVREG_H_
 #define __NVREG_H_
Index: xc/programs/Xserver/hw/xfree86/vga256/drivers/nv/nvsetup.c
diff -u xc/programs/Xserver/hw/xfree86/vga256/drivers/nv/nvsetup.c:1.1.2.3 xc/programs/Xserver/hw/xfree86/vga256/drivers/nv/nvsetup.c:removed
--- xc/programs/Xserver/hw/xfree86/vga256/drivers/nv/nvsetup.c:1.1.2.3	Sat Jan 24 22:55:10 1998
+++ xc/programs/Xserver/hw/xfree86/vga256/drivers/nv/nvsetup.c	Wed Jan  6 00:32:35 1999
@@ -1,595 +0,0 @@
-/*
- * Copyright 1996-1997  David J. McKay
- *
- * Permission is hereby granted, free of charge, to any person obtaining a 
- * copy of this software and associated documentation files (the "Software"), 
- * to deal in the Software without restriction, including without limitation 
- * the rights to use, copy, modify, merge, publish, distribute, sublicense, 
- * and/or sell copies of the Software, and to permit persons to whom the 
- * Software is furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- * 
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL 
- * DAVID J. MCKAY BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, 
- * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF 
- * OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE 
- * SOFTWARE.
- */
-
-/* $XFree86: xc/programs/Xserver/hw/xfree86/vga256/drivers/nv/nvsetup.c,v 1.1.2.3 1998/01/24 11:55:10 dawes Exp $ */
-
-#include <stdlib.h>
-
-
-#include "nvuser.h"
-#include "nv1ref.h"
-#include "nvreg.h"
-
-typedef struct {
-  UINT32 id;      /* 32 bit unique identifer for this object */
-  UINT32 channel; /* What channel this object belongs to */
-  UINT32 context; /* Holds configuration of pipeline. Written to CTX SWITCH */
-}NVObject;
-
-
-
-static int graphicsEngineOk;
-
-#define WaitForIdle() while(PGRAPH_Read(STATUS))
-
-static void EnableOptimisations(void)
-{
-  /* Now switch on all the optimisations that there are */
-  PGRAPH_Write(DEBUG_0,PGRAPH_Def(DEBUG_0_EDGE_FILLING,ENABLED) |
-                       PGRAPH_Def(DEBUG_0_WRITE_ONLY_ROPS,ENABLED) |     
-                       PGRAPH_Def(DEBUG_0_NONBLOCK_BROAD,ENABLED) |
-                       PGRAPH_Def(DEBUG_0_BLOCK_BROAD,ENABLED) |
-                       PGRAPH_Def(DEBUG_0_BLOCK,ENABLED) |
-                       PGRAPH_Def(DEBUG_0_BULK_READS,ENABLED));
-
-  PGRAPH_Write(DEBUG_1,PGRAPH_Def(DEBUG_1_HIRES_TM,DISABLED) |
-	               PGRAPH_Def(DEBUG_1_FAST_BUS,DISABLED) |
-	               PGRAPH_Def(DEBUG_1_TM_QUAD_HANDOFF,ENABLED) |
-	               PGRAPH_Def(DEBUG_1_FAST_RMW_BLITS,ENABLED) | 
-	               PGRAPH_Def(DEBUG_1_PATT_BLOCK,ENABLED) |
-	               PGRAPH_Def(DEBUG_1_TRI_OPTS,DISABLED) |
-	               PGRAPH_Def(DEBUG_1_BI_RECTS,DISABLED) |
-	               PGRAPH_Def(DEBUG_1_DMA_ACTIVITY,IGNORE) |
-	               PGRAPH_Def(DEBUG_1_VOLATILE_RESET,NOT_LAST));
-
-  PGRAPH_Write(DEBUG_2,PGRAPH_Def(DEBUG_2_VOLATILE_RESET,ENABLED) |
-	               PGRAPH_Def(DEBUG_2_TM_FASTINPUT,ENABLED) |
-	               PGRAPH_Def(DEBUG_2_BUSY_PATIENCE,ENABLED) |
-	               PGRAPH_Def(DEBUG_2_TRAPEZOID_TEXEL,ENABLED) |
-	               PGRAPH_Def(DEBUG_2_MONO_ABORT,DISABLED) | 
-	               PGRAPH_Def(DEBUG_2_BETA_ABORT,ENABLED) |
-	               PGRAPH_Def(DEBUG_2_ALPHA_ABORT,ENABLED) |
-	               PGRAPH_Def(DEBUG_2_AVOID_RMW_BLEND,DISABLED));
-
-  /* 
-   * REV c parts have another debug register here, but ignore for the 
-   * moment
-   */
-}
-
-static void InitDMAInstance(void)
-{
-  PDMA_Write(GR_CHANNEL,PDMA_Def(GR_CHANNEL_ACCESS,DISABLED));
-  PDMA_Write(GR_INSTANCE,0);
-  PGRAPH_Write(DMA,0);
-  PGRAPH_Write(NOTIFY,0);
-  PDMA_Write(GR_CHANNEL,PDMA_Def(GR_CHANNEL_ACCESS,ENABLED));
-}
-
-
-
-static void DisableFifo(void)
-{
-  /* Disable CACHE1 first */
-  PFIFO_Write(CACHES,PFIFO_Def(CACHES_REASSIGN,DISABLED));
-  PFIFO_Write(CACHE1_PUSH0,PFIFO_Def(CACHE1_PUSH0_ACCESS,DISABLED));
-  PFIFO_Write(CACHE1_PULL0,PFIFO_Def(CACHE1_PULL0_ACCESS,DISABLED));
-  PFIFO_Write(CACHE0_PUSH0,PFIFO_Def(CACHE1_PUSH0_ACCESS,DISABLED));
-  PFIFO_Write(CACHE0_PULL0,PFIFO_Def(CACHE1_PULL0_ACCESS,DISABLED));
-
-}
-
-static void EnableFifo(void)
-{
-  /* Enable CACHE1 first */
-  PFIFO_Write(CACHE1_PUSH0,PFIFO_Def(CACHE1_PUSH0_ACCESS,ENABLED));
-  PFIFO_Write(CACHE1_PULL0,PFIFO_Def(CACHE1_PULL0_ACCESS,ENABLED));
-  PFIFO_Write(CACHES,PFIFO_Def(CACHES_REASSIGN,ENABLED));
-}
-
-
-#define PRIV_RAM_SIZE 0
-#define NUM_FIFO_CONTEXT ((PRIV_RAM_SIZE)? 128 : 64)
-
-/* Clear out channel 0 fifo context */
-static void ClearOutFifoContext(void)
-{
-  int i;
-
-  /* Set up size of PRAM */
-  PRAM_Write(CONFIG_0,PRAM_Val(CONFIG_0_SIZE,PRIV_RAM_SIZE));
-
-  for(i=0;i<NUM_FIFO_CONTEXT;i++) {
-    nvPRAMFCPort[i]=0;
-  }
-}  
-
-int NvKbRamUsedByHW(void)
-{
-  /* Audio scratch and password context are fixed at 4K, 
-   * but hash table, runout and fifo vary with PRIV_RAM_SIZE
-   */
-   return ( (8<<PRIV_RAM_SIZE)+4 );
-}
-
-
-
-static void ClearOutContext(void)
-{
-  int i;
-
-  /* Init context register */
-  PGRAPH_Write(CTX_SWITCH,0);
-
-  ClearOutFifoContext();
-
-  /* Set PUT and GET pointers to address 0*/
-  PFIFO_Write(CACHE1_PUT,0);PFIFO_Write(CACHE1_GET,0);
-
-  /* Make sure there is no runout data */
-  PFIFO_Write(RUNOUT_PUT,0);
-  PFIFO_Write(RUNOUT_GET,0);
-
-  /* Nobody is allowed to lie about how much space in the fifo */ 
-  PFIFO_Write(CONFIG_0,PFIFO_Def(CONFIG_0_FREE_LIE,DISABLED));
-
-  /* Clear out CACHED CONTEXT registers */
-  for(i=0;i<NV_PFIFO_CACHE1_CTX__SIZE_1;i++) {
-    PFIFO_Write(CACHE1_CTX(i),0);
-  }
-}
-
-#define HASH_TABLE_DEPTH (2<<PRIV_RAM_SIZE)
-#define HASH_TABLE_SIZE 256
-
-typedef struct {
-  UINT32 id;
-  UINT32 context;
-}HashTableEntry;
-
-static HashTableEntry   localHash[HASH_TABLE_SIZE][HASH_TABLE_DEPTH];
-static HashTableEntry *realHash=NULL;
-
-
-#define HASH_FIFO(h,c) ((((h)^((h)>>8)^((h)>>16)^((h)>>24))&0xFF)^((c)&0x7F))
-
-#define HASH_ENTRY(index,depth) (((index)*HASH_TABLE_DEPTH)+(depth))
-
-static void ClearOutHashTables(void)
-{
-  int i,j;
-
-  if(!realHash) realHash=(HashTableEntry *) nvPRAMHTPort;
-
-  /* Clear out host copy of hash table */
-  for(i=0;i<HASH_TABLE_SIZE;i++) {
-    for(j=0;j<HASH_TABLE_DEPTH;j++) {
-      localHash[i][j].id=0;
-      localHash[i][j].context=0;
-      (realHash+HASH_ENTRY(i,j))->id=0;
-      (realHash+HASH_ENTRY(i,j))->context=0;
-    }
-  }
-  /* Clear out hash virtual registers */
-  for(i=0;i<NV_PRAM_HASH_VIRTUAL__SIZE_1;i++) {
-    PRAM_Write(HASH_VIRTUAL(i),0);
-  }
-}
-
-/* Defaults the context for the channel to be something sensible. 
- * This code is the basis of what needs to be context switched if this 
- * driver ever expands to cope with multiple channels at the same time.
- */
-
-void LoadChannelContext(void)
-{
-  int i;
-  UINT32 read;
-
-
-  /* Force Cache 0 and Cache 1 to be set for channel 0 */
-
-  PFIFO_Write(CACHE0_PUSH1,0);
-  PFIFO_Write(CACHE1_PUSH1,0);
-
-  PFIFO_Write(CACHE1_PULL1, 0);
-  read=PFIFO_Read(CACHE1_PULL1);
-  PFIFO_Write(CACHE1_PULL1,read|PFIFO_Def(CACHE1_PULL1_CTX,DIRTY));
-  read=PFIFO_Read(CACHE1_PULL1);
-  PFIFO_Write(CACHE1_PULL1,read|PFIFO_Def(CACHE1_PULL1_OBJECT,CHANGED));
-
-  /* Set context control. Don't enable channel yet */
-  PGRAPH_Write(CTX_CONTROL,PGRAPH_Def(CTX_CONTROL_MINIMUM_TIME,2MS) |
-		           PGRAPH_Def(CTX_CONTROL_TIME,EXPIRED) |
-		           PGRAPH_Def(CTX_CONTROL_CHID,INVALID) |
-		           PGRAPH_Def(CTX_CONTROL_SWITCHING,IDLE) |
-		           PGRAPH_Def(CTX_CONTROL_DEVICE,ENABLED));
-
-  PGRAPH_Write(CANVAS_MIN,0);
-  PGRAPH_Write(CANVAS_MAX,PACK_UINT16(MAX_UINT16,MAX_UINT16));
-
-  PGRAPH_Write(CLIP_MISC,0);
-  PGRAPH_Write(CLIP0_MIN,0);
-  PGRAPH_Write(CLIP1_MIN,0);
-  PGRAPH_Write(CLIP0_MAX,0);
-  PGRAPH_Write(CLIP1_MAX,0);
-
-  PGRAPH_Write(CANVAS_MISC,PGRAPH_Def(CANVAS_MISC_DAC_BYPASS,DISABLED)|
-                           PGRAPH_Def(CANVAS_MISC_DITHER,ENABLED)|
-                           PGRAPH_Def(CANVAS_MISC_REPLICATE,ENABLED));
-
-  PGRAPH_Write(SOURCE_COLOR,0);
-  PGRAPH_Write(MONO_COLOR0,0);
-  PGRAPH_Write(MONO_COLOR1,0);
-
-  PGRAPH_Write(ABS_UCLIP_XMIN,0);
-  PGRAPH_Write(ABS_UCLIP_YMIN,0);
-  PGRAPH_Write(ABS_UCLIP_XMAX,0);
-  PGRAPH_Write(ABS_UCLIP_YMAX,0);
-
-  /* Beta and Plane Mask */
-  PGRAPH_Write(PLANE_MASK,0xffffffff);
-  PGRAPH_Write(BETA,0);
-  for(i=0;i<NV_PGRAPH_BETA_RAM__SIZE_1;i++) {
-    PGRAPH_Write(BETA_RAM(i),0);
-  }
-
-  for(i=0;i<NV_PGRAPH_ABS_X_RAM__SIZE_1;i++) {
-    PGRAPH_Write(ABS_X_RAM(i),0);
-
-  }
-  for(i=0;i<NV_PGRAPH_ABS_Y_RAM__SIZE_1;i++) {
-    PGRAPH_Write(ABS_Y_RAM(i),0);
-  }
-
-  PGRAPH_Write(ABS_ICLIP_XMAX,0);PGRAPH_Write(ABS_ICLIP_YMAX,0);
-
-  PGRAPH_Write(XY_LOGIC_MISC0,0);PGRAPH_Write(XY_LOGIC_MISC1,0);
-  PGRAPH_Write(X_MISC,0);PGRAPH_Write(Y_MISC,0);
-
-  PGRAPH_Write(SUBDIVIDE,0);PGRAPH_Write(EDGEFILL,0);
-
-  /* Pattern registers . Initialise to something sensible */
-  PGRAPH_Write(PATT_COLOR0_0,0);PGRAPH_Write(PATT_COLOR0_1,0xff);
-  PGRAPH_Write(PATT_COLOR1_0,1);PGRAPH_Write(PATT_COLOR1_1,0xff);
-  PGRAPH_Write(PATTERN(0),0xffffffff);PGRAPH_Write(PATTERN(1),0xffffffff);
-  PGRAPH_Write(PATTERN_SHAPE,0);
-
-  /* Set the ROP to be COPY (Uses Microshaft raster op codes) */
-  PGRAPH_Write(ROP3,0xcc);
-
-  PGRAPH_Write(EXCEPTIONS,0);
-  PGRAPH_Write(BIT33,0);
-
-}
-
-static void EnableFlowThru(void)
-{
-  /* Disable the fifo and the DMA engine, but keep flowthu enabled. 
-   * This state is needed to actually access many of the registers 
-   * in the graphics engine that we are going to set up
-   */
-  PGRAPH_Write(MISC,PGRAPH_Def(MISC_FLOWTHRU_WRITE,ENABLED) |
-                    PGRAPH_Def(MISC_FLOWTHRU,ENABLED) | 
-		    PGRAPH_Def(MISC_FIFO_WRITE,ENABLED) |
-		    PGRAPH_Def(MISC_FIFO,DISABLED) |
-		    PGRAPH_Def(MISC_DMA_WRITE,ENABLED) |
-		    PGRAPH_Def(MISC_DMA,DISABLED) |
-		    PGRAPH_Def(MISC_CLASS_WRITE,ENABLED) |
-		    PGRAPH_Val(MISC_CLASS, 0));
-
-}
-
-
-/* Will need to define here what all this lot actually does */
-
-#define COLOR_CONTEXT_R5G5B5     0x0
-#define COLOR_CONTEXT_R8G8B8     0x1
-#define COLOR_CONTEXT_R10G10B10  0x2
-#define COLOR_CONTEXT_Y8         0x3
-#define COLOR_CONTEXT_Y16        0x4
-
-
-#define GENERATE_CONTEXT(device,cfg,chroma,plane,clip,color,alpha) \
- DEVICE_BASE(device)|\
- SetBF(4:0,cfg)|SetBF(5:5,chroma)|SetBF(6:6,plane)|\
- SetBF(7:7,clip)|SetBF(8:8,0)|SetBF(12:9,color)|\
- SetBF(13:13,alpha)|SetBF(14:14,0)|SetBF(15:15,0)
-  
-/* This value does SRC & PATTERN */
-/* The pattern is disabled/enabled by the ROP code we set up */
-#define PATCH_CONTEXT 0x10
-
-/* All contexts will be generated at run time as we need to set the color
- * format dynamically
- */
-static NVObject ropObject;
-static NVObject clipObject;
-static NVObject patternObject;
-static NVObject rectObject;
-static NVObject blitObject;
-static NVObject colourExpandObject;
-static NVObject lineObject;
-static NVObject linObject;
-static NVObject chromaObject;
-
-#define Info ErrorF
-
-static void InitObject(NVObject *object)
-{
-  UINT32 hash;
-  int i;
-
-  /* Will put an entry into the hash table */
-  hash=HASH_FIFO(object->id,object->channel);
-  
-  for(i=0;i<HASH_TABLE_DEPTH;i++) {
-    if(localHash[hash][i].id==0) break; /* Found an empty slot!!! */
-    /* is object already in cache? */
-    if(localHash[hash][i].context==object->id) return;
-  }
-  if(i==HASH_TABLE_DEPTH) {
-    /* There is no room at the inn. Since we can't cope with reloading
-     * context we had better abort here!!
-     */
-    Info("**** NO ROOM FOR OBJECT %08lx IN HASH TABLE ****\n",object->id);
-    graphicsEngineOk=0; /* Set flag so that we won't use accel */
-    return;
-  }
-  /* Ok, bung entry in at appropriate place */
-  localHash[hash][i].id=object->id;
-  localHash[hash][i].context=object->context;
-  (realHash+HASH_ENTRY(hash,i))->id=object->id;
-  (realHash+HASH_ENTRY(hash,i))->context=object->context;
-}
-
-static void SetUpObjects(int bpp)
-{
-  int colorContext=(bpp==8) ? COLOR_CONTEXT_R8G8B8 : COLOR_CONTEXT_R5G5B5;
-  
-  ropObject.id=ROP_OBJECT_ID;
-  ropObject.channel=0;
-  ropObject.context=GENERATE_CONTEXT(UROP,0,0,0,0,0,0);
-  InitObject(&ropObject);
-
-  clipObject.id=CLIP_OBJECT_ID;
-  clipObject.channel=0;
-  clipObject.context=GENERATE_CONTEXT(UCLIP,0,0,0,0,0,0);
-  InitObject(&clipObject);
-
-  patternObject.id=PATTERN_OBJECT_ID;
-  patternObject.channel=0; 
-  patternObject.context=
-     GENERATE_CONTEXT(UPATT,0,0,0,0,colorContext,0);
-  InitObject(&patternObject);
-  
-  rectObject.id=RECT_OBJECT_ID;
-  rectObject.channel=0; 
-  rectObject.context=
-     GENERATE_CONTEXT(URECT,PATCH_CONTEXT,0,0,1,colorContext,0);
-  InitObject(&rectObject);
-
-
-  blitObject.id=BLIT_OBJECT_ID;
-  blitObject.channel=0; 
-  blitObject.context=
-     GENERATE_CONTEXT(UBLIT,PATCH_CONTEXT,0,0,1,colorContext,0);
-  InitObject(&blitObject);
-
-  colourExpandObject.id=COLOUR_EXPAND_OBJECT_ID;
-  colourExpandObject.channel=0;
-  colourExpandObject.context=
-     GENERATE_CONTEXT(UBITMAP,PATCH_CONTEXT,0,0,1,colorContext,1);
-  InitObject(&colourExpandObject);
-
-  lineObject.id=LINE_OBJECT_ID;
-  lineObject.channel=0;
-  lineObject.context=
-     GENERATE_CONTEXT(ULINE,PATCH_CONTEXT,0,0,1,colorContext,0);
-  InitObject(&lineObject);
-
-  linObject.id=LIN_OBJECT_ID;
-  linObject.channel=0;
-  linObject.context=
-     GENERATE_CONTEXT(ULIN,PATCH_CONTEXT,0,0,1,colorContext,0);
-  InitObject(&linObject);
-}
-
-
-
-static void ClearAndEnableInterrupts(void)
-{
-  PGRAPH_Write(INTR_0,PGRAPH_Def(INTR_0_RESERVED,RESET)|
-                      PGRAPH_Def(INTR_0_CONTEXT_SWITCH,RESET)|
-                      PGRAPH_Def(INTR_0_VBLANK,RESET)|
-                      PGRAPH_Def(INTR_0_RANGE,RESET)|
-                      PGRAPH_Def(INTR_0_METHOD_COUNT,RESET)|
-                      PGRAPH_Def(INTR_0_SOFTWARE,RESET)|
-                      PGRAPH_Def(INTR_0_COMPLEX_CLIP,RESET)|
-                      PGRAPH_Def(INTR_0_NOTIFY,RESET));
-
-
-  /* Enable all interrupts except VBLANK */
-  PGRAPH_Write(INTR_EN_0,PGRAPH_Def(INTR_EN_0_RESERVED,ENABLED)|
-                         PGRAPH_Def(INTR_EN_0_CONTEXT_SWITCH,ENABLED)|
-                         PGRAPH_Def(INTR_EN_0_VBLANK,DISABLED)|
-                         PGRAPH_Def(INTR_EN_0_RANGE,ENABLED)|
-                         PGRAPH_Def(INTR_EN_0_METHOD_COUNT,ENABLED)|
-                         PGRAPH_Def(INTR_EN_0_SOFTWARE,ENABLED)|
-                         PGRAPH_Def(INTR_EN_0_COMPLEX_CLIP,ENABLED)|
-                         PGRAPH_Def(INTR_EN_0_NOTIFY,ENABLED));
-
-  PGRAPH_Write(INTR_1,PGRAPH_Def(INTR_1_METHOD,RESET)|
-                      PGRAPH_Def(INTR_1_DATA,RESET)|
-                      PGRAPH_Def(INTR_1_NOTIFY_INST,RESET)|
-                      PGRAPH_Def(INTR_1_DOUBLE_NOTIFY,RESET)|
-                      PGRAPH_Def(INTR_1_CTXSW_NOTIFY,RESET));
-
-  /* Don't care about any of this lot */
-  PGRAPH_Write(INTR_EN_1,0);
-
-  /* Reset the FIFO interrupt state */
-  PFIFO_Write(INTR_0, PFIFO_Def(INTR_0_CACHE_ERROR,RESET)|
-                      PFIFO_Def(INTR_0_RUNOUT,RESET)|
-                      PFIFO_Def(INTR_0_RUNOUT_OVERFLOW,RESET));
-
-  PFIFO_Write(INTR_EN_0, PFIFO_Def(INTR_EN_0_CACHE_ERROR,ENABLED)|
-                         PFIFO_Def(INTR_EN_0_RUNOUT,ENABLED)|
-                         PFIFO_Def(INTR_EN_0_RUNOUT_OVERFLOW,ENABLED));
-
-  /* Switch on all the user devices in the master control */
-  PMC_Write(ENABLE,PMC_Def(ENABLE_PAUDIO,ENABLED) |
-                   PMC_Def(ENABLE_PDMA,ENABLED)  |
-                   PMC_Def(ENABLE_PFIFO,ENABLED) |
-                   PMC_Def(ENABLE_PGRAPH,ENABLED) |
-                   PMC_Def(ENABLE_PRM,ENABLED) |
-                   PMC_Def(ENABLE_PFB,ENABLED));
-}
-
-static void ResetEngine(void)
-{
-  /* Reset the graphics engine state machine */
-  PGRAPH_Write(DEBUG_1,PGRAPH_Def(DEBUG_1_VOLATILE_RESET,LAST));
-  PGRAPH_Write(DEBUG_0,PGRAPH_Def(DEBUG_0_STATE,RESET));
-}  
-
-static void EnableChannel(void)
-{
-
-  /* Set context control */
-  PGRAPH_Write(CTX_CONTROL,PGRAPH_Def(CTX_CONTROL_MINIMUM_TIME,2MS) |
-		           PGRAPH_Def(CTX_CONTROL_TIME,EXPIRED) |
-		           PGRAPH_Def(CTX_CONTROL_CHID,VALID) |
-		           PGRAPH_Def(CTX_CONTROL_SWITCHING,IDLE) |
-		           PGRAPH_Def(CTX_CONTROL_DEVICE,ENABLED));
-
-
-  PGRAPH_Write(MISC,PGRAPH_Def(MISC_FLOWTHRU_WRITE,ENABLED) |
-		    PGRAPH_Def(MISC_FLOWTHRU,ENABLED) |
-		    PGRAPH_Def(MISC_FIFO_WRITE,ENABLED) |
-		    PGRAPH_Def(MISC_FIFO,ENABLED) |
-		    PGRAPH_Def(MISC_DMA_WRITE,ENABLED) |
-		    PGRAPH_Def(MISC_DMA,ENABLED) |
-		    PGRAPH_Def(MISC_CLASS_WRITE,IGNORED) |
-		    PGRAPH_Val(MISC_CLASS, 0));
-}  
-
-int SetupGraphicsEngine(int bpp)
-{
-  graphicsEngineOk=1;
-
-  WaitForIdle();
-  /* Possibly enable the hardware engines here. Should already be on though */
- 
-  DisableFifo();
-
-  EnableFlowThru(); 
-
-  ResetEngine();
-
-  EnableOptimisations();
-
-  InitDMAInstance();
-
-  ClearAndEnableInterrupts();
-
-  ClearOutContext();
-
-  ClearOutHashTables();
-
-  LoadChannelContext();
-
-  SetUpObjects(bpp);
-
-  EnableChannel();
-
-  EnableFifo();
-
-  return graphicsEngineOk;
-
-}
-
-static int channelOpen=0;
-
-NvChannel *NvOpenChannel(void)
-{
-  if(channelOpen) return NULL;
-   
-  channelOpen=1;
-  return (NvChannel*) nvCHAN0Port;
-}
-
-/* Bit of future-proofing here */
-void NvCloseChannel(void)
-{
-  channelOpen=0;
-}
-
-void NvSync(void)
-{
-  WaitForIdle();
-}
-
-/* This function checks to see if an interrupt has been raised, then
- * prints out the appropriate registers so that you can attempt to 
- * figure out what is going on
- * if you start mucking around with this chip this will happen a lot 
- */
-
-
-
-#define CheckBit(var,device,bitfield) \
-if(var & device##_Mask(bitfield)) {\
-  Info(#device"_"#bitfield" Set\n");\
-}
-
-
-void NvCheckForErrors(void) 
-{
-  UINT32 val=PMC_Read(INTR_0);
-  /* Has an interrupt been raised ???? */  
-  /*if(val==0) return;*/
-  /*  Info("An Interrupt has been raised.\n");*/
-  CheckBit(val,PMC,INTR_0_PAUDIO);
-  CheckBit(val,PMC,INTR_0_PDMA);
-  CheckBit(val,PMC,INTR_0_PFIFO);
-  CheckBit(val,PMC,INTR_0_PGRAPH);
-  CheckBit(val,PMC,INTR_0_PRM);
-  CheckBit(val,PMC,INTR_0_PTIMER);
-  CheckBit(val,PMC,INTR_0_PFB);
-  CheckBit(val,PMC,INTR_0_SOFTWARE);
-
-  val=PGRAPH_Read(INTR_0);
-  CheckBit(val,PGRAPH,INTR_0_RESERVED);
-  CheckBit(val,PGRAPH,INTR_0_CONTEXT_SWITCH);
-  /* CheckBit(val,PGRAPH,INTR_0_VBLANK);*/
-  CheckBit(val,PGRAPH,INTR_0_RANGE);
-  CheckBit(val,PGRAPH,INTR_0_METHOD_COUNT);
-  CheckBit(val,PGRAPH,INTR_0_SOFTWARE);
-  CheckBit(val,PGRAPH,INTR_0_COMPLEX_CLIP);
-  CheckBit(val,PGRAPH,INTR_0_NOTIFY);
-
-  val=PFIFO_Read(INTR_0);
-  CheckBit(val,PFIFO,INTR_0_CACHE_ERROR);
-  CheckBit(val,PFIFO,INTR_0_RUNOUT);
-  CheckBit(val,PFIFO,INTR_0_RUNOUT_OVERFLOW);
-}
Index: xc/programs/Xserver/hw/xfree86/vga256/drivers/nv/nvuser.h
diff -u xc/programs/Xserver/hw/xfree86/vga256/drivers/nv/nvuser.h:1.1.2.3 xc/programs/Xserver/hw/xfree86/vga256/drivers/nv/nvuser.h:1.1.2.5
--- xc/programs/Xserver/hw/xfree86/vga256/drivers/nv/nvuser.h:1.1.2.3	Mon Oct 19 17:33:51 1998
+++ xc/programs/Xserver/hw/xfree86/vga256/drivers/nv/nvuser.h	Tue Dec 22 23:39:14 1998
@@ -31,7 +31,7 @@
 |*                                                                           *|
  \***************************************************************************/
 
-/* $XFree86: xc/programs/Xserver/hw/xfree86/vga256/drivers/nv/nvuser.h,v 1.1.2.3 1998/10/19 07:33:51 hohndel Exp $ */
+/* $XFree86: xc/programs/Xserver/hw/xfree86/vga256/drivers/nv/nvuser.h,v 1.1.2.5 1998/12/22 12:39:14 hohndel Exp $ */
 
 #ifndef __NVUSER_H_
 #define __NVUSER_H_
Index: xc/programs/Xserver/hw/xfree86/vga256/drivers/nv/nvvga.h
diff -u xc/programs/Xserver/hw/xfree86/vga256/drivers/nv/nvvga.h:1.1.2.3 xc/programs/Xserver/hw/xfree86/vga256/drivers/nv/nvvga.h:1.1.2.4
--- xc/programs/Xserver/hw/xfree86/vga256/drivers/nv/nvvga.h:1.1.2.3	Mon Oct 19 17:33:51 1998
+++ xc/programs/Xserver/hw/xfree86/vga256/drivers/nv/nvvga.h	Tue Dec 22 18:37:50 1998
@@ -20,14 +20,17 @@
  * SOFTWARE.
  */
 
-/* $XFree86: xc/programs/Xserver/hw/xfree86/vga256/drivers/nv/nvvga.h,v 1.1.2.3 1998/10/19 07:33:51 hohndel Exp $ */
+/* $XFree86: xc/programs/Xserver/hw/xfree86/vga256/drivers/nv/nvvga.h,v 1.1.2.4 1998/12/22 07:37:50 hohndel Exp $ */
 
 #ifndef __NVVGA_H__
 #define __NVVGA_H__
 
+#ifndef __RIVA_HW_H__
+#include "riva_hw.h"
+#endif
+
 #define PALETTE_SIZE 256
 
-#if 1
 #define NV_PDAC_CURSOR_SIZE                   32
 #define NV_PDAC_CURSOR_PLANE_SIZE         (NV_PDAC_CURSOR_SIZE*4)
 
@@ -63,46 +66,6 @@
   unsigned char plane1[NV_PDAC_CURSOR_PLANE_SIZE];
   unsigned char palette[PALETTE_SIZE][3];
 }NV1Registers;
-#endif
-
-
-/* This is for the NV3, AKA RIVA128. It does have a VGA core, so
- * fits into the SVGA server much easier than the NV1 does
- */
-typedef struct {
-  unsigned char offset,
-                repaint0,
-                repaint1,
-                screenExtra,
-                pixelFormat,
-                horizExtra,
-                fifoControl,
-                fifo;
-
-  unsigned long vpllCoeff,
-                config0,
-                coeffSelect,
-                generalControl;
-}NV3Registers;
-
-/* This is for the NV4, AKA RIVATNT. It does have a VGA core, so
- * fits into the SVGA server much easier than the NV1 does
- */
-typedef struct {
-  unsigned char offset,
-                repaint0,
-                repaint1,
-                screenExtra,
-                pixelFormat,
-                horizExtra,
-                fifoControl,
-                fifo;
-
-  unsigned long vpllCoeff,
-                config0,
-                coeffSelect,
-                generalControl;
-}NV4Registers;
 
 /*
  * Driver data structures.
@@ -112,11 +75,9 @@
   int vgaValid; /* is the above state valid?? */
   NVChipType type; /* What the union holds */
   union {
-    NV1Registers nv1;
-    NV3Registers nv3;
-    NV4Registers nv4;
+    NV1Registers  nv1;
+    RIVA_HW_STATE RivaState;
   }regs;
 } vgaNVRec, *vgaNVPtr;
-
 
 #endif
Index: xc/programs/Xserver/hw/xfree86/vga256/drivers/nv/riva_hw.c
diff -u /dev/null xc/programs/Xserver/hw/xfree86/vga256/drivers/nv/riva_hw.c:1.1.2.3
--- /dev/null	Wed Jan  6 00:32:37 1999
+++ xc/programs/Xserver/hw/xfree86/vga256/drivers/nv/riva_hw.c	Sat Dec 26 11:12:39 1998
@@ -0,0 +1,1355 @@
+ /***************************************************************************\
+|*                                                                           *|
+|*       Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.      *|
+|*                                                                           *|
+|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
+|*     international laws.  Users and possessors of this source code are     *|
+|*     hereby granted a nonexclusive,  royalty-free copyright license to     *|
+|*     use this code in individual and commercial software.                  *|
+|*                                                                           *|
+|*     Any use of this source code must include,  in the user documenta-     *|
+|*     tion and  internal comments to the code,  notices to the end user     *|
+|*     as follows:                                                           *|
+|*                                                                           *|
+|*       Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.      *|
+|*                                                                           *|
+|*     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY     *|
+|*     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"     *|
+|*     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-     *|
+|*     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,     *|
+|*     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-     *|
+|*     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL     *|
+|*     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-     *|
+|*     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-     *|
+|*     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION     *|
+|*     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF     *|
+|*     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.     *|
+|*                                                                           *|
+|*     U.S. Government  End  Users.   This source code  is a "commercial     *|
+|*     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),     *|
+|*     consisting  of "commercial  computer  software"  and  "commercial     *|
+|*     computer  software  documentation,"  as such  terms  are  used in     *|
+|*     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-     *|
+|*     ment only as  a commercial end item.   Consistent with  48 C.F.R.     *|
+|*     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),     *|
+|*     all U.S. Government End Users  acquire the source code  with only     *|
+|*     those rights set forth herein.                                        *|
+|*                                                                           *|
+ \***************************************************************************/
+/* $XFree86: xc/programs/Xserver/hw/xfree86/vga256/drivers/nv/riva_hw.c,v 1.1.2.3 1998/12/26 00:12:39 dawes Exp $ */
+
+#include "riva_hw.h"
+#include "riva_tbl.h"
+#include "compiler.h"
+/*
+ * This file is an OS-agnostic file used to make RIVA 128 and RIVA TNT
+ * operate identically (except TNT has more memory and better 3D quality.
+ */
+
+static int nv3Busy
+(
+    RIVA_HW_INST *chip
+)
+{
+    return ((!(chip->PFIFO[0x00001214/4] & 0x10)) | (chip->PGRAPH[0x000006B0/4] & 0x01));
+}
+static int nv4Busy
+(
+    RIVA_HW_INST *chip
+)
+{
+    return ((!(chip->PFIFO[0x00001214/4] & 0x10)) | (chip->PGRAPH[0x00000700/4] & 0x01));
+}
+static int ShowHideCursor
+(
+    RIVA_HW_INST *chip,
+    int           ShowHide
+)
+{
+    int current;
+    current                     =  chip->CurrentState->cursor1;
+    chip->CurrentState->cursor1 = (chip->CurrentState->cursor1 & 0xFE) | (ShowHide & 0x01);
+    outb(0x3D4,0x31);
+    outb(0x3D5, chip->CurrentState->cursor1);
+    return (current & 0x01);
+}
+
+/****************************************************************************\
+*                                                                            *
+* The video arbitration routines calculate some "magic" numbers.  Fixes      *
+* the snow seen when accessing the framebuffer without it.                   *
+* It just works (I hope).                                                    *
+*                                                                            *
+\****************************************************************************/
+
+#define DEFAULT_GR_LWM 100
+#define DEFAULT_VID_LWM 100
+#define DEFAULT_GR_BURST_SIZE 256
+#define DEFAULT_VID_BURST_SIZE 128
+#define VIDEO		0
+#define GRAPHICS	1
+#define MPORT		2
+#define ENGINE		3
+#define GFIFO_SIZE	320
+#define GFIFO_SIZE_128	256
+#define MFIFO_SIZE	120
+#define VFIFO_SIZE	256
+#define	ABS(a)	(a>0?a:-a)
+typedef struct {
+  int gdrain_rate;
+  int vdrain_rate;
+  int mdrain_rate;
+  int gburst_size;
+  int vburst_size;
+  char vid_en;
+  char gr_en;
+  int wcmocc, wcgocc, wcvocc, wcvlwm, wcglwm;
+  int by_gfacc;
+  char vid_only_once;
+  char gr_only_once;
+  char first_vacc;
+  char first_gacc;
+  char first_macc;
+  int vocc;
+  int gocc;
+  int mocc;
+  char cur;
+  char engine_en;
+  char converged;
+  int priority;
+} nv3_arb_info;
+typedef struct {
+  int graphics_lwm;
+  int video_lwm;
+  int graphics_burst_size;
+  int video_burst_size;
+  int graphics_hi_priority;
+  int media_hi_priority;
+  int rtl_values;
+  int valid;
+} nv3_fifo_info;
+typedef struct {
+  char pix_bpp;
+  char enable_video;
+  char gr_during_vid;
+  char enable_mp;
+  int memory_width;
+  int video_scale;
+  int pclk_khz;
+  int mclk_khz;
+  int mem_page_miss;
+  int mem_latency;
+  char mem_aligned;
+} nv3_sim_state;
+typedef struct {
+  int graphics_lwm;
+  int video_lwm;
+  int graphics_burst_size;
+  int video_burst_size;
+  int valid;
+} nv4_fifo_info;
+typedef struct {
+  int pclk_khz;
+  int mclk_khz;
+  int nvclk_khz;
+  char mem_page_miss;
+  char mem_latency;
+  int memory_width;
+  char enable_video;
+  char gr_during_vid;
+  char pix_bpp;
+  char mem_aligned;
+  char enable_mp;
+} nv4_sim_state;
+static int nv3_iterate(nv3_fifo_info *res_info, nv3_sim_state * state, nv3_arb_info *ainfo)
+{
+    int iter = 0;
+    int tmp, t;
+    int vfsize, mfsize, gfsize;
+    int mburst_size = 32;
+    int mmisses, gmisses, vmisses;
+    int misses;
+    int vlwm, glwm, mlwm;
+    int last, next, cur;
+    int max_gfsize ;
+    long ns;
+
+    vlwm = 0;
+    glwm = 0;
+    mlwm = 0;
+    vfsize = 0;
+    gfsize = 0;
+    cur = ainfo->cur;
+    mmisses = 2;
+    gmisses = 2;
+    vmisses = 2;
+    if (ainfo->gburst_size == 128) max_gfsize = GFIFO_SIZE_128;
+    else  max_gfsize = GFIFO_SIZE;
+    max_gfsize = GFIFO_SIZE;
+    while (1)
+    {
+        if (ainfo->vid_en)
+        {
+            if (ainfo->wcvocc > ainfo->vocc) ainfo->wcvocc = ainfo->vocc;
+            if (ainfo->wcvlwm > vlwm) ainfo->wcvlwm = vlwm ;
+            ns = 1000000 * ainfo->vburst_size/(state->memory_width/8)/state->mclk_khz;
+            vfsize = ns * ainfo->vdrain_rate / 1000000;
+            vfsize =  ainfo->wcvlwm - ainfo->vburst_size + vfsize;
+        }
+        if (state->enable_mp)
+        {
+            if (ainfo->wcmocc > ainfo->mocc) ainfo->wcmocc = ainfo->mocc;
+        }
+        if (ainfo->gr_en)
+        {
+            if (ainfo->wcglwm > glwm) ainfo->wcglwm = glwm ;
+            if (ainfo->wcgocc > ainfo->gocc) ainfo->wcgocc = ainfo->gocc;
+            ns = 1000000 * (ainfo->gburst_size/(state->memory_width/8))/state->mclk_khz;
+            gfsize = ns *ainfo->gdrain_rate/1000000;
+            gfsize = ainfo->wcglwm - ainfo->gburst_size + gfsize;
+        }
+        mfsize = 0;
+        if (!state->gr_during_vid && ainfo->vid_en)
+            if (ainfo->vid_en && (ainfo->vocc < 0) && !ainfo->vid_only_once)
+                next = VIDEO;
+            else if (ainfo->mocc < 0)
+                next = MPORT;
+            else if (ainfo->gocc< ainfo->by_gfacc)
+                next = GRAPHICS;
+            else return (0);
+        else switch (ainfo->priority)
+            {
+                case VIDEO:
+                    if (ainfo->vid_en && ainfo->vocc<0 && !ainfo->vid_only_once)
+                        next = VIDEO;
+                    else if (ainfo->gr_en && ainfo->gocc<0 && !ainfo->gr_only_once)
+                        next = GRAPHICS;
+                    else if (ainfo->mocc<0)
+                        next = MPORT;
+                    else    return (0);
+                    break;
+                case GRAPHICS:
+                    if (ainfo->gr_en && ainfo->gocc<0 && !ainfo->gr_only_once)
+                        next = GRAPHICS;
+                    else if (ainfo->vid_en && ainfo->vocc<0 && !ainfo->vid_only_once)
+                        next = VIDEO;
+                    else if (ainfo->mocc<0)
+                        next = MPORT;
+                    else    return (0);
+                    break;
+                default:
+                    if (ainfo->mocc<0)
+                        next = MPORT;
+                    else if (ainfo->gr_en && ainfo->gocc<0 && !ainfo->gr_only_once)
+                        next = GRAPHICS;
+                    else if (ainfo->vid_en && ainfo->vocc<0 && !ainfo->vid_only_once)
+                        next = VIDEO;
+                    else    return (0);
+                    break;
+            }
+        last = cur;
+        cur = next;
+        iter++;
+        switch (cur)
+        {
+            case VIDEO:
+                if (last==cur)    misses = 0;
+                else if (ainfo->first_vacc)   misses = vmisses;
+                else    misses = 1;
+                ainfo->first_vacc = 0;
+                if (last!=cur)
+                {
+                    ns =  1000000 * (vmisses*state->mem_page_miss + state->mem_latency)/state->mclk_khz; 
+                    vlwm = ns * ainfo->vdrain_rate/ 1000000;
+                    vlwm = ainfo->vocc - vlwm;
+                }
+                ns = 1000000*(misses*state->mem_page_miss + ainfo->vburst_size)/(state->memory_width/8)/state->mclk_khz;
+                ainfo->vocc = ainfo->vocc + ainfo->vburst_size - ns*ainfo->vdrain_rate/1000000;
+                ainfo->gocc = ainfo->gocc - ns*ainfo->gdrain_rate/1000000;
+                ainfo->mocc = ainfo->mocc - ns*ainfo->mdrain_rate/1000000;
+                break;
+            case GRAPHICS:
+                if (last==cur)    misses = 0;
+                else if (ainfo->first_gacc)   misses = gmisses;
+                else    misses = 1;
+                ainfo->first_gacc = 0;
+                if (last!=cur)
+                {
+                    ns = 1000000*(gmisses*state->mem_page_miss + state->mem_latency)/state->mclk_khz ;
+                    glwm = ns * ainfo->gdrain_rate/1000000;
+                    glwm = ainfo->gocc - glwm;
+                }
+                ns = 1000000*(misses*state->mem_page_miss + ainfo->gburst_size/(state->memory_width/8))/state->mclk_khz;
+                ainfo->vocc = ainfo->vocc + 0 - ns*ainfo->vdrain_rate/1000000;
+                ainfo->gocc = ainfo->gocc + ainfo->gburst_size - ns*ainfo->gdrain_rate/1000000;
+                ainfo->mocc = ainfo->mocc + 0 - ns*ainfo->mdrain_rate/1000000;
+                break;
+            default:
+                if (last==cur)    misses = 0;
+                else if (ainfo->first_macc)   misses = mmisses;
+                else    misses = 1;
+                ainfo->first_macc = 0;
+                ns = 1000000*(misses*state->mem_page_miss + mburst_size/(state->memory_width/8))/state->mclk_khz;
+                ainfo->vocc = ainfo->vocc + 0 - ns*ainfo->vdrain_rate/1000000;
+                ainfo->gocc = ainfo->gocc + 0 - ns*ainfo->gdrain_rate/1000000;
+                ainfo->mocc = ainfo->mocc + mburst_size - ns*ainfo->mdrain_rate/1000000;
+                break;
+        }
+        if (iter>100)
+        {
+            ainfo->converged = 0;
+            return (1);
+        }
+        ns = 1000000*ainfo->gburst_size/(state->memory_width/8)/state->mclk_khz;
+        tmp = ns * ainfo->gdrain_rate/1000000;
+        if (ABS(ainfo->gburst_size) + ((ABS(ainfo->wcglwm) + 16 ) & ~0x7)    - tmp > max_gfsize)
+        {
+            ainfo->converged = 0;
+            return (1);
+        }
+        ns = 1000000*ainfo->vburst_size/(state->memory_width/8)/state->mclk_khz;
+        tmp = ns * ainfo->vdrain_rate/1000000;
+        if (ABS(ainfo->vburst_size) + (ABS(ainfo->wcvlwm + 32) & ~0xf)  - tmp> VFIFO_SIZE)
+        {
+            ainfo->converged = 0;
+            return (1);
+        }
+        if (ABS(ainfo->gocc) > max_gfsize)
+        {
+            ainfo->converged = 0;
+            return (1);
+        }
+        if (ABS(ainfo->vocc) > VFIFO_SIZE)
+        {
+            ainfo->converged = 0;
+            return (1);
+        }
+        if (ABS(ainfo->mocc) > MFIFO_SIZE)
+        {
+            ainfo->converged = 0;
+            return (1);
+        }
+        if (ABS(vfsize) > VFIFO_SIZE)
+        {
+            ainfo->converged = 0;
+            return (1);
+        }
+        if (ABS(gfsize) > max_gfsize)
+        {
+            ainfo->converged = 0;
+            return (1);
+        }
+        if (ABS(mfsize) > MFIFO_SIZE)
+        {
+            ainfo->converged = 0;
+            return (1);
+        }
+    }
+}
+static char nv3_arb(nv3_fifo_info * res_info, nv3_sim_state * state,  nv3_arb_info *ainfo) 
+{
+    int  g, v, not_done;
+    long ens, vns, mns, gns;
+    int mmisses, gmisses, vmisses, eburst_size, mburst_size;
+    int refresh_cycle;
+
+    refresh_cycle = 0;
+    refresh_cycle = 2*(state->mclk_khz/state->pclk_khz) + 5;
+    mmisses = 2;
+    if (state->mem_aligned) gmisses = 2;
+    else    gmisses = 3;
+    vmisses = 2;
+    eburst_size = state->memory_width * 1;
+    mburst_size = 32;
+    gns = 1000000 * (gmisses*state->mem_page_miss + state->mem_latency)/state->mclk_khz;
+    ainfo->by_gfacc = gns*ainfo->gdrain_rate/1000000;
+    ainfo->wcmocc = 0;
+    ainfo->wcgocc = 0;
+    ainfo->wcvocc = 0;
+    ainfo->wcvlwm = 0;
+    ainfo->wcglwm = 0;
+    ainfo->engine_en = 1;
+    ainfo->converged = 1;
+    if (ainfo->engine_en)
+    {
+        ens =  1000000*(state->mem_page_miss + eburst_size/(state->memory_width/8) +refresh_cycle)/state->mclk_khz;
+        ainfo->mocc = state->enable_mp ? 0-ens*ainfo->mdrain_rate/1000000 : 0;
+        ainfo->vocc = ainfo->vid_en ? 0-ens*ainfo->vdrain_rate/1000000 : 0;
+        ainfo->gocc = ainfo->gr_en ? 0-ens*ainfo->gdrain_rate/1000000 : 0;
+        ainfo->cur = ENGINE;
+        ainfo->first_vacc = 1;
+        ainfo->first_gacc = 1;
+        ainfo->first_macc = 1;
+        nv3_iterate(res_info, state,ainfo);
+    }
+    if (state->enable_mp)
+    {
+        mns = 1000000 * (mmisses*state->mem_page_miss + mburst_size/(state->memory_width/8) + refresh_cycle)/state->mclk_khz;
+        ainfo->mocc = state->enable_mp ? 0 : mburst_size - mns*ainfo->mdrain_rate/1000000;
+        ainfo->vocc = ainfo->vid_en ? 0 : 0- mns*ainfo->vdrain_rate/1000000;
+        ainfo->gocc = ainfo->gr_en ? 0: 0- mns*ainfo->gdrain_rate/1000000;
+        ainfo->cur = MPORT;
+        ainfo->first_vacc = 1;
+        ainfo->first_gacc = 1;
+        ainfo->first_macc = 0;
+        nv3_iterate(res_info, state,ainfo);
+    }
+    if (ainfo->gr_en)
+    {
+        ainfo->first_vacc = 1;
+        ainfo->first_gacc = 0;
+        ainfo->first_macc = 1;
+        gns = 1000000*(gmisses*state->mem_page_miss + ainfo->gburst_size/(state->memory_width/8) + refresh_cycle)/state->mclk_khz;
+        ainfo->gocc = ainfo->gburst_size - gns*ainfo->gdrain_rate/1000000;
+        ainfo->vocc = ainfo->vid_en? 0-gns*ainfo->vdrain_rate/1000000 : 0;
+        ainfo->mocc = state->enable_mp ?  0-gns*ainfo->mdrain_rate/1000000: 0;
+        ainfo->cur = GRAPHICS;
+        nv3_iterate(res_info, state,ainfo);
+    }
+    if (ainfo->vid_en)
+    {
+        ainfo->first_vacc = 0;
+        ainfo->first_gacc = 1;
+        ainfo->first_macc = 1;
+        vns = 1000000*(vmisses*state->mem_page_miss + ainfo->vburst_size/(state->memory_width/8) + refresh_cycle)/state->mclk_khz;
+        ainfo->vocc = ainfo->vburst_size - vns*ainfo->vdrain_rate/1000000;
+        ainfo->gocc = ainfo->gr_en? (0-vns*ainfo->gdrain_rate/1000000) : 0;
+        ainfo->mocc = state->enable_mp? 0-vns*ainfo->mdrain_rate/1000000 :0 ;
+        ainfo->cur = VIDEO;
+        nv3_iterate(res_info, state, ainfo);
+    }
+    if (ainfo->converged)
+    {
+        res_info->graphics_lwm = (int)ABS(ainfo->wcglwm) + 16;
+        res_info->video_lwm = (int)ABS(ainfo->wcvlwm) + 32;
+        res_info->graphics_burst_size = ainfo->gburst_size;
+        res_info->video_burst_size = ainfo->vburst_size;
+        res_info->graphics_hi_priority = (ainfo->priority == GRAPHICS);
+        res_info->media_hi_priority = (ainfo->priority == MPORT);
+        if (res_info->video_lwm > 160)
+        {
+            res_info->graphics_lwm = 256;
+            res_info->video_lwm = 128;
+            res_info->graphics_burst_size = 64;
+            res_info->video_burst_size = 64;
+            res_info->graphics_hi_priority = 0;
+            res_info->media_hi_priority = 0;
+            ainfo->converged = 0;
+            return (0);
+        }
+        if (res_info->video_lwm > 128)
+        {
+            res_info->video_lwm = 128;
+        }
+        return (1);
+    }
+    else
+    {
+        res_info->graphics_lwm = 256;
+        res_info->video_lwm = 128;
+        res_info->graphics_burst_size = 64;
+        res_info->video_burst_size = 64;
+        res_info->graphics_hi_priority = 0;
+        res_info->media_hi_priority = 0;
+        return (0);
+    }
+}
+static char nv3_get_param(nv3_fifo_info *res_info, nv3_sim_state * state, nv3_arb_info *ainfo)
+{
+    int done, g,v, p;
+    int priority, gburst_size, vburst_size, iter;
+    
+    done = 0;
+    if (state->gr_during_vid && ainfo->vid_en)
+        ainfo->priority = MPORT;
+    else
+        ainfo->priority = ainfo->gdrain_rate < ainfo->vdrain_rate ? VIDEO: GRAPHICS;
+    for (p=0; p < 2 && done != 1; p++)
+    {
+        for (g=128 ; (g > 32) && (done != 1); g= g>> 1)
+        {
+            for (v=128; (v >=32) && (done !=1); v = v>> 1)
+            {
+                ainfo->priority = p;
+                ainfo->gburst_size = g;     
+                ainfo->vburst_size = v;
+                done = nv3_arb(res_info, state,ainfo);
+                if (g==128)
+                {
+                    if ((res_info->graphics_lwm + g) > 256)
+                        done = 0;
+                }
+            }
+        }
+    }
+    if (!done)
+        return (0);
+    else
+        return (1);
+}
+static void nv3CalcArbitration 
+(
+    nv3_fifo_info * res_info,
+    nv3_sim_state * state
+)
+{
+    nv3_fifo_info save_info;
+    nv3_arb_info ainfo;
+    char   res_gr, res_vid;
+
+    ainfo.gr_en = 1;
+    ainfo.vid_en = state->enable_video;
+    ainfo.vid_only_once = 0;
+    ainfo.gr_only_once = 0;
+    ainfo.gdrain_rate = (int) state->pclk_khz * state -> pix_bpp/8;
+    ainfo.vdrain_rate = (int) state->pclk_khz * 2;
+    if (state->video_scale != 0)
+        ainfo.vdrain_rate = ainfo.vdrain_rate/state->video_scale;
+    ainfo.mdrain_rate = 33000;
+    res_info->rtl_values = 0;
+    if (!state->gr_during_vid && state->enable_video)
+    {
+        ainfo.gr_only_once = 1;
+        ainfo.gr_en = 1;
+        ainfo.gdrain_rate = 0;
+        res_vid = nv3_get_param(res_info, state,  &ainfo);
+        res_vid = ainfo.converged;
+        save_info.video_lwm = res_info->video_lwm;
+        save_info.video_burst_size = res_info->video_burst_size;
+        ainfo.vid_en = 1;
+        ainfo.vid_only_once = 1;
+        ainfo.gr_en = 1;
+        ainfo.gdrain_rate = (int) state->pclk_khz * state -> pix_bpp/8;
+        ainfo.vdrain_rate = 0;
+        res_gr = nv3_get_param(res_info, state,  &ainfo);
+        res_gr = ainfo.converged;
+        res_info->video_lwm = save_info.video_lwm;
+        res_info->video_burst_size = save_info.video_burst_size;
+        res_info->valid = res_gr & res_vid;
+    }
+    else
+    {
+        if (!ainfo.gr_en) ainfo.gdrain_rate = 0;
+        if (!ainfo.vid_en) ainfo.vdrain_rate = 0;
+        res_gr = nv3_get_param(res_info, state,  &ainfo);
+        res_info->valid = ainfo.converged;
+    }
+}
+void nv3UpdateArbitrationSettings
+(
+    unsigned      VClk, 
+    unsigned      pixelDepth, 
+    unsigned     *burst,
+    unsigned     *lwm,
+    RIVA_HW_INST *chip
+)
+{
+    nv3_fifo_info fifo_data;
+    nv3_sim_state sim_data;
+    unsigned int M, N, P, pll, MClk;
+    
+    pll = chip->PRAMDAC[0x00000504/4];
+    M = (pll >> 0) & 0xFF; N = (pll >> 8) & 0xFF; P = (pll >> 16) & 0x0F;
+    MClk = (N * chip->CrystalFreqKHz / M) >> P;
+    sim_data.pix_bpp        = (char)pixelDepth;
+    sim_data.enable_video   = 0;
+    sim_data.enable_mp      = 0;
+    sim_data.video_scale    = 1;
+    sim_data.memory_width   = (chip->PEXTDEV[0x00000000/4] & 0x10) ? 128 : 64;
+    sim_data.memory_width   = 128;
+    sim_data.mem_latency    = 11;
+    sim_data.mem_aligned    = 1;
+    sim_data.mem_page_miss  = 9;
+    sim_data.gr_during_vid  = 0;
+    sim_data.pclk_khz       = VClk;
+    sim_data.mclk_khz       = MClk;
+    nv3CalcArbitration(&fifo_data, &sim_data);
+    if (fifo_data.valid)
+    {
+        int  b = fifo_data.graphics_burst_size >> 4;
+        *burst = 0;
+        while (b >>= 1) (*burst)++;
+        *lwm   = fifo_data.graphics_lwm >> 3;
+    }
+    else
+    {
+        *lwm   = 0x24;
+        *burst = 0x02;
+    }
+}
+static void nv4CalcArbitration 
+(
+    nv4_fifo_info *fifo,
+    nv4_sim_state *arb
+)
+{
+    int data, m,n,p, pagemiss, cas,width, video_enable, color_key_enable, bpp, align;
+    int nvclks, mclks, pclks, vpagemiss, crtpagemiss, vbs;
+    int found, mclk_extra, mclk_loop, cbs, m1, p1;
+    int xtal_freq, mclk_freq, pclk_freq, nvclk_freq, mp_enable;
+    int us_m, us_n, us_p, video_drain_rate, crtc_drain_rate;
+    int vpm_us, us_video, vlwm, video_fill_us, cpm_us, us_crt,clwm;
+    int craw, vraw;
+
+    fifo->valid = 1;
+    pclk_freq = arb->pclk_khz;
+    mclk_freq = arb->mclk_khz;
+    nvclk_freq = arb->nvclk_khz;
+    pagemiss = arb->mem_page_miss;
+    cas = arb->mem_latency;
+    width = arb->memory_width >> 6;
+    video_enable = arb->enable_video;
+    color_key_enable = arb->gr_during_vid;
+    bpp = arb->pix_bpp;
+    align = arb->mem_aligned;
+    mp_enable = arb->enable_mp;
+    clwm = 0;
+    vlwm = 0;
+    cbs = 128;
+    pclks = 2;
+    nvclks = 2;
+    nvclks += 2;
+    nvclks += 1;
+    mclks = 5;
+    mclks += 3;
+    mclks += 1;
+    mclks += cas;
+    mclks += 1;
+    mclks += 1;
+    mclks += 1;
+    mclks += 1;
+    mclk_extra = 3;
+    nvclks += 2;
+    nvclks += 1;
+    nvclks += 1;
+    nvclks += 1;
+    if (mp_enable)
+        mclks+=4;
+    nvclks += 0;
+    pclks += 0;
+    found = 0;
+    while (found != 1)
+    {
+        fifo->valid = 1;
+        found = 1;
+        mclk_loop = mclks+mclk_extra;
+        us_m = mclk_loop *1000*1000 / mclk_freq;
+        us_n = nvclks*1000*1000 / nvclk_freq;
+        us_p = nvclks*1000*1000 / pclk_freq;
+        if (video_enable)
+        {
+            video_drain_rate = pclk_freq * 2;
+            crtc_drain_rate = pclk_freq * bpp/8;
+            vpagemiss = 2;
+            vpagemiss += 1;
+            crtpagemiss = 2;
+            vpm_us = (vpagemiss * pagemiss)*1000*1000/mclk_freq;
+            if (nvclk_freq * 2 > mclk_freq * width)
+                video_fill_us = cbs*1000*1000 / 16 / nvclk_freq ;
+            else
+                video_fill_us = cbs*1000*1000 / (8 * width) / mclk_freq;
+            us_video = vpm_us + us_m + us_n + us_p + video_fill_us;
+            vlwm = us_video * video_drain_rate/(1000*1000);
+            vlwm++;
+            vbs = 128;
+            if (vlwm > 128) vbs = 64;
+            if (vlwm > (256-64)) vbs = 32;
+            if (nvclk_freq * 2 > mclk_freq * width)
+                video_fill_us = vbs *1000*1000/ 16 / nvclk_freq ;
+            else
+                video_fill_us = vbs*1000*1000 / (8 * width) / mclk_freq;
+            cpm_us = crtpagemiss  * pagemiss *1000*1000/ mclk_freq;
+            us_crt =
+            us_video
+            +video_fill_us
+            +cpm_us
+            +us_m + us_n +us_p
+            ;
+            clwm = us_crt * crtc_drain_rate/(1000*1000);
+            clwm++;
+        }
+        else
+        {
+            crtc_drain_rate = pclk_freq * bpp/8;
+            crtpagemiss = 2;
+            crtpagemiss += 1;
+            cpm_us = crtpagemiss  * pagemiss *1000*1000/ mclk_freq;
+            us_crt =  cpm_us + us_m + us_n + us_p ;
+            clwm = us_crt * crtc_drain_rate/(1000*1000);
+            clwm++;
+        }
+        m1 = clwm + cbs - 512;
+        p1 = m1 * pclk_freq / mclk_freq;
+        p1 = p1 * bpp / 8;
+        if ((p1 < m1) && (m1 > 0))
+        {
+            fifo->valid = 0;
+            found = 0;
+            if (mclk_extra ==0)   found = 1;
+            mclk_extra--;
+        }
+        else if (video_enable)
+        {
+            if ((clwm > 511) || (vlwm > 255))
+            {
+                fifo->valid = 0;
+                found = 0;
+                if (mclk_extra ==0)   found = 1;
+                mclk_extra--;
+            }
+        }
+        else
+        {
+            if (clwm > 519)
+            {
+                fifo->valid = 0;
+                found = 0;
+                if (mclk_extra ==0)   found = 1;
+                mclk_extra--;
+            }
+        }
+        craw = clwm;
+        vraw = vlwm;
+        if (clwm < 384) clwm = 384;
+        if (vlwm < 128) vlwm = 128;
+        data = (int)(clwm);
+        fifo->graphics_lwm = data;
+        fifo->graphics_burst_size = 128;
+        data = (int)((vlwm+15));
+        fifo->video_lwm = data;
+        fifo->video_burst_size = vbs;
+    }
+}
+static void nv4UpdateArbitrationSettings
+(
+    unsigned      VClk, 
+    unsigned      pixelDepth, 
+    unsigned     *burst,
+    unsigned     *lwm,
+    RIVA_HW_INST *chip
+)
+{
+    nv4_fifo_info fifo_data;
+    nv4_sim_state sim_data;
+    unsigned int M, N, P, pll, MClk, NVClk, cfg1;
+
+    pll = chip->PRAMDAC[0x00000504/4];
+    M = (pll >> 0)  & 0xFF; N = (pll >> 8)  & 0xFF; P = (pll >> 16) & 0x0F;
+    MClk  = (N * chip->CrystalFreqKHz / M) >> P;
+    pll = chip->PRAMDAC[0x00000500/4];
+    M = (pll >> 0)  & 0xFF; N = (pll >> 8)  & 0xFF; P = (pll >> 16) & 0x0F;
+    NVClk  = (N * chip->CrystalFreqKHz / M) >> P;
+    cfg1 = chip->PFB[0x00000204/4];
+    sim_data.pix_bpp        = (char)pixelDepth;
+    sim_data.enable_video   = 0;
+    sim_data.enable_mp      = 0;
+    sim_data.memory_width   = (chip->PEXTDEV[0x00000000/4] & 0x10) ? 128 : 64;
+    sim_data.mem_latency    = (char)cfg1 & 0x0F;
+    sim_data.mem_aligned    = 1;
+    sim_data.mem_page_miss  = (char)(((cfg1 >> 4) &0x0F) + ((cfg1 >> 31) & 0x01));
+    sim_data.gr_during_vid  = 0;
+    sim_data.pclk_khz       = VClk;
+    sim_data.mclk_khz       = MClk;
+    sim_data.nvclk_khz      = NVClk;
+    nv4CalcArbitration(&fifo_data, &sim_data);
+    if (fifo_data.valid)
+    {
+        int  b = fifo_data.graphics_burst_size >> 4;
+        *burst = 0;
+        while (b >>= 1) (*burst)++;
+        *lwm   = fifo_data.graphics_lwm >> 3;
+    }
+}
+
+/****************************************************************************\
+*                                                                            *
+*                          RIVA Mode State Routines                          *
+*                                                                            *
+\****************************************************************************/
+
+/*
+ * Calculate the Video Clock parameters for the PLL.
+ */
+static int CalcVClock
+(
+    int           clockIn,
+    int          *clockOut,
+    int          *mOut,
+    int          *nOut,
+    int          *pOut,
+    RIVA_HW_INST *chip
+)
+{
+    unsigned lowM, highM, highP;
+    unsigned DeltaNew, DeltaOld;
+    unsigned VClk, Freq;
+    unsigned M, N, O, P;
+    
+    DeltaOld = 0xFFFFFFFF;
+    VClk     = (unsigned)clockIn;
+    if (chip->CrystalFreqKHz == 14318)
+    {
+        lowM  = 8;
+        highM = 14 - (chip->Architecture == 3);
+    }
+    else
+    {
+        lowM  = 7;
+        highM = 13 - (chip->Architecture == 3);
+    }                      
+    highP = 4 - (chip->Architecture == 3);
+    for (P = 0; P <= highP; P ++)
+    {
+        Freq = VClk << P;
+        if ((Freq >= 128000) && (Freq <= chip->MaxVClockFreqKHz))
+        {
+            for (M = lowM; M <= highM; M++)
+            {
+                N    = (VClk * M / chip->CrystalFreqKHz) << P;
+                Freq = (chip->CrystalFreqKHz * N / M) >> P;
+                if (Freq > VClk)
+                    DeltaNew = Freq - VClk;
+                else
+                    DeltaNew = VClk - Freq;
+                if (DeltaNew < DeltaOld)
+                {
+                    *mOut     = M;
+                    *nOut     = N;
+                    *pOut     = P;
+                    *clockOut = Freq;
+                    DeltaOld  = DeltaNew;
+                }
+            }
+        }
+    }
+    return (DeltaOld != 0xFFFFFFFF);
+}
+/*
+ * Calculate extended mode parameters (SVGA) and save in a 
+ * mode state structure.
+ */
+static void CalcStateExt
+(
+    RIVA_HW_INST  *chip,
+    RIVA_HW_STATE *state,
+    int            bpp,
+    int            width,
+    int            hDisplaySize,
+    int            hDisplay,
+    int            hStart,
+    int            hEnd,
+    int            hTotal,
+    int            height,
+    int            vDisplay,
+    int            vStart,
+    int            vEnd,
+    int            vTotal,
+    int            dotClock
+)
+{
+    int pixelDepth, VClk, m, n, p;
+    /*
+     * Save mode parameters.
+     */
+    state->bpp    = bpp;
+    state->width  = width;
+    state->height = height;
+    /*
+     * Extended RIVA registers.
+     */
+    pixelDepth = (bpp + 1)/8;
+    CalcVClock(dotClock, &VClk, &m, &n, &p, chip);
+    switch (chip->Architecture)
+    {
+        case 3:
+            nv3UpdateArbitrationSettings(VClk, 
+                                         pixelDepth * 8, 
+                                        &(state->arbitration0),
+                                        &(state->arbitration1),
+                                         chip);
+            state->cursor0  = 0x00;
+            state->cursor1  = 0x78;
+            state->cursor2  = 0x00000000;
+            state->pllsel   = 0x10010100;
+            state->config   = ((width + 31)/32)
+                            | (((pixelDepth > 2) ? 3 : pixelDepth) << 8)
+                            | 0x1000;
+            state->general  = 0x00000100;
+            state->repaint1 = hDisplaySize < 1280 ? 0x06 : 0x02;
+            break;
+        case 4:
+            nv4UpdateArbitrationSettings(VClk, 
+                                         pixelDepth * 8, 
+                                        &(state->arbitration0),
+                                        &(state->arbitration1),
+                                         chip);
+            state->cursor0  = 0x00;
+            state->cursor1  = 0xFC;
+            state->cursor2  = 0x00000000;
+            state->pllsel   = 0x10000700;
+            state->config   = 0x00001114;
+            state->general  = bpp == 16 ? 0x00101100 : 0x00100100;
+            state->repaint1 = hDisplaySize < 1280 ? 0x04 : 0x00;
+            break;
+    }
+    state->vpll     = (p << 16) | (n << 8) | m;
+    state->screen   = ((hTotal   & 0x040) >> 2)
+                    | ((vDisplay & 0x400) >> 7)
+                    | ((vStart   & 0x400) >> 8)
+                    | ((vDisplay & 0x400) >> 9)
+                    | ((vTotal   & 0x400) >> 10);
+    state->repaint0 = (((width/8)*pixelDepth) & 0x700) >> 3;
+    state->horiz    = hTotal     < 260 ? 0x00 : 0x01;
+    state->pixel    = pixelDepth > 2   ? 3    : pixelDepth;
+    state->offset0  =
+    state->offset1  =
+    state->offset2  =
+    state->offset3  = 0;
+    state->pitch0   =
+    state->pitch1   =
+    state->pitch2   =
+    state->pitch3   = pixelDepth * width;
+}
+/*
+ * Load fixed function state and pre-calculated/stored state.
+ */
+#define LOAD_FIXED_STATE(tbl,dev)                                       \
+    for (i = 0; i < sizeof(tbl##Table##dev)/8; i++)                 \
+        chip->dev[tbl##Table##dev[i][0]] = tbl##Table##dev[i][1]
+#define LOAD_FIXED_STATE_8BPP(tbl,dev)                                  \
+    for (i = 0; i < sizeof(tbl##Table##dev##_8BPP)/8; i++)            \
+        chip->dev[tbl##Table##dev##_8BPP[i][0]] = tbl##Table##dev##_8BPP[i][1]
+#define LOAD_FIXED_STATE_15BPP(tbl,dev)                                 \
+    for (i = 0; i < sizeof(tbl##Table##dev##_15BPP)/8; i++)           \
+        chip->dev[tbl##Table##dev##_15BPP[i][0]] = tbl##Table##dev##_15BPP[i][1]
+#define LOAD_FIXED_STATE_16BPP(tbl,dev)                                 \
+    for (i = 0; i < sizeof(tbl##Table##dev##_16BPP)/8; i++)           \
+        chip->dev[tbl##Table##dev##_16BPP[i][0]] = tbl##Table##dev##_16BPP[i][1]
+#define LOAD_FIXED_STATE_32BPP(tbl,dev)                                 \
+    for (i = 0; i < sizeof(tbl##Table##dev##_32BPP)/8; i++)           \
+        chip->dev[tbl##Table##dev##_32BPP[i][0]] = tbl##Table##dev##_32BPP[i][1]
+static void LoadStateExt
+(
+    RIVA_HW_INST  *chip,
+    RIVA_HW_STATE *state
+)
+{
+    int i;
+
+    /*
+     * Load HW fixed function state.
+     */
+    LOAD_FIXED_STATE(Riva,PMC);
+    LOAD_FIXED_STATE(Riva,PTIMER);
+    /*
+     * Make sure frame buffer config gets set before loading PRAMIN.
+     */
+    chip->PFB[0x00000200/4] = state->config;
+    switch (chip->Architecture)
+    {
+        case 3:
+            LOAD_FIXED_STATE(nv3,PFIFO);
+            LOAD_FIXED_STATE(nv3,PRAMIN);
+            LOAD_FIXED_STATE(nv3,PGRAPH);
+            switch (state->bpp)
+            {
+                case 15:
+                case 16:
+                    LOAD_FIXED_STATE_15BPP(nv3,PRAMIN);
+                    LOAD_FIXED_STATE_15BPP(nv3,PGRAPH);
+                    chip->Tri03 = (RivaTexturedTriangle03  *)&(chip->FIFO[0x0000E000/4]);
+                    break;
+                case 24:
+                case 32:
+                    LOAD_FIXED_STATE_32BPP(nv3,PRAMIN);
+                    LOAD_FIXED_STATE_32BPP(nv3,PGRAPH);
+                    chip->Tri03 = 0L;
+                    break;
+                case 8:
+                default:
+                    LOAD_FIXED_STATE_8BPP(nv3,PRAMIN);
+                    LOAD_FIXED_STATE_8BPP(nv3,PGRAPH);
+                    chip->Tri03 = 0L;
+                    break;
+            }
+            for (i = 0x00000; i < 0x00800; i++)
+                chip->PRAMIN[0x00000502 + i] = (i << 12) | 0x03;
+            chip->PGRAPH[0x00000630/4] = state->offset0;
+            chip->PGRAPH[0x00000634/4] = state->offset1;
+            chip->PGRAPH[0x00000638/4] = state->offset2;
+            chip->PGRAPH[0x0000063C/4] = state->offset3;
+            chip->PGRAPH[0x00000650/4] = state->pitch0;
+            chip->PGRAPH[0x00000654/4] = state->pitch1;
+            chip->PGRAPH[0x00000658/4] = state->pitch2;
+            chip->PGRAPH[0x0000065C/4] = state->pitch3;
+            break;
+        case 4:
+            LOAD_FIXED_STATE(nv4,PFIFO);
+            LOAD_FIXED_STATE(nv4,PRAMIN);
+            LOAD_FIXED_STATE(nv4,PGRAPH);
+            switch (state->bpp)
+            {
+                case 15:
+                    LOAD_FIXED_STATE_15BPP(nv4,PRAMIN);
+                    LOAD_FIXED_STATE_15BPP(nv4,PGRAPH);
+                    chip->Tri03 = (RivaTexturedTriangle03  *)&(chip->FIFO[0x0000E000/4]);
+                    break;
+                case 16:
+                    LOAD_FIXED_STATE_16BPP(nv4,PRAMIN);
+                    LOAD_FIXED_STATE_16BPP(nv4,PGRAPH);
+                    chip->Tri03 = (RivaTexturedTriangle03  *)&(chip->FIFO[0x0000E000/4]);
+                    break;
+                case 24:
+                case 32:
+                    LOAD_FIXED_STATE_32BPP(nv4,PRAMIN);
+                    LOAD_FIXED_STATE_32BPP(nv4,PGRAPH);
+                    chip->Tri03 = 0L;
+                    break;
+                case 8:
+                default:
+                    LOAD_FIXED_STATE_8BPP(nv4,PRAMIN);
+                    LOAD_FIXED_STATE_8BPP(nv4,PGRAPH);
+                    chip->Tri03 = 0L;
+                    break;
+            }
+            chip->PGRAPH[0x00000640/4] = state->offset0;
+            chip->PGRAPH[0x00000644/4] = state->offset1;
+            chip->PGRAPH[0x00000648/4] = state->offset2;
+            chip->PGRAPH[0x0000064C/4] = state->offset3;
+            chip->PGRAPH[0x00000670/4] = state->pitch0;
+            chip->PGRAPH[0x00000674/4] = state->pitch1;
+            chip->PGRAPH[0x00000678/4] = state->pitch2;
+            chip->PGRAPH[0x0000067C/4] = state->pitch3;
+            break;
+    }
+    LOAD_FIXED_STATE(Riva,FIFO);
+    /*
+     * Load HW mode state.
+     */
+    outb(0x3D4,0x19); outb(0x3D5, state->repaint0);
+    outb(0x3D4,0x1A); outb(0x3D5, state->repaint1);
+    outb(0x3D4,0x25); outb(0x3D5, state->screen);
+    outb(0x3D4,0x28); outb(0x3D5, state->pixel);
+    outb(0x3D4,0x2D); outb(0x3D5, state->horiz);
+    outb(0x3D4,0x1B); outb(0x3D5, state->arbitration0);
+    outb(0x3D4,0x20); outb(0x3D5, state->arbitration1);
+    outb(0x3D4,0x30); outb(0x3D5, state->cursor0);
+    outb(0x3D4,0x31); outb(0x3D5, state->cursor1);
+    chip->PRAMDAC[0x00000300/4]  = state->cursor2;
+    chip->PRAMDAC[0x00000508/4]  = state->vpll;
+    chip->PRAMDAC[0x0000050C/4]  = state->pllsel;
+    chip->PRAMDAC[0x00000600/4]  = state->general;
+    /*
+     * Turn off VBlank enable and reset.
+     */
+    *(chip->VBLANKENABLE) = 0;
+    *(chip->VBLANK)       = chip->VBlankBit;
+    /*
+     * Set interrupt enable.
+     */    
+    chip->PMC[0x00000140/4]  = chip->EnableIRQ & 0x01;
+    /*
+     * Set current state pointer.
+     */
+    chip->CurrentState = state;
+    /*
+     * Reset FIFO free count.
+     */
+    chip->FifoFreeCount = 0;
+}
+static void UnloadStateExt
+(
+    RIVA_HW_INST  *chip,
+    RIVA_HW_STATE *state
+)
+{
+    /*
+     * Save current HW state.
+     */
+    outb(0x3D4,0x19); state->repaint0     = inb(0x3D5);
+    outb(0x3D4,0x1A); state->repaint1     = inb(0x3D5);
+    outb(0x3D4,0x25); state->screen       = inb(0x3D5);
+    outb(0x3D4,0x28); state->pixel        = inb(0x3D5);
+    outb(0x3D4,0x2D); state->horiz        = inb(0x3D5);
+    outb(0x3D4,0x1B); state->arbitration0 = inb(0x3D5);
+    outb(0x3D4,0x20); state->arbitration1 = inb(0x3D5);
+    outb(0x3D4,0x30); state->cursor0      = inb(0x3D5);
+    outb(0x3D4,0x31); state->cursor1      = inb(0x3D5);
+                      state->cursor2      = chip->PRAMDAC[0x00000300/4];
+                      state->vpll         = chip->PRAMDAC[0x00000508/4];
+                      state->pllsel       = chip->PRAMDAC[0x0000050C/4];
+                      state->general      = chip->PRAMDAC[0x00000600/4];
+                      state->config       = chip->PFB[0x00000200/4];
+                      switch (chip->Architecture)
+                      {
+                          case 3:
+                              state->offset0  = chip->PGRAPH[0x00000630/4];
+                              state->offset1  = chip->PGRAPH[0x00000634/4];
+                              state->offset2  = chip->PGRAPH[0x00000638/4];
+                              state->offset3  = chip->PGRAPH[0x0000063C/4];
+                              state->pitch0   = chip->PGRAPH[0x00000650/4];
+                              state->pitch1   = chip->PGRAPH[0x00000654/4];
+                              state->pitch2   = chip->PGRAPH[0x00000658/4];
+                              state->pitch3   = chip->PGRAPH[0x0000065C/4];
+                              break;
+                          case 4:
+                              state->offset0  = chip->PGRAPH[0x00000640/4];
+                              state->offset1  = chip->PGRAPH[0x00000644/4];
+                              state->offset2  = chip->PGRAPH[0x00000648/4];
+                              state->offset3  = chip->PGRAPH[0x0000064C/4];
+                              state->pitch0   = chip->PGRAPH[0x00000670/4];
+                              state->pitch1   = chip->PGRAPH[0x00000674/4];
+                              state->pitch2   = chip->PGRAPH[0x00000678/4];
+                              state->pitch3   = chip->PGRAPH[0x0000067C/4];
+                              break;
+                      }
+}
+static void SetStartAddress
+(
+    RIVA_HW_INST *chip,
+    unsigned      start
+)
+{
+    int offset = start >> 2;
+    int pan    = (start & 3) << 1;
+    unsigned char tmp;
+
+    /*
+     * Unlock extended registers.
+     */
+    outb(chip->LockUnlockIO, chip->LockUnlockIndex);
+    outb(chip->LockUnlockIO + 1, 0x57);
+    /*
+     * Set start address.
+     */
+    outb(0x3D4, 0x0D);
+    outb(0x3D5, offset);
+    outb(0x3D4, 0x0C);
+    outb(0x3D5, offset >> 8);
+    outb(0x3D4, 0x19);
+    tmp = inb(0x3D5);
+    outb(0x3D5, (offset >> 16) & 0x0F | (tmp & 0xF0));
+    /*
+     * 4 pixel pan register.
+     */
+    offset = inb(chip->IO + 0x0A);
+    outb(0x3C0, 0x13);
+    outb(0x3C0, pan);
+}
+static void nv3SetSurfaces2D
+(
+    RIVA_HW_INST *chip,
+    unsigned     surf0,
+    unsigned     surf1
+)
+{
+    while (nv3Busy(chip));
+    chip->PGRAPH[0x00000630/4] = surf0;
+    chip->PGRAPH[0x00000634/4] = surf1;
+}
+static void nv4SetSurfaces2D
+(
+    RIVA_HW_INST *chip,
+    unsigned     surf0,
+    unsigned     surf1
+)
+{
+    while (nv4Busy(chip));
+    chip->PGRAPH[0x00000640/4] = surf0;
+    chip->PGRAPH[0x00000644/4] = surf1;
+}
+static void nv3SetSurfaces3D
+(
+    RIVA_HW_INST *chip,
+    unsigned     surf0,
+    unsigned     surf1
+)
+{
+    while (nv3Busy(chip));
+    chip->PGRAPH[0x00000638/4] = surf0;
+    chip->PGRAPH[0x0000063C/4] = surf1;
+}
+static void nv4SetSurfaces3D
+(
+    RIVA_HW_INST *chip,
+    unsigned     surf0,
+    unsigned     surf1
+)
+{
+    while (nv4Busy(chip));
+    chip->PGRAPH[0x00000648/4] = surf0;
+    chip->PGRAPH[0x0000064C/4] = surf1;
+}
+
+/****************************************************************************\
+*                                                                            *
+*                      Probe RIVA Chip Configuration                         *
+*                                                                            *
+\****************************************************************************/
+
+void nv3GetConfig
+(
+    RIVA_HW_INST *chip
+)
+{
+    /*
+     * Fill in chip configuration.
+     */
+    if (chip->PFB[0x00000000/4] & 0x00000020)
+    {
+        if (((chip->PMC[0x00000000/4] & 0xF0) == 0x20)
+         && ((chip->PMC[0x00000000/4] & 0x0F) >= 0x02))
+        {        
+            /*
+             * SDRAM 128 ZX.
+             */
+            chip->RamBandwidthKBytesPerSec = 800000;
+            switch (chip->PFB[0x00000000/4] & 0x03)
+            {
+                case 2:
+                    chip->RamAmountKBytes = 1024 * 4 - 32;
+                    break;
+                case 1:
+                    chip->RamAmountKBytes = 1024 * 2 - 32;
+                    break;
+                default:
+                    chip->RamAmountKBytes = 1024 * 8 - 32;
+                    break;
+            }
+        }            
+        else            
+        {
+            chip->RamBandwidthKBytesPerSec = 1000000;
+            chip->RamAmountKBytes          = 1024 * 8 - 32;
+        }            
+    }
+    else
+    {
+        /*
+         * SGRAM 128.
+         */
+        chip->RamBandwidthKBytesPerSec = 1000000;
+        switch (chip->PFB[0x00000000/4] & 0x00000003)
+        {
+            case 0:
+                chip->RamAmountKBytes = 1024 * 8 - 32;
+                break;
+            case 2:
+                chip->RamAmountKBytes = 1024 * 4 - 32;
+                break;
+            default:
+                chip->RamAmountKBytes = 1024 * 2 - 32;
+                break;
+        }
+    }        
+    chip->CrystalFreqKHz   = (chip->PEXTDEV[0x00000000/4] & 0x00000020) ? 14318 : 13500;
+    chip->CURSOR           = &(chip->PRAMIN[0x00008000/4 - 0x0800/4]);
+    chip->CURSORPOS        = &(chip->PRAMDAC[0x0300/4]);
+    chip->VBLANKENABLE     = &(chip->PGRAPH[0x0140/4]);
+    chip->VBLANK           = &(chip->PGRAPH[0x0100/4]);
+    chip->VBlankBit        = 0x00000100;
+    chip->MaxVClockFreqKHz = 230000;
+    chip->LockUnlockIO     = 0x3C4;
+    chip->LockUnlockIndex  = 0x06;
+    /*
+     * Set chip functions.
+     */
+    chip->Busy            = nv3Busy;
+    chip->ShowHideCursor  = ShowHideCursor;
+    chip->CalcStateExt    = CalcStateExt;
+    chip->LoadStateExt    = LoadStateExt;
+    chip->UnloadStateExt  = UnloadStateExt;
+    chip->SetStartAddress = SetStartAddress;
+    chip->SetSurfaces2D   = nv3SetSurfaces2D;
+    chip->SetSurfaces3D   = nv3SetSurfaces3D;
+}
+void nv4GetConfig
+(
+    RIVA_HW_INST *chip
+)
+{
+    /*
+     * Fill in chip configuration.
+     */
+    switch (chip->PFB[0x00000000/4] & 0x00000003)
+    {
+        case 0:
+            chip->RamAmountKBytes = 1024 * 32 - 128;
+            break;
+        case 1:
+            chip->RamAmountKBytes = 1024 * 4 - 128;
+            break;
+        case 2:
+            chip->RamAmountKBytes = 1024 * 8 - 128;
+            break;
+        case 3:
+        default:
+            chip->RamAmountKBytes = 1024 * 16 - 128;
+            break;
+    }
+    switch ((chip->PFB[0x00000000/4] >> 3) & 0x00000003)
+    {
+        case 3:
+            chip->RamBandwidthKBytesPerSec = 800000;
+            break;
+        default:
+            chip->RamBandwidthKBytesPerSec = 1000000;
+            break;
+    }
+    chip->CrystalFreqKHz   = (chip->PEXTDEV[0x00000000/4] & 0x00000040) ? 14318 : 13500;
+    chip->CURSOR           = &(chip->PRAMIN[0x00010000/4 - 0x0800/4]);
+    chip->CURSORPOS        = &(chip->PRAMDAC[0x0300/4]);
+    chip->VBLANKENABLE     = &(chip->PCRTC[0x0140/4]);
+    chip->VBLANK           = &(chip->PCRTC[0x0100/4]);
+    chip->VBlankBit        = 0x00000001;
+    chip->MaxVClockFreqKHz = 250000;
+    chip->LockUnlockIO     = 0x3D4;
+    chip->LockUnlockIndex  = 0x1F;
+    /*
+     * Set chip functions.
+     */
+    chip->Busy            = nv4Busy;
+    chip->ShowHideCursor  = ShowHideCursor;
+    chip->CalcStateExt    = CalcStateExt;
+    chip->LoadStateExt    = LoadStateExt;
+    chip->UnloadStateExt  = UnloadStateExt;
+    chip->SetStartAddress = SetStartAddress;
+    chip->SetSurfaces2D   = nv4SetSurfaces2D;
+    chip->SetSurfaces3D   = nv4SetSurfaces3D;
+}
+int RivaGetConfig
+(
+    RIVA_HW_INST *chip
+)
+{
+    /*
+     * Save this so future SW know whats it's dealing with.
+     */
+    chip->Version = RIVA_SW_VERSION;
+    /*
+     * Chip specific configuration.
+     */
+    switch (chip->Architecture)
+    {
+        case 3:
+            nv3GetConfig(chip);
+            break;
+        case 4:
+            nv4GetConfig(chip);
+            break;
+        default:
+            return (-1);
+    }
+    /*
+     * Fill in FIFO pointers.
+     */
+    chip->Rop    = (RivaRop                 *)&(chip->FIFO[0x00000000/4]);
+    chip->Clip   = (RivaClip                *)&(chip->FIFO[0x00002000/4]);
+    chip->Patt   = (RivaPattern             *)&(chip->FIFO[0x00004000/4]);
+    chip->Pixmap = (RivaPixmap              *)&(chip->FIFO[0x00006000/4]);
+    chip->Blt    = (RivaScreenBlt           *)&(chip->FIFO[0x00008000/4]);
+    chip->Bitmap = (RivaBitmap              *)&(chip->FIFO[0x0000A000/4]);
+    chip->Tri03  = (RivaTexturedTriangle03  *)&(chip->FIFO[0x0000E000/4]);
+    return (0);
+}
+
Index: xc/programs/Xserver/hw/xfree86/vga256/drivers/nv/riva_hw.h
diff -u /dev/null xc/programs/Xserver/hw/xfree86/vga256/drivers/nv/riva_hw.h:1.1.2.2
--- /dev/null	Wed Jan  6 00:32:38 1999
+++ xc/programs/Xserver/hw/xfree86/vga256/drivers/nv/riva_hw.h	Wed Dec 23 03:33:19 1998
@@ -0,0 +1,336 @@
+/***************************************************************************\
+|*                                                                           *|
+|*       Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.      *|
+|*                                                                           *|
+|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
+|*     international laws.  Users and possessors of this source code are     *|
+|*     hereby granted a nonexclusive,  royalty-free copyright license to     *|
+|*     use this code in individual and commercial software.                  *|
+|*                                                                           *|
+|*     Any use of this source code must include,  in the user documenta-     *|
+|*     tion and  internal comments to the code,  notices to the end user     *|
+|*     as follows:                                                           *|
+|*                                                                           *|
+|*       Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.      *|
+|*                                                                           *|
+|*     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY     *|
+|*     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"     *|
+|*     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-     *|
+|*     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,     *|
+|*     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-     *|
+|*     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL     *|
+|*     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-     *|
+|*     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-     *|
+|*     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION     *|
+|*     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF     *|
+|*     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.     *|
+|*                                                                           *|
+|*     U.S. Government  End  Users.   This source code  is a "commercial     *|
+|*     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),     *|
+|*     consisting  of "commercial  computer  software"  and  "commercial     *|
+|*     computer  software  documentation,"  as such  terms  are  used in     *|
+|*     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-     *|
+|*     ment only as  a commercial end item.   Consistent with  48 C.F.R.     *|
+|*     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),     *|
+|*     all U.S. Government End Users  acquire the source code  with only     *|
+|*     those rights set forth herein.                                        *|
+|*                                                                           *|
+\***************************************************************************/
+/* $XFree86: xc/programs/Xserver/hw/xfree86/vga256/drivers/nv/riva_hw.h,v 1.1.2.2 1998/12/22 16:33:19 hohndel Exp $ */
+#ifndef __RIVA_HW_H__
+#define __RIVA_HW_H__
+#define RIVA_SW_VERSION 0x00010000
+
+/***************************************************************************\
+*                                                                           *
+*                             FIFO registers.                               *
+*                                                                           *
+\***************************************************************************/
+
+/*
+ * Raster OPeration. Windows style ROP3.
+ */
+typedef volatile struct
+{
+    unsigned reserved00[4];
+    unsigned short FifoFree;
+    unsigned short Nop;
+    unsigned reserved01[0x0BB];
+    unsigned Rop3;
+} RivaRop;
+/*
+ * 8X8 Monochrome pattern.
+ */
+typedef volatile struct
+{
+    unsigned reserved00[4];
+    unsigned short FifoFree;
+    unsigned short Nop;
+    unsigned reserved01[0x0BD];
+    unsigned Shape;
+    unsigned reserved03[0x001];
+    unsigned Color0;
+    unsigned Color1;
+    unsigned Monochrome[2];
+} RivaPattern;
+/*
+ * Scissor clip rectangle.
+ */
+typedef volatile struct
+{
+    unsigned reserved00[4];
+    unsigned short FifoFree;
+    unsigned short Nop;
+    unsigned reserved01[0x0BB];
+    unsigned TopLeft;
+    unsigned WidthHeight;
+} RivaClip;
+/*
+ * 2D filled rectangle.
+ */
+typedef volatile struct
+{
+    unsigned reserved00[4];
+    unsigned short FifoFree;
+    unsigned short Nop[1];
+    unsigned reserved01[0x0BC];
+    unsigned Color;
+    unsigned reserved03[0x03E];
+    unsigned TopLeft;
+    unsigned WidthHeight;
+} RivaRectangle;
+/*
+ * 2D screen-screen BLT.
+ */
+typedef volatile struct
+{
+    unsigned reserved00[4];
+    unsigned short FifoFree;
+    unsigned short Nop;
+    unsigned reserved01[0x0BB];
+    unsigned TopLeftSrc;
+    unsigned TopLeftDst;
+    unsigned WidthHeight;
+} RivaScreenBlt;
+/*
+ * 2D pixel BLT.
+ */
+typedef volatile struct
+{
+    unsigned reserved00[4];
+    unsigned short FifoFree;
+    unsigned short Nop[1];
+    unsigned reserved01[0x0BC];
+    unsigned TopLeft;
+    unsigned WidthHeight;
+    unsigned WidthHeightIn;
+    unsigned reserved02[0x03C];
+    unsigned Pixels;
+} RivaPixmap;
+/*
+ * Filled rectangle combined with monochrome expand.  Useful for glyphs.
+ */
+typedef volatile struct
+{
+    unsigned reserved00[4];
+    unsigned short FifoFree;
+    unsigned short Nop;
+    unsigned reserved01[0x0BB];
+    unsigned reserved03[(0x040)-1];
+    unsigned Color1A;
+    struct
+    {
+        unsigned TopLeft;
+        unsigned WidthHeight;
+    } UnclippedRectangle[64];
+    unsigned reserved04[(0x080)-3];
+    struct
+    {
+        unsigned TopLeft;
+        unsigned BottomRight;
+    } ClipB;
+    unsigned Color1B;
+    struct
+    {
+        unsigned TopLeft;
+        unsigned BottomRight;
+    } ClippedRectangle[64];
+    unsigned reserved05[(0x080)-5];
+    struct
+    {
+        unsigned TopLeft;
+        unsigned BottomRight;
+    } ClipC;
+    unsigned Color1C;
+    unsigned WidthHeightC;
+    unsigned PointC;
+    unsigned MonochromeData1C;
+    unsigned reserved06[(0x080)+121];
+    struct
+    {
+        unsigned TopLeft;
+        unsigned BottomRight;
+    } ClipD;
+    unsigned Color1D;
+    unsigned WidthHeightInD;
+    unsigned WidthHeightOutD;
+    unsigned PointD;
+    unsigned MonochromeData1D;
+    unsigned reserved07[(0x080)+120];
+    struct
+    {
+        unsigned TopLeft;
+        unsigned BottomRight;
+    } ClipE;
+    unsigned Color0E;
+    unsigned Color1E;
+    unsigned WidthHeightInE;
+    unsigned WidthHeightOutE;
+    unsigned PointE;
+    unsigned MonochromeData01E;
+} RivaBitmap;
+/*
+ * 3D textured, Z buffered triangle.
+ */
+typedef volatile struct
+{
+    unsigned reserved00[4];
+    unsigned short FifoFree;
+    unsigned short Nop;
+    unsigned reserved01[0x0BC];
+    unsigned TextureOffset;
+    unsigned TextureFormat;
+    unsigned TextureFilter;
+    unsigned FogColor;
+    unsigned Control;
+    unsigned AlphaTest;
+    unsigned reserved02[0x339];
+    unsigned FogAndIndex;
+    unsigned Color;
+    float ScreenX;
+    float ScreenY;
+    float ScreenZ;
+    float EyeM;
+    float TextureS;
+    float TextureT;
+} RivaTexturedTriangle03;
+
+/***************************************************************************\
+*                                                                           *
+*                        Virtualized RIVA H/W interface.                    *
+*                                                                           *
+\***************************************************************************/
+
+struct _riva_hw_inst;
+struct _riva_hw_state;
+/*
+ * Virtialized chip interface. Makes RIVA 128 and TNT look alike.
+ */
+typedef struct _riva_hw_inst
+{
+    /*
+     * Chip specific settings.
+     */
+    unsigned Architecture;
+    unsigned Version;
+    unsigned CrystalFreqKHz;
+    unsigned RamAmountKBytes;
+    unsigned MaxVClockFreqKHz;
+    unsigned RamBandwidthKBytesPerSec;
+    unsigned EnableIRQ;
+    unsigned IO;
+    unsigned LockUnlockIO;
+    unsigned LockUnlockIndex;
+    unsigned VBlankBit;
+    unsigned FifoFreeCount;
+    /*
+     * Non-FIFO registers.
+     */
+    volatile unsigned *PCRTC;
+    volatile unsigned *PRAMDAC;
+    volatile unsigned *PFB;
+    volatile unsigned *PFIFO;
+    volatile unsigned *PGRAPH;
+    volatile unsigned *PEXTDEV;
+    volatile unsigned *PTIMER;
+    volatile unsigned *PMC;
+    volatile unsigned *PRAMIN;
+    volatile unsigned *FIFO;
+    volatile unsigned *CURSOR;
+    volatile unsigned *CURSORPOS;
+    volatile unsigned *VBLANKENABLE;
+    volatile unsigned *VBLANK;
+    /*
+     * Common chip functions.
+     */
+    int  (*Busy)(struct _riva_hw_inst *);
+    void (*CalcStateExt)(struct _riva_hw_inst *,struct _riva_hw_state *,int,int,int,int,int,int,int,int,int,int,int,int,int);
+    void (*LoadStateExt)(struct _riva_hw_inst *,struct _riva_hw_state *);
+    void (*UnloadStateExt)(struct _riva_hw_inst *,struct _riva_hw_state *);
+    void (*SetStartAddress)(struct _riva_hw_inst *,unsigned);
+    void (*SetSurfaces2D)(struct _riva_hw_inst *,unsigned,unsigned);
+    void (*SetSurfaces3D)(struct _riva_hw_inst *,unsigned,unsigned);
+    int  (*ShowHideCursor)(struct _riva_hw_inst *,int);
+    /*
+     * Current extended mode settings.
+     */
+    struct _riva_hw_state *CurrentState;
+    /*
+     * FIFO registers.
+     */
+    RivaRop                 *Rop;
+    RivaPattern             *Patt;
+    RivaClip                *Clip;
+    RivaPixmap              *Pixmap;
+    RivaScreenBlt           *Blt;
+    RivaBitmap              *Bitmap;
+    RivaTexturedTriangle03  *Tri03;
+} RIVA_HW_INST;
+/*
+ * Extended mode state information.
+ */
+typedef struct _riva_hw_state
+{
+    unsigned bpp;
+    unsigned width;
+    unsigned height;
+    unsigned repaint0;
+    unsigned repaint1;
+    unsigned screen;
+    unsigned pixel;
+    unsigned horiz;
+    unsigned arbitration0;
+    unsigned arbitration1;
+    unsigned vpll;
+    unsigned pllsel;
+    unsigned general;
+    unsigned config;
+    unsigned cursor0;
+    unsigned cursor1;
+    unsigned cursor2;
+    unsigned offset0;
+    unsigned offset1;
+    unsigned offset2;
+    unsigned offset3;
+    unsigned pitch0;
+    unsigned pitch1;
+    unsigned pitch2;
+    unsigned pitch3;
+} RIVA_HW_STATE;
+/*
+ * External routines.
+ */
+int RivaGetConfig(RIVA_HW_INST *);
+/*
+ * FIFO Free Count. Should attempt to yield processor if RIVA is busy.
+ */
+#define RIVA_FIFO_FREE(hwinst,hwptr,cnt)                                    \
+{                                                                           \
+while ((hwinst).FifoFreeCount < (cnt))                                      \
+{                                                                           \
+    (hwinst).FifoFreeCount = (hwinst).hwptr->FifoFree >> 2;                 \
+}                                                                           \
+(hwinst).FifoFreeCount -= (cnt);                                            \
+}
+#endif /* __RIVA_HW_H__ */
+
Index: xc/programs/Xserver/hw/xfree86/vga256/drivers/nv/riva_tbl.h
diff -u /dev/null xc/programs/Xserver/hw/xfree86/vga256/drivers/nv/riva_tbl.h:1.1.2.2
--- /dev/null	Wed Jan  6 00:32:39 1999
+++ xc/programs/Xserver/hw/xfree86/vga256/drivers/nv/riva_tbl.h	Wed Dec 23 03:33:20 1998
@@ -0,0 +1,395 @@
+ /***************************************************************************\
+|*                                                                           *|
+|*       Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.      *|
+|*                                                                           *|
+|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
+|*     international laws.  Users and possessors of this source code are     *|
+|*     hereby granted a nonexclusive,  royalty-free copyright license to     *|
+|*     use this code in individual and commercial software.                  *|
+|*                                                                           *|
+|*     Any use of this source code must include,  in the user documenta-     *|
+|*     tion and  internal comments to the code,  notices to the end user     *|
+|*     as follows:                                                           *|
+|*                                                                           *|
+|*       Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.      *|
+|*                                                                           *|
+|*     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY     *|
+|*     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"     *|
+|*     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-     *|
+|*     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,     *|
+|*     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-     *|
+|*     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL     *|
+|*     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-     *|
+|*     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-     *|
+|*     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION     *|
+|*     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF     *|
+|*     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.     *|
+|*                                                                           *|
+|*     U.S. Government  End  Users.   This source code  is a "commercial     *|
+|*     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),     *|
+|*     consisting  of "commercial  computer  software"  and  "commercial     *|
+|*     computer  software  documentation,"  as such  terms  are  used in     *|
+|*     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-     *|
+|*     ment only as  a commercial end item.   Consistent with  48 C.F.R.     *|
+|*     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),     *|
+|*     all U.S. Government End Users  acquire the source code  with only     *|
+|*     those rights set forth herein.                                        *|
+|*                                                                           *|
+ \***************************************************************************/
+/* $XFree86: xc/programs/Xserver/hw/xfree86/vga256/drivers/nv/riva_tbl.h,v 1.1.2.2 1998/12/22 16:33:20 hohndel Exp $ */
+/*
+ * RIVA Fixed Functionality Init Tables.
+ */
+static unsigned RivaTablePMC[][2] =
+{
+    {0x00000050, 0x00000000},
+    {0x00000080, 0xFFFF00FF},
+    {0x00000080, 0xFFFFFFFF}
+};
+static unsigned RivaTablePTIMER[][2] =
+{
+    {0x00000080, 0x00000008},
+    {0x00000084, 0x00000003},
+    {0x00000050, 0x00000000},
+    {0x00000040, 0xFFFFFFFF}
+};
+static unsigned RivaTableFIFO[][2] =
+{
+    {0x00000000, 0x80000000},
+    {0x00000800, 0x80000001},
+    {0x00001000, 0x80000002},
+    {0x00001800, 0x80000010},
+    {0x00002000, 0x80000011},
+    {0x00002800, 0x80000012},
+    {0x00003800, 0x80000013}
+};
+static unsigned nv3TablePFIFO[][2] =
+{
+    {0x00000140, 0x00000000},
+    {0x00000480, 0x00000000},
+    {0x00000490, 0x00000000},
+    {0x00000494, 0x00000000},
+    {0x00000481, 0x00000000},
+    {0x00000084, 0x00000000},
+    {0x00000086, 0x00002000},
+    {0x00000085, 0x00002200},
+    {0x00000484, 0x00000000},
+    {0x0000049C, 0x00000000},
+    {0x00000104, 0x00000000},
+    {0x00000108, 0x00000000},
+    {0x00000100, 0x00000000},
+    {0x000004A0, 0x00000000},
+    {0x000004A4, 0x00000000},
+    {0x000004A8, 0x00000000},
+    {0x000004AC, 0x00000000},
+    {0x000004B0, 0x00000000},
+    {0x000004B4, 0x00000000},
+    {0x000004B8, 0x00000000},
+    {0x000004BC, 0x00000000},
+    {0x00000050, 0x00000000},
+    {0x00000040, 0xFFFFFFFF},
+    {0x00000480, 0x00000001},
+    {0x00000490, 0x00000001},
+    {0x00000140, 0x00000001}
+};
+static unsigned nv3TablePGRAPH[][2] =
+{
+    {0x00000020, 0x1230001F},
+    {0x00000021, 0x10113000},
+    {0x00000022, 0x1131F101},
+    {0x00000023, 0x0100F531},
+    {0x00000060, 0x00000000},
+    {0x00000065, 0x00000000},
+    {0x00000068, 0x00000000},
+    {0x00000069, 0x00000000},
+    {0x0000006A, 0x00000000},
+    {0x0000006B, 0x00000000},
+    {0x0000006C, 0x00000000},
+    {0x0000006D, 0x00000000},
+    {0x0000006E, 0x00000000},
+    {0x0000006F, 0x00000000},
+    {0x000001A8, 0x00000000},
+    {0x00000440, 0xFFFFFFFF},
+    {0x00000480, 0x00000001},
+    {0x000001A0, 0x00000000},
+    {0x000001A2, 0x00000000},
+    {0x0000018A, 0xFFFFFFFF},
+    {0x00000190, 0x00000000},
+    {0x00000142, 0x00000000},
+    {0x00000154, 0x00000000},
+    {0x00000155, 0xFFFFFFFF},
+    {0x00000156, 0x00000000},
+    {0x00000157, 0xFFFFFFFF},
+    {0x00000064, 0x10010002},
+    {0x00000050, 0x00000000},
+    {0x00000051, 0x00000000},
+    {0x00000040, 0xFFFFFFFF},
+    {0x00000041, 0xFFFFFFFF},
+    {0x00000440, 0xFFFFFFFF},
+    {0x000001A9, 0x00000001}
+};
+static unsigned nv3TablePGRAPH_8BPP[][2] =
+{
+    {0x000001AA, 0x00001111}
+};
+static unsigned nv3TablePGRAPH_15BPP[][2] =
+{
+    {0x000001AA, 0x00002222}
+};
+static unsigned nv3TablePGRAPH_32BPP[][2] =
+{
+    {0x000001AA, 0x00003333}
+};
+static unsigned nv3TablePRAMIN[][2] =
+{
+    {0x00000500, 0x00010000},
+    {0x00000501, 0x007FFFFF},
+    {0x00000200, 0x80000000},
+    {0x00000201, 0x00C20341},
+    {0x00000204, 0x80000001},
+    {0x00000205, 0x00C50342},
+    {0x00000208, 0x80000002},
+    {0x00000209, 0x00C60343},
+    {0x00000240, 0x80000010},
+    {0x00000241, 0x00D10344},
+    {0x00000244, 0x80000011},
+    {0x00000245, 0x00D00345},
+    {0x00000248, 0x80000012},
+    {0x00000249, 0x00CC0346},
+    {0x0000024C, 0x80000013},
+    {0x0000024D, 0x00D70347},
+    {0x00000D05, 0x00000000},
+    {0x00000D06, 0x00000000},
+    {0x00000D07, 0x00000000},
+    {0x00000D09, 0x00000000},
+    {0x00000D0A, 0x00000000},
+    {0x00000D0B, 0x00000000},
+    {0x00000D0D, 0x00000000},
+    {0x00000D0E, 0x00000000},
+    {0x00000D0F, 0x00000000},
+    {0x00000D11, 0x00000000},
+    {0x00000D12, 0x00000000},
+    {0x00000D13, 0x00000000},
+    {0x00000D15, 0x00000000},
+    {0x00000D16, 0x00000000},
+    {0x00000D17, 0x00000000},
+    {0x00000D19, 0x00000000},
+    {0x00000D1A, 0x00000000},
+    {0x00000D1B, 0x00000000},
+    {0x00000D1D, 0x00000140},
+    {0x00000D1E, 0x00000000},
+    {0x00000D1F, 0x00000000}
+};
+static unsigned nv3TablePRAMIN_8BPP[][2] =
+{
+    {0x00000D04, 0x10110203},
+    {0x00000D08, 0x10110203},
+    {0x00000D0C, 0x10110203},
+    {0x00000D10, 0x10118203},
+    {0x00000D14, 0x10110203},
+    {0x00000D18, 0x10110203},
+    {0x00000D1C, 0x10419208}
+};
+static unsigned nv3TablePRAMIN_15BPP[][2] =
+{
+    {0x00000D04, 0x10110200},
+    {0x00000D08, 0x10110200},
+    {0x00000D0C, 0x10110200},
+    {0x00000D10, 0x10118200},
+    {0x00000D14, 0x10110200},
+    {0x00000D18, 0x10110200},
+    {0x00000D1C, 0x10419208}
+};
+static unsigned nv3TablePRAMIN_32BPP[][2] =
+{
+    {0x00000D04, 0x10110201},
+    {0x00000D08, 0x10110201},
+    {0x00000D0C, 0x10110201},
+    {0x00000D10, 0x10118201},
+    {0x00000D14, 0x10110201},
+    {0x00000D18, 0x10110201},
+    {0x00000D1C, 0x10419208}
+};
+static unsigned nv4TablePFIFO[][2] =
+{
+    {0x00000140, 0x00000000},
+    {0x00000480, 0x00000000},
+    {0x00000494, 0x00000000},
+    {0x00000400, 0x00000000},
+    {0x00000414, 0x00000000},
+    {0x00000084, 0x03000100},  
+    {0x00000085, 0x00000110},
+    {0x00000086, 0x00000112},  
+    {0x00000143, 0x0000FFFF},
+    {0x00000496, 0x0000FFFF},
+    {0x00000050, 0x00000000},
+    {0x00000040, 0xFFFFFFFF},
+    {0x00000415, 0x00000001},
+    {0x00000480, 0x00000001},
+    {0x00000494, 0x00000001},
+    {0x00000495, 0x00000001},
+    {0x00000140, 0x00000001}
+};
+static unsigned nv4TablePGRAPH[][2] =
+{
+    {0x00000020, 0x1231C001},
+    {0x00000021, 0x72111101},
+    {0x00000022, 0x11D5F071},
+    {0x00000023, 0x10D4FF31},
+    {0x00000060, 0x00000000},
+    {0x00000068, 0x00000000},
+    {0x00000070, 0x00000000},
+    {0x00000078, 0x00000000},
+    {0x00000061, 0x00000000},
+    {0x00000069, 0x00000000},
+    {0x00000071, 0x00000000},
+    {0x00000079, 0x00000000},
+    {0x00000062, 0x00000000},
+    {0x0000006A, 0x00000000},
+    {0x00000072, 0x00000000},
+    {0x0000007A, 0x00000000},
+    {0x00000063, 0x00000000},
+    {0x0000006B, 0x00000000},
+    {0x00000073, 0x00000000},
+    {0x0000007B, 0x00000000},
+    {0x00000064, 0x00000000},
+    {0x0000006C, 0x00000000},
+    {0x00000074, 0x00000000},
+    {0x0000007C, 0x00000000},
+    {0x00000065, 0x00000000},
+    {0x0000006D, 0x00000000},
+    {0x00000075, 0x00000000},
+    {0x0000007D, 0x00000000},
+    {0x00000066, 0x00000000},
+    {0x0000006E, 0x00000000},
+    {0x00000076, 0x00000000},
+    {0x0000007E, 0x00000000},
+    {0x00000067, 0x00000000},
+    {0x0000006F, 0x00000000},
+    {0x00000077, 0x00000000},
+    {0x0000007F, 0x00000000},
+    {0x00000058, 0x00000000},
+    {0x00000059, 0x00000000},
+    {0x0000005A, 0x00000000},
+    {0x0000005B, 0x00000000},
+    {0x00000196, 0x00000000},
+    {0x000001A1, 0x00FFFFFF},
+    {0x00000197, 0x00000000},
+    {0x000001A2, 0x00FFFFFF},
+    {0x00000198, 0x00000000},
+    {0x000001A3, 0x00FFFFFF},
+    {0x00000199, 0x00000000},
+    {0x000001A4, 0x00FFFFFF},
+    {0x00000050, 0x00000000},
+    {0x00000040, 0xFFFFFFFF},
+    {0x0000005C, 0x10010100},
+    {0x000001C8, 0x00000001}
+};
+static unsigned nv4TablePGRAPH_8BPP[][2] =
+{
+    {0x000001C4, 0xFFFFFFFF},
+    {0x000001C9, 0x00111111},
+    {0x00000186, 0x00001010},
+    {0x0000020C, 0x01010101}
+};
+static unsigned nv4TablePGRAPH_15BPP[][2] =
+{
+    {0x000001C4, 0xFFFFFFFF},
+    {0x000001C9, 0x00226222},
+    {0x00000186, 0x00002071},
+    {0x0000020C, 0x09090909}
+};
+static unsigned nv4TablePGRAPH_16BPP[][2] =
+{
+    {0x000001C4, 0xFFFFFFFF},
+    {0x000001C9, 0x00556555},
+    {0x00000186, 0x000050C2},
+    {0x0000020C, 0x0C0C0C0C}
+};
+static unsigned nv4TablePGRAPH_32BPP[][2] =
+{
+    {0x000001C4, 0xFFFFFFFF},
+    {0x000001C9, 0x0077D777},
+    {0x00000186, 0x000070E5},
+    {0x0000020C, 0x07070707}
+};
+static unsigned nv4TablePRAMIN[][2] =
+{
+    {0x00000000, 0x80000010},
+    {0x00000001, 0x80011145},
+    {0x00000002, 0x80000011},
+    {0x00000003, 0x80011146},
+    {0x00000004, 0x80000012},
+    {0x00000005, 0x80011147},
+    {0x00000006, 0x80000013},
+    {0x00000007, 0x80011148},
+    {0x00000020, 0x80000000},
+    {0x00000021, 0x80011142},
+    {0x00000022, 0x80000001},
+    {0x00000023, 0x80011143},
+    {0x00000024, 0x80000002},
+    {0x00000025, 0x80011144}, 
+    {0x00000500, 0x00003000},
+    {0x00000501, 0x02FFFFFF},
+    {0x00000502, 0x00000002},
+    {0x00000503, 0x00000002},
+    {0x00000508, 0x01008043},
+    {0x0000050A, 0x00000000},
+    {0x0000050B, 0x00000000},
+    {0x0000050C, 0x01008019},
+    {0x0000050E, 0x00000000},
+    {0x0000050F, 0x00000000},
+    {0x00000510, 0x01008018},
+    {0x00000512, 0x00000000},
+    {0x00000513, 0x00000000},
+    {0x00000514, 0x0100A033},
+    {0x00000516, 0x00000000},
+    {0x00000517, 0x00000000},
+    {0x00000518, 0x0100805F},
+    {0x0000051A, 0x00000000},
+    {0x0000051B, 0x00000000},
+    {0x0000051C, 0x0100804B},
+    {0x0000051E, 0x00000000},
+    {0x0000051F, 0x00000000},
+    {0x00000520, 0x0100A048},
+    {0x00000521, 0x00000D01},
+    {0x00000522, 0x11401140},
+    {0x00000523, 0x00000000}
+};
+static unsigned nv4TablePRAMIN_8BPP[][2] =
+{
+    {0x00000509, 0x00000301},
+    {0x0000050D, 0x00000301},
+    {0x00000511, 0x00000301},
+    {0x00000515, 0x00000301},
+    {0x00000519, 0x00000301},
+    {0x0000051D, 0x00000301}
+};
+static unsigned nv4TablePRAMIN_15BPP[][2] =
+{
+    {0x00000509, 0x00000901},
+    {0x0000050D, 0x00000901},
+    {0x00000511, 0x00000901},
+    {0x00000515, 0x00000901},
+    {0x00000519, 0x00000901},
+    {0x0000051D, 0x00000901}
+};
+static unsigned nv4TablePRAMIN_16BPP[][2] =
+{
+    {0x00000509, 0x00000C01},
+    {0x0000050D, 0x00000C01},
+    {0x00000511, 0x00000C01},
+    {0x00000515, 0x00000C01},
+    {0x00000519, 0x00000C01},
+    {0x0000051D, 0x00000C01}
+};
+static unsigned nv4TablePRAMIN_32BPP[][2] =
+{
+    {0x00000509, 0x00000E01},
+    {0x0000050D, 0x00000E01},
+    {0x00000511, 0x00000E01},
+    {0x00000515, 0x00000E01},
+    {0x00000519, 0x00000E01},
+    {0x0000051D, 0x00000E01}
+};
+
Index: xc/programs/Xserver/hw/xfree86/vga256/drivers/nv/riva_xaa.c
diff -u /dev/null xc/programs/Xserver/hw/xfree86/vga256/drivers/nv/riva_xaa.c:1.1.2.4
--- /dev/null	Wed Jan  6 00:32:39 1999
+++ xc/programs/Xserver/hw/xfree86/vga256/drivers/nv/riva_xaa.c	Sat Dec 26 11:12:39 1998
@@ -0,0 +1,915 @@
+ /***************************************************************************\
+|*                                                                           *|
+|*       Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.      *|
+|*                                                                           *|
+|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
+|*     international laws.  Users and possessors of this source code are     *|
+|*     hereby granted a nonexclusive,  royalty-free copyright license to     *|
+|*     use this code in individual and commercial software.                  *|
+|*                                                                           *|
+|*     Any use of this source code must include,  in the user documenta-     *|
+|*     tion and  internal comments to the code,  notices to the end user     *|
+|*     as follows:                                                           *|
+|*                                                                           *|
+|*       Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.      *|
+|*                                                                           *|
+|*     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY     *|
+|*     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"     *|
+|*     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-     *|
+|*     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,     *|
+|*     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-     *|
+|*     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL     *|
+|*     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-     *|
+|*     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-     *|
+|*     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION     *|
+|*     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF     *|
+|*     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.     *|
+|*                                                                           *|
+|*     U.S. Government  End  Users.   This source code  is a "commercial     *|
+|*     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),     *|
+|*     consisting  of "commercial  computer  software"  and  "commercial     *|
+|*     computer  software  documentation,"  as such  terms  are  used in     *|
+|*     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-     *|
+|*     ment only as  a commercial end item.   Consistent with  48 C.F.R.     *|
+|*     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),     *|
+|*     all U.S. Government End Users  acquire the source code  with only     *|
+|*     those rights set forth herein.                                        *|
+|*                                                                           *|
+ \***************************************************************************/
+/* $XFree86: xc/programs/Xserver/hw/xfree86/vga256/drivers/nv/riva_xaa.c,v 1.1.2.4 1998/12/26 00:12:39 dawes Exp $ */
+/*
+ * Based on the NV1, NV3 code by Dave McKay.
+ *
+ * Copyright 1996-1997  David J. McKay
+ */
+#include <math.h>
+#include <stdlib.h>
+#include "X.h"
+#include "Xproto.h"
+#include "misc.h"
+#include "input.h"
+#include "screenint.h"
+#include "cursorstr.h"
+#include "regionstr.h"
+#include "scrnintstr.h"
+#include "servermd.h"
+#include "windowstr.h"
+#include "compiler.h"
+#include "vga256.h"
+#include "mipointer.h"
+#include "xf86.h"
+#include "xf86Priv.h"
+#include "xf86_Option.h"
+#include "xf86_OSlib.h"
+#include "xf86_HWlib.h"
+#include "xf86xaa.h"
+#include "vga.h"
+#include "vgaPCI.h"
+#define XCONFIG_FLAGS_ONLY
+#include "xf86_Config.h"
+#ifdef XFreeXDGA
+#include "X.h"
+#include "Xproto.h"
+#include "scrnintstr.h"
+#include "servermd.h"
+#define _XF86DGA_SERVER_
+#include "extensions/xf86dgastr.h"
+#endif
+/*
+ * RIVA and NVIDIA specific includes.
+ */
+#include "riva_hw.h"
+#include "nvreg.h"
+#include "nvvga.h"
+/*
+ * Very useful macros that allows you to set overflow bits
+ */
+#define SetBitField(value,from,to) SetBF(to,GetBF(value,from))
+#define SetBit(n) (1<<(n))
+#define Set8Bits(value) ((value)&0xff)
+/*
+ * RIVA hardware instance structure.
+ */
+RIVA_HW_INST riva;
+/*
+ * Buffers.
+ */
+#define RIVA_FRONT_BUFFER       0
+#define RIVA_BACK_BUFFER        1
+#define RIVA_DEPTH_BUFFER       2
+#define RIVA_TEXTURE_BUFFER     3
+#define RIVA_CACHE_BUFFER       4
+unsigned rivaBufferOffset[5] = {0, 0, 0, 0, 0};
+
+/****************************************************************************\
+*                                                                            *
+*                        XAA 2D Accelation Entrypoints                       *
+*                                                                            *
+\****************************************************************************/
+
+/*
+ * 2D render flag for 3D code.
+ */
+int rivaRendered2D = 0;
+/*
+ * Set ROP.  Translate X rop into ROP3.  Internal routine.
+ */
+static int currentRop = -1;
+static void RivaSetRopSolid(int rop)
+{
+    static int ropTrans[16] = 
+    {
+        0x00, /* GXclear        */
+        0x88, /* Gxand          */
+        0x44, /* GXandReverse   */
+        0xCC, /* GXcopy         */
+        0x22, /* GXandInverted  */
+        0xAA, /* GXnoop         */
+        0x66, /* GXxor          */
+        0xEE, /* GXor           */
+        0x11, /* GXnor          */
+        0x99, /* GXequiv        */
+        0x55, /* GXinvert       */
+        0xDD, /* GXorReverse    */
+        0x33, /* GXcopyInverted */
+        0xBB, /* GXorInverted   */
+        0x77, /* GXnand         */
+        0xFF  /* GXset          */
+    };
+    
+    if (currentRop != rop)
+    {
+        currentRop     = rop;
+        rivaRendered2D = 1;
+        RIVA_FIFO_FREE(riva, Rop, 1);
+        riva.Rop->Rop3 = ropTrans[rop];
+    }
+}
+static void RivaSetRopPattern(int rop)
+{
+    static int ropTrans[16] = 
+    {
+        0x00, /* GXclear        */
+        0xA0, /* Gxand          */
+        0x0A, /* GXandReverse   */
+        0xF0, /* GXcopy         */
+        0x30, /* GXandInverted  */
+        0xAA, /* GXnoop         */
+        0x3A, /* GXxor          */
+        0xFA, /* GXor           */
+        0x03, /* GXnor          */
+        0xA0, /* Gxequiv        */
+        0x0F, /* GXinvert       */
+        0xAF, /* GXorReverse    */
+        0x33, /* GXcopyInverted */
+        0xBB, /* GXorInverted   */
+        0xF3, /* GXnand         */
+        0xFF  /* GXset          */
+    };
+    
+    if (currentRop != rop + 16)
+    {
+        currentRop     = rop + 16; /* +16 is important */
+        rivaRendered2D = 1;
+        RIVA_FIFO_FREE(riva, Rop, 1);
+        riva.Rop->Rop3 = ropTrans[rop];
+    }
+}
+/*
+ * Set scissor clip rect.  Internal routine.
+ */
+static void RivaSetClippingRectangle(int x1, int y1, int x2, int y2)
+{
+    int height = y2-y1 + 1;
+    int width  = x2-x1 + 1;
+
+    rivaRendered2D = 1;
+    RIVA_FIFO_FREE(riva, Clip, 2);
+    riva.Clip->TopLeft     = (y1     << 16) | x1;
+    riva.Clip->WidthHeight = (height << 16) | width;
+}
+/*
+ * Set pattern. Internal routine.
+ */
+static void RivaSetPattern(int clr0, int clr1, int pat0, int pat1)
+{
+    rivaRendered2D = 1;
+    RIVA_FIFO_FREE(riva, Patt, 5);
+    riva.Patt->Shape         = 0; /* 0 = 8X8, 1 = 64X1, 2 = 1X64 */
+    riva.Patt->Color0        = clr0;
+    riva.Patt->Color1        = clr1;
+    riva.Patt->Monochrome[0] = pat0;
+    riva.Patt->Monochrome[1] = pat1;
+}
+/*
+ * Fill solid rectangles.
+ */                                           
+static void RivaSetupForFillRectSolid(int color, int rop, unsigned planemask)
+{
+    RivaSetRopSolid(rop);
+    
+    rivaRendered2D = 1;
+    RIVA_FIFO_FREE(riva, Bitmap, 1);
+    riva.Bitmap->Color1A = color;
+}
+static void RivaSubsequentFillRectSolid(int x, int y, int w, int h)
+{
+    RIVA_FIFO_FREE(riva, Bitmap, 2);
+    riva.Bitmap->UnclippedRectangle[0].TopLeft     = (x << 16) | y;
+    riva.Bitmap->UnclippedRectangle[0].WidthHeight = (w << 16) | h;
+}
+/*
+ * Screen to screen BLTs.
+ */
+static void RivaSetupForScreenToScreenCopy(int xdir, int ydir, int rop, unsigned planemask, int transparency_color)
+{
+    rivaRendered2D = 1;
+    RivaSetRopSolid(rop);
+}
+static void RivaSubsequentScreenToScreenCopy(int x1, int y1, int x2, int y2, int w, int h)
+{
+    RIVA_FIFO_FREE(riva, Blt, 3);
+    riva.Blt->TopLeftSrc  = (y1 << 16) | x1;
+    riva.Blt->TopLeftDst  = (y2 << 16) | x2;
+    riva.Blt->WidthHeight = (h  << 16) | w;
+}
+/*
+ * Synchronise with graphics engine.  Make sure it is idle before returning.
+ * Should attempt to yield CPU if busy for awhile.
+ */
+static void RivaSync(void)
+{
+    while (riva.Busy(&riva));
+}
+
+/****************************************************************************\
+*                                                                            *
+*                        XAA HW Cursor Entrypoints                           *
+*                                                                            *
+\****************************************************************************/
+                              
+/*
+ * RIVA supports full colour cursors as X1R5G5B5.  Upper bit is the XOR
+ * bit.  All 0's equals transparency.
+ */
+#define MAX_CURS            32
+#define TRANSPARENT_PIXEL   0
+#define ConvertToRGB555(red,green,blue) \
+    ((((red)>>11)&0x1F)<<10)|((((green)>>11)&0x1F)<<5)|(((blue)>>11)&0x1F)|0x8000
+/*
+ * Externals.
+ */
+extern vgaHWCursorRec         vgaHWCursor;
+extern miPointerScreenFuncRec xf86PointerScreenFuncs;
+extern xf86InfoRec            xf86Info;
+/*
+ * Internal realized cursor structure.
+ */
+typedef struct
+{
+    unsigned short foreColour, backColour;   /* Colour for this cursor in RGB555 */
+    unsigned short image[MAX_CURS*MAX_CURS]; /* Image */
+}RivaCursor;
+/*
+ * This is the set variables that defines the cursor state within the
+ * driver.
+ */
+static int       RivaCursorHotX, RivaCursorHotY;
+static CursorPtr RivaCursorpCurs;
+/*
+ * This function is called when a new cursor image is requested by
+ * the server. The main thing to do is convert the bitwise image
+ * provided by the server into a format that the graphics card
+ * can conveniently handle, and store that in system memory.
+ * Adapted from accel/s3/s3Cursor.c.
+ */
+static Bool RivaRealizeCursor(ScreenPtr pScr, CursorPtr pCurs)
+{
+    RivaCursor    *cursor;
+    int            x, y, i;
+    int            byteIndex, bitIndex, maskBit, sourceBit;
+    int            height, width;
+    int            pad, lineOffset;
+    unsigned char *source, *mask;
+
+    if (pCurs->bits->refcnt > 1) return (TRUE);
+    if (!(cursor = (RivaCursor*)xalloc(sizeof(RivaCursor)))) return (FALSE);
+    cursor->foreColour = ConvertToRGB555(pCurs->foreRed, pCurs->foreGreen, pCurs->foreBlue);
+    cursor->backColour = ConvertToRGB555(pCurs->backRed, pCurs->backGreen, pCurs->backBlue);
+    height = pCurs->bits->height;
+    width  = pCurs->bits->width;
+    source = (unsigned char *)pCurs->bits->source;
+    mask   = (unsigned char *)pCurs->bits->mask;
+    pad    = PixmapBytePad(width, 1); /* Bytes per line. */
+    for (y = 0, i = 0, lineOffset = 0; y < MAX_CURS; y++, lineOffset += pad)
+    {
+        for (x = 0; x < MAX_CURS; x++, i++)
+        {
+            cursor->image[i] = TRANSPARENT_PIXEL;
+            if (x < width && y < height)
+            {
+                byteIndex = lineOffset + (x >> 3);
+                bitIndex  = x & 0x07;
+                maskBit   = mask[byteIndex]   & (1 << bitIndex);
+                sourceBit = source[byteIndex] & (1 << bitIndex);
+                if (maskBit)
+                    cursor->image[i] = (sourceBit) ? cursor->foreColour : cursor->backColour;
+            }
+        }
+    }
+    pCurs->bits->devPriv[pScr->myNum] = (pointer)cursor;
+    return (TRUE);
+}
+/*
+ * This is called when a cursor is no longer used. The intermediate
+ * cursor image storage that we created needs to be deallocated.
+ */
+static Bool RivaUnrealizeCursor(ScreenPtr pScr, CursorPtr pCurs)
+{
+    if (pCurs->bits->refcnt <= 1 && pCurs->bits->devPriv[pScr->myNum])
+    {
+        xfree(pCurs->bits->devPriv[pScr->myNum]);
+        pCurs->bits->devPriv[pScr->myNum] = 0;
+    }
+    return (TRUE);
+}
+/*
+ * This function is called when the current cursor is moved. It makes
+ * the graphic chip display the cursor at the new position.
+ */
+static void RivaMoveCursor(ScreenPtr pScr, int x, int y)
+{
+    if (xf86VTSema)
+        *(riva.CURSORPOS) = ((x - vga256InfoRec.frameX0 - RivaCursorHotX) & 0xFFFF)
+                          | ((y - vga256InfoRec.frameY0 - RivaCursorHotY) << 16);
+}
+/*
+ * This function uploads a cursor image to the video memory of the
+ * graphics card. The source image has already been converted by the
+ * Realize function to a format that can be quickly transferred to
+ * the card.
+ * This is a local function that is not called from outside of this
+ * module.
+ */
+static void RivaLoadCursorToCard(ScreenPtr pScr, CursorPtr pCurs)
+{
+    int        *image, i, numInts, save;
+    RivaCursor *cursor = (RivaCursor*) pCurs->bits->devPriv[pScr->myNum];
+
+    numInts = sizeof(cursor->image) / sizeof(int);
+    image   = (int *)cursor->image;
+    save    = riva.ShowHideCursor(&riva, 0); /* Hide cursor, saving its current display state */
+    for (i = 0; i < numInts; i++)
+        riva.CURSOR[i] = image[i];
+    riva.ShowHideCursor(&riva, save); /* Restore cursor display state */
+}
+/*
+ * This function should make the graphics chip display new cursor that
+ * has already been "realized". We need to upload it to video memory,
+ * make the graphics chip display it.
+ * This is a local function that is not called from outside of this
+ * module (although it largely corresponds to what the SetCursor
+ * function in the Pointer record needs to do).
+ */
+static void RivaLoadCursor(ScreenPtr pScr, CursorPtr pCurs, int x, int y)
+{
+    RivaCursorpCurs = pCurs;
+    RivaCursorHotX  = pCurs->bits->xhot;
+    RivaCursorHotY  = pCurs->bits->yhot;
+    riva.ShowHideCursor(&riva, 0);
+    RivaLoadCursorToCard(pScr, pCurs);
+    RivaMoveCursor(pScr, x, y);
+    riva.ShowHideCursor(&riva, 1);
+}
+/*
+ * This function should display a new cursor at a new position.
+ */
+static void RivaSetCursor(ScreenPtr pScr, CursorPtr pCurs, int x, int y, Bool generateEvent)
+{
+    if (pCurs && xf86VTSema)
+            RivaLoadCursor(pScr, pCurs, x, y);
+}
+/*
+ * This is a local function that programs the colors of the cursor
+ * on the graphics chip.
+ * Adapted from accel/s3/s3Cursor.c.
+ */
+static void RivaRecolorCursor(ScreenPtr pScr, CursorPtr pCurs, Bool displayed)
+{
+    unsigned short fore, back;
+    RivaCursor    *cursor = (RivaCursor *)pCurs->bits->devPriv[pScr->myNum];
+
+    if (xf86VTSema && displayed)
+    {
+        fore = ConvertToRGB555(pCurs->foreRed, pCurs->foreGreen, pCurs->foreBlue);
+        back = ConvertToRGB555(pCurs->backRed, pCurs->backGreen, pCurs->backBlue);
+        if (cursor->foreColour != fore || cursor->backColour != back)
+            RivaLoadCursorToCard(pScr, pCurs);
+    }
+}
+/*
+ * This function should redisplay a cursor that has been
+ * displayed earlier. It is called by the SVGA server.
+ */
+static void RivaRestoreCursor(ScreenPtr pScr)
+{
+    int x, y;
+
+    miPointerPosition(&x, &y);
+    RivaLoadCursor(pScr, RivaCursorpCurs, x, y);
+}
+/*
+ * This doesn't do very much. It just calls the mi routine. It is called
+ * by the SVGA server.
+ */
+static void RivaWarpCursor(ScreenPtr pScr, int x, int y)
+{
+    miPointerWarpCursor(pScr, x, y);
+    xf86Info.currentScreen = pScr;
+}
+/*
+ * This function is called by the SVGA server. It returns the
+ * size of the hardware cursor that we support when asked for.
+ * It is called by the SVGA server.
+ */
+static void RivaQueryBestSize(int class, unsigned short *pwidth, unsigned short *pheight, ScreenPtr pScreen)
+{
+    if (*pwidth > 0)
+    {
+        if (class == CursorShape)
+            *pwidth = *pheight = MAX_CURS;
+        else
+            (void)mfbQueryBestSize(class, pwidth, pheight, pScreen);
+    }
+}
+/*
+ * This is a high-level init function, called once; it passes a local
+ * miPointerSpriteFuncRec with additional functions that we need to provide.
+ * It is called by the SVGA server.
+ */
+static Bool RivaCursorInit(char *pm,ScreenPtr pScr)
+{
+    static int RivaCursorGeneration = -1;
+    static miPointerSpriteFuncRec RivaPointerSpriteFuncs =
+    {
+        (Bool (*)())RivaRealizeCursor, (Bool (*)())RivaUnrealizeCursor,
+        (void (*)())RivaSetCursor,     (void (*)())RivaMoveCursor,
+    };
+
+    RivaCursorHotX = RivaCursorHotY = 0;
+    if (RivaCursorGeneration != serverGeneration)
+    {
+        if (!(miPointerInitialize(pScr, &RivaPointerSpriteFuncs, &xf86PointerScreenFuncs, FALSE)))
+            return (FALSE);
+        pScr->RecolorCursor  = RivaRecolorCursor;
+        RivaCursorGeneration = serverGeneration;
+    }
+    return (TRUE);
+}
+
+/****************************************************************************\
+*                                                                            *
+*                        XAA Chip Setup Entrypoints                          *
+*                                                                            *
+\****************************************************************************/
+
+/*
+ * Main initialization entrypoint.
+ */
+static void RivaFbInit(void)
+{
+    unsigned surfSize, cacheSize;
+    /*
+     * Hardware Cursor initialization.
+     */
+    if (!OFLG_ISSET(OPTION_SW_CURSOR, &vga256InfoRec.options))
+    {
+        vgaHWCursor.Initialized   = TRUE;
+        vgaHWCursor.Init          = RivaCursorInit;
+        vgaHWCursor.Restore       = RivaRestoreCursor;
+        vgaHWCursor.Warp          = RivaWarpCursor;
+        vgaHWCursor.QueryBestSize = RivaQueryBestSize;
+        if (xf86Verbose)
+            ErrorF("%s %s: %s: Using hardware cursor\n",
+                   XCONFIG_PROBED,
+                   vga256InfoRec.name,
+                   vga256InfoRec.chipset);
+    }
+    /*
+     * 2D acceleration initialization.
+     */
+    if (!OFLG_ISSET(OPTION_NOACCEL, &vga256InfoRec.options))
+    {
+        /*
+         * There are still some problems with delayed syncing.
+         */
+        xf86AccelInfoRec.Flags = BACKGROUND_OPERATIONS/*| DELAYED_SYNC*/;
+        xf86AccelInfoRec.Sync  = RivaSync;
+        /*
+         * Hook filled rectangles.
+         */
+        xf86GCInfoRec.PolyFillRectSolidFlags     = NO_PLANEMASK | NO_TRANSPARENCY;
+        xf86AccelInfoRec.SetupForFillRectSolid   = RivaSetupForFillRectSolid;
+        xf86AccelInfoRec.SubsequentFillRectSolid = RivaSubsequentFillRectSolid;
+        /*
+         * Hook screen-to-screen BLTs.
+         */
+        xf86GCInfoRec.CopyAreaFlags                   = NO_PLANEMASK | NO_TRANSPARENCY;
+        xf86AccelInfoRec.SetupForScreenToScreenCopy   = RivaSetupForScreenToScreenCopy;
+        xf86AccelInfoRec.SubsequentScreenToScreenCopy = RivaSubsequentScreenToScreenCopy;
+        /*
+         * Calc surface size and round up to nearest 256 bytes.
+         */
+        surfSize = vga256InfoRec.virtualY 
+                 * vga256InfoRec.displayWidth
+                 * vga256InfoRec.bitsPerPixel / 8;
+        surfSize = (surfSize + 255) & 0xFFFFFF00;
+        /*
+         * Get a reasonable value for pixmap cache size.
+         */
+        switch (vga256InfoRec.bitsPerPixel)
+        {
+            case 8:
+                cacheSize = vga256InfoRec.videoRam * 1024 - surfSize;
+            break;
+            case 15:
+            case 16:
+                cacheSize = 128 * vga256InfoRec.displayWidth;
+                if ((vga256InfoRec.videoRam < 7*1024) && (vga256InfoRec.displayWidth < 1024))
+                    cacheSize = 0;
+                break;
+            case 24:
+            case 32:
+                cacheSize = 256 * vga256InfoRec.displayWidth;
+                if (vga256InfoRec.videoRam < 15*1024)
+                    cacheSize = vga256InfoRec.videoRam * 1024 - surfSize;
+                break;
+        }
+        if (cacheSize + surfSize > vga256InfoRec.videoRam * 1024)
+            cacheSize = vga256InfoRec.videoRam * 1024 - surfSize;
+        /*
+         * Calc surface offsets.
+         */
+        rivaBufferOffset[RIVA_FRONT_BUFFER]   = 0;
+        rivaBufferOffset[RIVA_CACHE_BUFFER]   = rivaBufferOffset[RIVA_FRONT_BUFFER] + surfSize;
+        rivaBufferOffset[RIVA_BACK_BUFFER]    = rivaBufferOffset[RIVA_CACHE_BUFFER] + cacheSize;
+        rivaBufferOffset[RIVA_DEPTH_BUFFER]   = vga256InfoRec.videoRam * 1024       - surfSize;
+        rivaBufferOffset[RIVA_TEXTURE_BUFFER] = rivaBufferOffset[RIVA_BACK_BUFFER]  + surfSize;
+        /*
+         * Make sure there are no overlapping surfaces.
+         */
+        if (rivaBufferOffset[RIVA_TEXTURE_BUFFER] > rivaBufferOffset[RIVA_DEPTH_BUFFER])
+        {
+            /*
+             * Overlap back and depth buffer.  Accelerated apps can't have both.
+             */
+            rivaBufferOffset[RIVA_TEXTURE_BUFFER] = rivaBufferOffset[RIVA_BACK_BUFFER];
+            rivaBufferOffset[RIVA_BACK_BUFFER]    = rivaBufferOffset[RIVA_DEPTH_BUFFER];
+            if (rivaBufferOffset[RIVA_TEXTURE_BUFFER] > rivaBufferOffset[RIVA_DEPTH_BUFFER])
+            {
+                /*
+                 * Nope, no room.
+                 */
+                rivaBufferOffset[RIVA_BACK_BUFFER]  = 0;
+                rivaBufferOffset[RIVA_DEPTH_BUFFER] = 0;
+            }
+        }
+        /*
+         * Check for any room at all.
+         */
+        if (rivaBufferOffset[RIVA_BACK_BUFFER] > rivaBufferOffset[RIVA_DEPTH_BUFFER])
+        {
+            rivaBufferOffset[RIVA_BACK_BUFFER]    = 0;
+            rivaBufferOffset[RIVA_DEPTH_BUFFER]   = 0;
+            rivaBufferOffset[RIVA_TEXTURE_BUFFER] = 0;
+        }
+        /*
+         * Set pixmap cache if enough room.
+         */
+        if (cacheSize > 1024)
+        {
+            xf86AccelInfoRec.Flags |= PIXMAP_CACHE;
+            xf86InitPixmapCache(&vga256InfoRec,
+                                rivaBufferOffset[RIVA_CACHE_BUFFER],
+                                rivaBufferOffset[RIVA_CACHE_BUFFER] + cacheSize);
+        }
+    }
+}
+/*
+ * Lock and unlock VGA and SVGA registers.
+ */
+static void RivaEnterLeave(Bool enter)
+{
+    unsigned char tmp;
+
+#ifdef XFreeXDGA
+    if (vga256InfoRec.directMode&XF86DGADirectGraphics && !enter)
+    {
+        if (vgaHWCursor.Initialized)
+            riva.ShowHideCursor(&riva, 0);
+        return;
+    }
+#endif 
+
+    if (enter)
+    {
+        xf86EnableIOPorts(vga256InfoRec.scrnIndex);
+        outb(vgaIOBase + 4, 0x11);
+        tmp = inb(vgaIOBase + 5);
+        outb(vgaIOBase + 5, tmp & 0x7F);
+        outb(riva.LockUnlockIO, riva.LockUnlockIndex);
+        outb(riva.LockUnlockIO + 1, 0x57);
+    }
+    else
+    {
+        outb(vgaIOBase + 4, 0x11);
+        tmp = inb(vgaIOBase + 5);
+        outb(vgaIOBase + 5, (tmp & 0x7F) | 0x80);
+        outb(riva.LockUnlockIO, riva.LockUnlockIndex);
+        outb(riva.LockUnlockIO + 1, 0x99);
+        xf86DisableIOPorts(vga256InfoRec.scrnIndex);
+    }
+}
+/*
+ * Initialize mode info.
+ */
+static Bool RivaInit(DisplayModePtr mode)
+{
+    int i;
+    int horizDisplay = (mode->CrtcHDisplay/8)   - 1;
+    int horizStart   = (mode->CrtcHSyncStart/8) - 1;
+    int horizEnd     = (mode->CrtcHSyncEnd/8)   - 1;
+    int horizTotal   = (mode->CrtcHTotal/8)     - 1;
+    int vertDisplay  =  mode->CrtcVDisplay      - 1;
+    int vertStart    =  mode->CrtcVSyncStart    - 1;
+    int vertEnd      =  mode->CrtcVSyncEnd      - 1;
+    int vertTotal    =  mode->CrtcVTotal        - 2;
+
+    /* 
+     * Calculate standard VGA settings.
+     */
+    if (!vgaHWInit(mode, sizeof(vgaNVRec)))
+        return (FALSE);
+    /*
+     * VGA is always valid for RIVA.
+     */
+    ((vgaNVPtr)vgaNewVideoState)->vgaValid = 1;
+    /*
+     * Set all CRTC values.
+     */
+    ((vgaNVPtr)vgaNewVideoState)->std.CRTC[0x0]  = Set8Bits(horizTotal - 4);
+    ((vgaNVPtr)vgaNewVideoState)->std.CRTC[0x1]  = Set8Bits(horizDisplay);
+    ((vgaNVPtr)vgaNewVideoState)->std.CRTC[0x2]  = Set8Bits(horizDisplay);
+    ((vgaNVPtr)vgaNewVideoState)->std.CRTC[0x3]  = SetBitField(horizTotal,4:0,4:0) 
+                                                 | SetBit(7);
+    ((vgaNVPtr)vgaNewVideoState)->std.CRTC[0x4]  = Set8Bits(horizStart);
+    ((vgaNVPtr)vgaNewVideoState)->std.CRTC[0x5]  = SetBitField(horizTotal,5:5,7:7)
+                                                 | SetBitField(horizEnd,4:0,4:0);
+    ((vgaNVPtr)vgaNewVideoState)->std.CRTC[0x6]  = SetBitField(vertTotal,7:0,7:0);
+    ((vgaNVPtr)vgaNewVideoState)->std.CRTC[0x7]  = SetBitField(vertTotal,8:8,0:0)
+                                                 | SetBitField(vertDisplay,8:8,1:1)
+                                                 | SetBitField(vertStart,8:8,2:2)
+                                                 | SetBitField(vertDisplay,8:8,3:3)
+                                                 | SetBit(4)
+                                                 | SetBitField(vertTotal,9:9,5:5)
+                                                 | SetBitField(vertDisplay,9:9,6:6)
+                                                 | SetBitField(vertStart,9:9,7:7);
+    ((vgaNVPtr)vgaNewVideoState)->std.CRTC[0x9]  = SetBitField(vertDisplay,9:9,5:5)
+                                                 | SetBit(6)
+                                                 | ((mode->Flags & V_DBLSCAN) ? 0x80 : 0x00);
+    ((vgaNVPtr)vgaNewVideoState)->std.CRTC[0x10] = Set8Bits(vertStart);
+    ((vgaNVPtr)vgaNewVideoState)->std.CRTC[0x11] = SetBitField(vertEnd,3:0,3:0) | SetBit(5);
+    ((vgaNVPtr)vgaNewVideoState)->std.CRTC[0x12] = Set8Bits(vertDisplay);
+    ((vgaNVPtr)vgaNewVideoState)->std.CRTC[0x13] = ((vga256InfoRec.displayWidth/8)*(vgaBitsPerPixel/8)) & 0xFF;
+    ((vgaNVPtr)vgaNewVideoState)->std.CRTC[0x15] = Set8Bits(vertDisplay);
+    ((vgaNVPtr)vgaNewVideoState)->std.CRTC[0x16] = Set8Bits(vertTotal + 1);
+    /*
+     * Initialize DAC palette.
+     */
+    if(vgaBitsPerPixel != 8 )
+    {
+        if (riva.Architecture == 3)
+            for (i = 0; i < 256; i++)
+            {
+                ((vgaNVPtr)vgaNewVideoState)->std.DAC[i*3]     = i >> 2;
+                ((vgaNVPtr)vgaNewVideoState)->std.DAC[(i*3)+1] = i >> 2;
+                ((vgaNVPtr)vgaNewVideoState)->std.DAC[(i*3)+2] = i >> 2;
+            }
+        else
+            for (i = 0; i < 256; i++)
+            {
+                ((vgaNVPtr)vgaNewVideoState)->std.DAC[i*3]     = i;
+                ((vgaNVPtr)vgaNewVideoState)->std.DAC[(i*3)+1] = i;
+                ((vgaNVPtr)vgaNewVideoState)->std.DAC[(i*3)+2] = i;
+            }
+    }
+    /*
+     * Calculate the extended registers.
+     */
+    switch (vgaBitsPerPixel)
+    {
+        case 8:
+            i = 8;
+            break;
+        case 15:
+        case 16:
+            i = (xf86weight.green == 6) ? 16 : 15;
+            break;
+        default:
+            i = 32;
+    }
+    riva.CalcStateExt(&riva, 
+                      (RIVA_HW_STATE *)&(((vgaNVPtr)vgaNewVideoState)->regs.RivaState),
+                      i, /* BPP */
+                      vga256InfoRec.displayWidth,
+                      mode->CrtcHDisplay,
+                      horizDisplay,
+                      horizStart,
+                      horizEnd,
+                      horizTotal,
+                      vga256InfoRec.virtualY,
+                      vertDisplay,
+                      vertStart,
+                      vertEnd,
+                      vertTotal,
+                      vga256InfoRec.clock[mode->Clock]);
+    return (TRUE);
+}
+/*
+ * Load new mode state.
+ */
+static void RivaRestore(void *data)
+{
+    RIVA_HW_STATE *state = &(((vgaNVPtr)data)->regs.RivaState);
+    vgaProtect(TRUE);
+    /*
+     * Make sure to restore state in this order.  Required for proper 8 bit DAC.
+     * restoration.
+     */
+    riva.LoadStateExt(&riva, state);
+    vgaHWRestore((vgaHWPtr)data);
+    /*
+     * Reset accelerator state. This MUST be done after a mode change to make
+     * the HW update complete.
+     */
+    RivaSetRopSolid(GXcopy);
+    RivaSetClippingRectangle(0, 0, 0x3FFF, 0x3FFF);
+    RivaSetPattern(~0, ~0, 0, 0);
+    vgaProtect(FALSE);
+}
+/*
+ * Save current mode state.
+ */
+static void *RivaSave(void *data)
+{
+    data = vgaHWSave((vgaHWPtr)data, sizeof(vgaNVRec));
+    riva.UnloadStateExt(&riva, (RIVA_HW_STATE *)&(((vgaNVPtr)data)->regs.RivaState));
+    return (data);
+}
+/*
+ * Update scanout address.
+ */
+static void RivaAdjust(int x, int y)
+{
+    int startAddr = (((y*vga256InfoRec.virtualX)+x)*(vgaBitsPerPixel/8));
+    riva.SetStartAddress(&riva, startAddr);
+}
+/*
+ * These are all NO-OPed for now.
+ */
+static int RivaValidMode(DisplayModePtr mode, Bool verbose, int flag)
+{
+    return (MODE_OK);
+}
+static void RivaDisplayPowerManagementSet(int mode)
+{
+}
+static Bool RivaScreenInit(ScreenPtr pScreen, pointer pbits, int xsize, int ysize, int dpix, int dpiy, int width)
+{
+    return (TRUE);
+}
+static void RivaSaveScreen(int on)
+{
+    vgaHWSaveScreen(on);
+}
+static void RivaGetMode(DisplayModePtr display)
+{
+}
+
+/****************************************************************************\
+*                                                                            *
+*                        XAA Chip Probe Entrypoints                          *
+*                                                                            *
+\****************************************************************************/
+
+/*
+ * OS specific code needs to map the registers so the config sense code can get
+ * to the registers.  This keeps the riva_hw.c file OS agnostic.
+ */
+static int RivaProbe(vgaVideoChipRec *nv, void *regBase, void *frameBase)
+{
+    OFLG_SET(OPTION_NOACCEL,   &(nv->ChipOptionFlags));
+    OFLG_SET(OPTION_SW_CURSOR, &(nv->ChipOptionFlags));
+    OFLG_SET(OPTION_HW_CURSOR, &(nv->ChipOptionFlags));
+    /*
+     * No IRQ in use.
+     */
+    riva.EnableIRQ = 0;
+    /*
+     * Map and enable I/O registers.
+     */
+    xf86ClearIOPortList(vga256InfoRec.scrnIndex);
+    xf86AddIOPorts(vga256InfoRec.scrnIndex, Num_VGA_IOPorts, VGA_IOPorts);
+    xf86EnableIOPorts(vga256InfoRec.scrnIndex);
+    /*
+     * Map remaining registers. This MUST be done in the OS specific driver code.
+     */
+    riva.IO      = vgaIOBase = (inb(0x3CC) & 0x01) ? 0x3D0 : 0x3B0;
+    riva.PRAMDAC = (unsigned *)xf86MapVidMem(vga256InfoRec.scrnIndex, MMIO_REGION,((char *)regBase+0x00680000), 0x00001000);
+    riva.PFB     = (unsigned *)xf86MapVidMem(vga256InfoRec.scrnIndex, MMIO_REGION,((char *)regBase+0x00100000), 0x00001000);
+    riva.PFIFO   = (unsigned *)xf86MapVidMem(vga256InfoRec.scrnIndex, MMIO_REGION,((char *)regBase+0x00002000), 0x00002000);
+    riva.PGRAPH  = (unsigned *)xf86MapVidMem(vga256InfoRec.scrnIndex, MMIO_REGION,((char *)regBase+0x00400000), 0x00002000);
+    riva.PEXTDEV = (unsigned *)xf86MapVidMem(vga256InfoRec.scrnIndex, MMIO_REGION,((char *)regBase+0x00101000), 0x00001000);
+    riva.PTIMER  = (unsigned *)xf86MapVidMem(vga256InfoRec.scrnIndex, MMIO_REGION,((char *)regBase+0x00009000), 0x00001000);
+    riva.PMC     = (unsigned *)xf86MapVidMem(vga256InfoRec.scrnIndex, MMIO_REGION,((char *)regBase+0x00000000), 0x00001000);
+    riva.FIFO    = (unsigned *)xf86MapVidMem(vga256InfoRec.scrnIndex, MMIO_REGION,((char *)regBase+0x00800000), 0x00010000);
+    /*
+     * Low level probe.
+     */
+    RivaGetConfig(&riva);
+    /*
+     * Enable extended IO ports.
+     */
+    RivaEnterLeave(ENTER);
+    /*
+     * Fill in the results of the probe.
+     */
+    vga256InfoRec.maxClock = riva.MaxVClockFreqKHz;
+    vga256InfoRec.videoRam = riva.RamAmountKBytes;
+    /*
+     * Set framebuffer information. Linear size must be power of 2 for 8bpp to
+     * work correctly (not the same as videoRam). Round up to next MByte.
+     */
+    nv->ChipLinearSize = ((vga256InfoRec.videoRam + 0x3FF) & ~0x3FF) * 1024;
+    nv->ChipLinearBase = (int)frameBase;
+    nv->ChipHas32bpp   = TRUE;
+    /*
+     * Changes the entries in the NV struct to point at the correct function.
+     */
+    nv->ChipEnterLeave = RivaEnterLeave;
+    nv->ChipInit       = RivaInit;
+    nv->ChipValidMode  = RivaValidMode;
+    nv->ChipSave       = RivaSave;
+    nv->ChipRestore    = RivaRestore;
+    nv->ChipAdjust     = RivaAdjust;
+    nv->ChipSaveScreen = RivaSaveScreen;
+    nv->ChipGetMode    = (void (*)())NoopDDA;
+    nv->ChipFbInit     = RivaFbInit;
+    return (1);
+}
+/*
+ * Need a probe for each architecture because the memory maps are
+ * slightly different for each.
+ */
+int NV3Probe(vgaVideoChipRec *nv, void *regBase, void *frameBase)
+{
+    OFLG_SET(OPTION_NOACCEL,   &(nv->ChipOptionFlags));
+    OFLG_SET(OPTION_SW_CURSOR, &(nv->ChipOptionFlags));
+    OFLG_SET(OPTION_HW_CURSOR, &(nv->ChipOptionFlags));
+    /*
+     * Unfortunately, RIVA 128 only wants to be accelerated at 15 BPP, not 16 BPP.
+     */
+    if (vgaBitsPerPixel == 16)
+        xf86weight.red = xf86weight.green = xf86weight.blue = 5;
+    /*
+     * Record chip architecture based in PCI probe.
+     */
+    riva.Architecture = 3;
+    /*
+     * Map chip-specific memory-mapped registers. This MUST be done in the OS specific driver code.
+     */
+    riva.PRAMIN = (unsigned *)xf86MapVidMem(vga256InfoRec.scrnIndex, MMIO_REGION,((char *)frameBase+0x00C00000), 0x00008000);
+    /*
+     * Call the common chip probe.
+     */
+    return (RivaProbe(nv, regBase, frameBase));
+}
+int NV4Probe(vgaVideoChipRec *nv, void *regBase, void *frameBase)
+{
+    OFLG_SET(OPTION_DAC_8_BIT, &(nv->ChipOptionFlags));
+    OFLG_SET(OPTION_DAC_8_BIT, &vga256InfoRec.options);
+    /*
+     * Record chip architecture based in PCI probe.
+     */
+    riva.Architecture = 4;
+    /*
+     * Map chip-specific memory-mapped registers. This MUST be done in the OS specific driver code.
+     */
+    riva.PRAMIN = (unsigned *)xf86MapVidMem(vga256InfoRec.scrnIndex, MMIO_REGION,((char *)regBase+0x00710000), 0x00010000);
+    riva.PCRTC  = (unsigned *)xf86MapVidMem(vga256InfoRec.scrnIndex, MMIO_REGION,((char *)regBase+0x00600000), 0x00001000);
+    /*
+     * Call the common chip probe.
+     */
+    return (RivaProbe(nv, regBase, frameBase));
+}
+
Index: xc/programs/Xserver/hw/xfree86/vga256/drivers/s3v/s3v_driver.c
diff -u xc/programs/Xserver/hw/xfree86/vga256/drivers/s3v/s3v_driver.c:1.1.2.20 xc/programs/Xserver/hw/xfree86/vga256/drivers/s3v/s3v_driver.c:1.1.2.21
--- xc/programs/Xserver/hw/xfree86/vga256/drivers/s3v/s3v_driver.c:1.1.2.20	Sun Nov  8 21:03:46 1998
+++ xc/programs/Xserver/hw/xfree86/vga256/drivers/s3v/s3v_driver.c	Sat Dec 26 11:12:40 1998
@@ -1,4 +1,4 @@
-/* $XFree86: xc/programs/Xserver/hw/xfree86/vga256/drivers/s3v/s3v_driver.c,v 1.1.2.20 1998/11/08 10:03:46 hohndel Exp $ */
+/* $XFree86: xc/programs/Xserver/hw/xfree86/vga256/drivers/s3v/s3v_driver.c,v 1.1.2.21 1998/12/26 00:12:40 dawes Exp $ */
 
 /*
  *
@@ -195,8 +195,11 @@
    unsigned char tmp;
 
 #ifdef XFreeXDGA
-	if (vga256InfoRec.directMode&XF86DGADirectGraphics && !enter)
+	if (vga256InfoRec.directMode&XF86DGADirectGraphics && !enter) {
+		if (vgaHWCursor.Initialized)
+			S3VHideCursor();
 		return;
+	}
 #endif
 
    if (enter){
Index: xc/programs/Xserver/hw/xfree86/vga256/drivers/tvga8900/t89_driver.c
diff -u xc/programs/Xserver/hw/xfree86/vga256/drivers/tvga8900/t89_driver.c:3.66.2.25 xc/programs/Xserver/hw/xfree86/vga256/drivers/tvga8900/t89_driver.c:3.66.2.29
--- xc/programs/Xserver/hw/xfree86/vga256/drivers/tvga8900/t89_driver.c:3.66.2.25	Mon Nov 16 16:37:00 1998
+++ xc/programs/Xserver/hw/xfree86/vga256/drivers/tvga8900/t89_driver.c	Tue Dec 29 21:57:48 1998
@@ -1,4 +1,4 @@
-/* $XFree86: xc/programs/Xserver/hw/xfree86/vga256/drivers/tvga8900/t89_driver.c,v 3.66.2.25 1998/11/16 05:37:00 dawes Exp $ */
+/* $XFree86: xc/programs/Xserver/hw/xfree86/vga256/drivers/tvga8900/t89_driver.c,v 3.66.2.29 1998/12/29 10:57:48 dawes Exp $ */
 /*
  * Copyright 1992 by Alan Hourihane, Wigan, England.
  *
@@ -895,8 +895,9 @@
 	case CYBER9388:
 	case CYBER9397:
 	case CYBER9520:
-		if((TVGAchipset != CYBER9388) &&
-		   (TVGAchipset != CYBER9397))
+		if(((TVGAchipset != CYBER9388) &&
+		    (TVGAchipset != CYBER9397)) ||
+		   OFLG_ISSET(OPTION_ACCEL, &vga256InfoRec.options))
 			tridentHasAcceleration = TRUE;
 		TVGA8900.ChipHas16bpp = TRUE;
 		TVGA8900.ChipHas24bpp = TRUE;
@@ -1303,10 +1304,11 @@
 
 	if (vgaPCIInfo && vgaPCIInfo->Vendor == PCI_VENDOR_TRIDENT)
 	{
-		OFLG_SET(OPTION_TGUI_PCI_READ_ON,
-			&TVGA8900.ChipOptionFlags);
-		OFLG_SET(OPTION_TGUI_PCI_WRITE_ON,
-			&TVGA8900.ChipOptionFlags);
+		OFLG_SET(OPTION_TGUI_PCI_READ_ON, &TVGA8900.ChipOptionFlags);
+		OFLG_SET(OPTION_TGUI_PCI_WRITE_ON, &TVGA8900.ChipOptionFlags);
+		OFLG_SET(OPTION_PCI_BURST_ON, &TVGA8900.ChipOptionFlags);
+		OFLG_SET(OPTION_PCI_BURST_OFF, &TVGA8900.ChipOptionFlags);
+		OFLG_SET(OPTION_ACCEL, &TVGA8900.ChipOptionFlags);
 	}
 
 	if ( (OFLG_ISSET(OPTION_NOLINEAR_MODE, &vga256InfoRec.options)) &&
@@ -2249,20 +2251,34 @@
 	}
 #endif
 
-	if (vgaPCIInfo && vgaPCIInfo->Vendor == PCI_VENDOR_TRIDENT)
+	if ((vgaPCIInfo && vgaPCIInfo->Vendor == PCI_VENDOR_TRIDENT))
 	{
-		outb(vgaIOBase + 4, 0x39);
-		new->PCIReg = inb(vgaIOBase + 5);
-		/* Turn PCI Burst Read and Write OFF - By Default ! */
-		/* Otherwise the Graphics Engine flakes out !	    */
-		/* But we still allow it to be turned on, if poss.  */
-		new->PCIReg &= 0xF9;
+		unsigned char burst = 0;
+
+		/*
+		 * Turn PCI Burst read and write on by default for all
+		 * chipsets except the 9440.  The 9440 graphics engine
+		 * often flakes out with these enabled.  Some other chipsets
+		 * lockup when burst read and write are not enabled.
+		 * We allow these defaults to be overriden.
+		 */
+		if (TVGAchipset != TGUI9440AGi)
+			burst =	0x06;
 		if (OFLG_ISSET(OPTION_TGUI_PCI_READ_ON,
-					&vga256InfoRec.options))
-			new->PCIReg |= 0x02;
+				&vga256InfoRec.options))
+			burst |= 0x02;
 		if (OFLG_ISSET(OPTION_TGUI_PCI_WRITE_ON,
-					&vga256InfoRec.options))
-			new->PCIReg |= 0x04;
+				&vga256InfoRec.options))
+			burst |= 0x04;
+		if (OFLG_ISSET(OPTION_PCI_BURST_ON, &vga256InfoRec.options))
+			burst |= 0x06;
+		if (OFLG_ISSET(OPTION_PCI_BURST_OFF, &vga256InfoRec.options))
+			burst &= ~0x06;
+
+		outb(vgaIOBase + 4, 0x39);
+		new->PCIReg = inb(vgaIOBase + 5);
+		new->PCIReg &= ~0x06;
+		new->PCIReg |= burst;
 	}
 
 	if (TVGAchipset >= TGUI9440AGi)
Index: xc/programs/Xserver/hw/xfree86/vga256/drivers/tvga8900/tgui_accel.c
diff -u xc/programs/Xserver/hw/xfree86/vga256/drivers/tvga8900/tgui_accel.c:3.6.2.6 xc/programs/Xserver/hw/xfree86/vga256/drivers/tvga8900/tgui_accel.c:3.6.2.7
--- xc/programs/Xserver/hw/xfree86/vga256/drivers/tvga8900/tgui_accel.c:3.6.2.6	Sun Nov  1 01:41:09 1998
+++ xc/programs/Xserver/hw/xfree86/vga256/drivers/tvga8900/tgui_accel.c	Sat Dec 26 11:12:42 1998
@@ -1,4 +1,4 @@
-/* $XFree86: xc/programs/Xserver/hw/xfree86/vga256/drivers/tvga8900/tgui_accel.c,v 3.6.2.6 1998/10/31 14:41:09 hohndel Exp $ */
+/* $XFree86: xc/programs/Xserver/hw/xfree86/vga256/drivers/tvga8900/tgui_accel.c,v 3.6.2.7 1998/12/26 00:12:42 dawes Exp $ */
 
 /*
  * Copyright 1996 by Alan Hourihane, Wigan, England.
@@ -34,7 +34,6 @@
 
 #include "xf86xaa.h"
 
-extern unsigned char *tguiMMIOBase;
 extern int TGUIRops_alu[16];
 extern int TGUIRops_Pixalu[16];
 extern int GE_OP;
Index: xc/programs/Xserver/hw/xfree86/vga256/drivers/tvga8900/tgui_mmio.h
diff -u xc/programs/Xserver/hw/xfree86/vga256/drivers/tvga8900/tgui_mmio.h:3.1.2.5 xc/programs/Xserver/hw/xfree86/vga256/drivers/tvga8900/tgui_mmio.h:3.1.2.6
--- xc/programs/Xserver/hw/xfree86/vga256/drivers/tvga8900/tgui_mmio.h:3.1.2.5	Sun Nov  1 01:41:10 1998
+++ xc/programs/Xserver/hw/xfree86/vga256/drivers/tvga8900/tgui_mmio.h	Sat Dec 26 11:12:42 1998
@@ -1,4 +1,4 @@
-/* $XFree86: xc/programs/Xserver/hw/xfree86/vga256/drivers/tvga8900/tgui_mmio.h,v 3.1.2.5 1998/10/31 14:41:10 hohndel Exp $ */
+/* $XFree86: xc/programs/Xserver/hw/xfree86/vga256/drivers/tvga8900/tgui_mmio.h,v 3.1.2.6 1998/12/26 00:12:42 dawes Exp $ */
 /*
  * Copyright 1996 by Alan Hourihane, Wigan, England.
  *
@@ -22,6 +22,8 @@
  *
  * Author:  Alan Hourihane, alanh@fairlite.demon.co.uk
  */
+
+extern volatile unsigned char *tguiMMIOBase;
 
 /* Merge XY */
 #define XY_MERGE(x,y) \
Index: xc/programs/Xserver/hw/xfree86/vga256/drivers/tvga8900/tgui_oldacl.c
diff -u xc/programs/Xserver/hw/xfree86/vga256/drivers/tvga8900/tgui_oldacl.c:3.2.2.2 xc/programs/Xserver/hw/xfree86/vga256/drivers/tvga8900/tgui_oldacl.c:3.2.2.3
--- xc/programs/Xserver/hw/xfree86/vga256/drivers/tvga8900/tgui_oldacl.c:3.2.2.2	Mon May 12 21:06:14 1997
+++ xc/programs/Xserver/hw/xfree86/vga256/drivers/tvga8900/tgui_oldacl.c	Sat Dec 26 11:12:43 1998
@@ -1,4 +1,4 @@
-/* $XFree86: xc/programs/Xserver/hw/xfree86/vga256/drivers/tvga8900/tgui_oldacl.c,v 3.2.2.2 1997/05/12 11:06:14 hohndel Exp $ */
+/* $XFree86: xc/programs/Xserver/hw/xfree86/vga256/drivers/tvga8900/tgui_oldacl.c,v 3.2.2.3 1998/12/26 00:12:43 dawes Exp $ */
 /*
  * Copyright 1997 by Alan Hourihane, Wigan, England.
  *
@@ -33,7 +33,6 @@
 
 #include "xf86xaa.h"
 
-extern unsigned char *tguiMMIOBase;
 extern int TGUIRops_alu[16];
 extern int TGUIRops_Pixalu[16];
 extern int GE_OP;
Index: xc/programs/Xserver/hw/xfree86/vga256/vga/vgaHW.c
diff -u xc/programs/Xserver/hw/xfree86/vga256/vga/vgaHW.c:3.50.2.5 xc/programs/Xserver/hw/xfree86/vga256/vga/vgaHW.c:3.50.2.6
--- xc/programs/Xserver/hw/xfree86/vga256/vga/vgaHW.c:3.50.2.5	Sun Nov  8 21:03:50 1998
+++ xc/programs/Xserver/hw/xfree86/vga256/vga/vgaHW.c	Tue Dec 22 22:23:28 1998
@@ -1,5 +1,5 @@
 /*
- * $XFree86: xc/programs/Xserver/hw/xfree86/vga256/vga/vgaHW.c,v 3.50.2.5 1998/11/08 10:03:50 hohndel Exp $
+ * $XFree86: xc/programs/Xserver/hw/xfree86/vga256/vga/vgaHW.c,v 3.50.2.6 1998/12/22 11:23:28 hohndel Exp $
  *
  * Copyright 1990,91 by Thomas Roell, Dinkelscherben, Germany.
  *
@@ -78,7 +78,7 @@
 #endif
 #endif
 
-#if defined(Lynx) || defined(CSRG_BASED) || defined(MACH386) || defined(linux) || defined(AMOEBA) || defined(MINIX)
+#if defined(Lynx) || defined(CSRG_BASED) || defined(MACH386) || defined(__GNU__)  || defined(linux) || defined(AMOEBA) || defined(MINIX)
 #ifndef NEED_SAVED_CMAP
 #define NEED_SAVED_CMAP
 #endif
@@ -103,11 +103,11 @@
 #define FONT_AMOUNT 8192
 #endif /* !defined(PC98_NEC480) && !defined(PC98_EGC) && !defined(PC98_MGA) */
 
-#if defined(CSRG_BASED) || defined(MACH386)
+#if defined(CSRG_BASED) || defined(MACH386) || defined(__GNU__) 
 #include <sys/time.h>
 #endif
 
-#ifdef MACH386
+#if defined(MACH386)||defined(__GNU__)
 #define WEXITSTATUS(x) (x.w_retcode)
 #define WTERMSIG(x) (x.w_termsig)
 #define WSTOPSIG(x) (x.w_stopsig)
@@ -439,7 +439,7 @@
      int clock2;       /* the Clock index */
 {
     int i;
-#ifdef MACH386
+#if defined(MACH386) || defined(__GNU__)
     union wait exit_status;
 #else
     int exit_status;
@@ -462,7 +462,7 @@
 	for (i = 0; i < MAXSCREENS; i++)
 	  xf86DisableIOPorts(i);
         setuid(getuid());
-#if !defined(AMOEBA) && !defined(MINIX)
+#if !defined(AMOEBA) && !defined(MINIX) && !defined(__GNU__)
         /* set stdin, stdout to the consoleFD, and leave stderr alone */
         for (i = 0; i < 2; i++)
         {
Index: xc/programs/Xserver/hw/xfree86/xaa/xf86bench.c
diff -u xc/programs/Xserver/hw/xfree86/xaa/xf86bench.c:3.5.2.3 xc/programs/Xserver/hw/xfree86/xaa/xf86bench.c:3.5.2.4
--- xc/programs/Xserver/hw/xfree86/xaa/xf86bench.c:3.5.2.3	Sat Jan 24 01:27:06 1998
+++ xc/programs/Xserver/hw/xfree86/xaa/xf86bench.c	Fri Dec 18 22:56:31 1998
@@ -1,4 +1,4 @@
-/* $XFree86: xc/programs/Xserver/hw/xfree86/xaa/xf86bench.c,v 3.5.2.3 1998/01/23 14:27:06 robin Exp $ */
+/* $XFree86: xc/programs/Xserver/hw/xfree86/xaa/xf86bench.c,v 3.5.2.4 1998/12/18 11:56:31 dawes Exp $ */
 
 /*
  * Copyright 1996  The XFree86 Project
@@ -40,6 +40,14 @@
 
 #include "xf86.h"
 #include "xf86xaa.h"
+
+#if defined(DGUX)
+#define _BSD_TIMEOFDAY_FLAVOR
+#include <sys/time.h>
+#define __bsd_tod    1
+#define tz_minuteswest  __hide__tz_minuteswest
+#define tz_dsttime      __hide__tz_dsttime
+#endif
 
 static struct timeval tv;
 static struct timezone tz;
Index: xc/programs/Xserver/hw/xfree86/xf86config/Cards
diff -u xc/programs/Xserver/hw/xfree86/xf86config/Cards:3.51.2.28 xc/programs/Xserver/hw/xfree86/xf86config/Cards:3.51.2.29
--- xc/programs/Xserver/hw/xfree86/xf86config/Cards:3.51.2.28	Tue Nov 10 22:55:42 1998
+++ xc/programs/Xserver/hw/xfree86/xf86config/Cards	Mon Dec 14 01:12:19 1998
@@ -18,7 +18,7 @@
 # The majority of entries are just a binding of a model name to a
 # chipset/server and untested.
 #
-# $XFree86: xc/programs/Xserver/hw/xfree86/xf86config/Cards,v 3.51.2.28 1998/11/10 11:55:42 dawes Exp $
+# $XFree86: xc/programs/Xserver/hw/xfree86/xf86config/Cards,v 3.51.2.29 1998/12/13 14:12:19 dawes Exp $
 
 # VGA
 
@@ -2685,6 +2685,12 @@
 CHIPSET TGA
 SERVER TGA
 RAMDAC Bt463
+
+# Epson
+
+NAME EPSON CardPC (onboard)
+CHIPSET SPC8110
+SERVER SVGA
 
 # Misc
 
Index: xc/programs/Xserver/hw/xfree86/xf86config/xf86config.c
diff -u xc/programs/Xserver/hw/xfree86/xf86config/xf86config.c:3.37.2.9 xc/programs/Xserver/hw/xfree86/xf86config/xf86config.c:3.37.2.10
--- xc/programs/Xserver/hw/xfree86/xf86config/xf86config.c:3.37.2.9	Tue Nov 10 00:36:56 1998
+++ xc/programs/Xserver/hw/xfree86/xf86config/xf86config.c	Sun Dec  6 16:40:41 1998
@@ -1,4 +1,4 @@
-/* $XFree86: xc/programs/Xserver/hw/xfree86/xf86config/xf86config.c,v 3.37.2.9 1998/11/09 13:36:56 dawes Exp $ */
+/* $XFree86: xc/programs/Xserver/hw/xfree86/xf86config/xf86config.c,v 3.37.2.10 1998/12/06 05:40:41 dawes Exp $ */
 
 /*
  * This is a configuration program that will create a base XF86Config
@@ -2395,7 +2395,7 @@
 "Modeline \"800x600\"     40     800  840  968 1056   600  601  605  628 +hsync +vsync\n"
 "\n"
 "# 640x480 @ 85 Hz, 43.27 kHz hsync\n"
-"Modeline \"640x400\"     36     640  696  752  832   480  481  484  509 -HSync -VSync\n"
+"Modeline \"640x480\"     36     640  696  752  832   480  481  484  509 -HSync -VSync\n"
 "# 1152x864 @ 89 Hz interlaced, 44 kHz hsync\n"
 "ModeLine \"1152x864\"    65    1152 1168 1384 1480   864  865  875  985 Interlace\n"
 "\n"
Index: xc/programs/Xserver/hw/xfree98/XF98Conf.cpp
diff -u xc/programs/Xserver/hw/xfree98/XF98Conf.cpp:3.13.2.5 xc/programs/Xserver/hw/xfree98/XF98Conf.cpp:3.13.2.7
--- xc/programs/Xserver/hw/xfree98/XF98Conf.cpp:3.13.2.5	Tue Nov 10 22:55:43 1998
+++ xc/programs/Xserver/hw/xfree98/XF98Conf.cpp	Thu Dec 24 00:36:28 1998
@@ -1,4 +1,4 @@
-XCOMM $XFree86: xc/programs/Xserver/hw/xfree98/XF98Conf.cpp,v 3.13.2.5 1998/11/10 11:55:43 dawes Exp $
+XCOMM $XFree86: xc/programs/Xserver/hw/xfree98/XF98Conf.cpp,v 3.13.2.7 1998/12/23 13:36:28 hohndel Exp $
 XCOMM
 XCOMM Copyright (c) 1994 by The XFree86 Project, Inc.
 XCOMM
@@ -474,6 +474,24 @@
 EndSection
 
 Section "Device"
+    Identifier	"WGNA2"
+    VendorName	"MELCO"
+    BoardName	"WGN-A2"
+    Chipset	"clgd5434"
+    ClockChip   "cirrus"
+    Option      "wap"
+    Option      "med_dram"
+    Option      "no_mmio"
+    Option      "sw_cursor"
+    Option      "fifo_conservative"
+    Option      "fifo_aggressive"
+    Option      "linear"
+    speedup     "all"
+    VideoRam    2048
+XCOMM    VideoRam	4096
+EndSection
+
+Section "Device"
     Identifier  "GA98NB1"
     VendorName  "IO DATA"
     BoardName   "GA-98NBI"
@@ -708,9 +726,8 @@
     Identifier	"GA-968"
     VendorName	"IO DATA"
     BoardName	"GA-968V4/PCI"
-    Chipset	"s3_generic"
+XCOMM Chipset	"s3_generic"
 XCOMM Chipset	"mmio_928"
-XCOMM Option	"ga968"
     VideoRam	4096
 XCOMM    VideoRam	2048
 Endsection
@@ -728,6 +745,7 @@
 XCOMM    Device	"NEC480"
 XCOMM    Device	"WAP"
 XCOMM    Device	"WSNA2F"
+XCOMM    Device	"WGNA2"
 XCOMM    Device	"NKVNEC"
 XCOMM    Device	"GA98NB1"
 XCOMM    Device	"GA98NB2"
Index: xc/programs/Xserver/hw/xfree98/SuperProbe/Imakefile
diff -u xc/programs/Xserver/hw/xfree98/SuperProbe/Imakefile:3.12.2.5 xc/programs/Xserver/hw/xfree98/SuperProbe/Imakefile:3.12.2.8
--- xc/programs/Xserver/hw/xfree98/SuperProbe/Imakefile:3.12.2.5	Mon Oct 19 13:51:20 1998
+++ xc/programs/Xserver/hw/xfree98/SuperProbe/Imakefile	Thu Dec 24 00:36:29 1998
@@ -4,8 +4,8 @@
 
 
 
-XCOMM $XFree86: xc/programs/Xserver/hw/xfree98/SuperProbe/Imakefile,v 3.12.2.5 1998/10/19 03:51:20 hohndel Exp $
-#if defined(SVR3Architecture) || defined(SVR4Architecture) || defined(SCOArchitecture)
+XCOMM $XFree86: xc/programs/Xserver/hw/xfree98/SuperProbe/Imakefile,v 3.12.2.8 1998/12/23 13:36:29 hohndel Exp $
+#if (defined(SVR3Architecture) || defined(SVR4Architecture) || defined(SCOArchitecture)) && !defined(DguxArchitecture)
 # define OSModule OS_SYSV
 #endif
 
@@ -13,6 +13,10 @@
 # include <Server.tmpl>
 #endif
 
+#if defined(DguxArchitecture)
+# define OSModule OS_DGUX
+#endif
+
 #if defined(SVR4Architecture) && defined(SunArchitecture) && !HasGcc
   OS_IO_SRC = SolX86IO.s
   OS_IO_OBJ = SolX86IO.o
@@ -34,9 +38,14 @@
 # define OSModule OS_Minix
 #endif
 #if defined(i386MachArchitecture)
+#if defined(GNUMachArchitecture)
+   SYS_LIBRARIES = 
+# define OSModule OS_GNUmach
+#else
    SYS_LIBRARIES = /usr/lib/libmach.a
 # define OSModule OS_Mach
 #endif
+#endif
 #if defined(OS2Architecture)
 # define OSModule OS_Os2
   CCOPTIONS = -Zmts
@@ -46,7 +55,6 @@
   IOPERMDEFINES = -DUSE_I386_IOPL
   SYS_LIBRARIES = -li386
 #endif
-
 OS_SRC = OSModule.c $(OS_IO_SRC)
 OS_OBJ = OSModule.o $(OS_IO_OBJ)
 BASE_SRC = MDA.c Herc.c CGA.c VGA.c RamDac.c MemProbe.c PCI.c
@@ -122,6 +130,8 @@
 LinkSourceFile(MemProbe.c,$(XF86SRC)/SuperProbe)
 LinkSourceFile(NCR.c,$(XF86SRC)/SuperProbe)
 LinkSourceFile(OS_386BSD.c,$(XF86SRC)/SuperProbe)
+LinkSourceFile(OS_DGUX.c,$(XF86SRC)/SuperProbe)
+LinkSourceFile(OS_GNUmach.c,$(XF86SRC)/SuperProbe)
 LinkSourceFile(OS_Linux.c,$(XF86SRC)/SuperProbe)
 LinkSourceFile(OS_LynxOS.c,$(XF86SRC)/SuperProbe)
 LinkSourceFile(OS_Mach.c,$(XF86SRC)/SuperProbe)
Index: xc/programs/Xserver/hw/xfree98/common/Imakefile
diff -u xc/programs/Xserver/hw/xfree98/common/Imakefile:3.28.2.6 xc/programs/Xserver/hw/xfree98/common/Imakefile:3.28.2.7
--- xc/programs/Xserver/hw/xfree98/common/Imakefile:3.28.2.6	Sun Nov  1 01:41:13 1998
+++ xc/programs/Xserver/hw/xfree98/common/Imakefile	Thu Dec 24 00:36:30 1998
@@ -4,14 +4,18 @@
 
 
 
-XCOMM $XFree86: xc/programs/Xserver/hw/xfree98/common/Imakefile,v 3.28.2.6 1998/10/31 14:41:13 hohndel Exp $
+XCOMM $XFree86: xc/programs/Xserver/hw/xfree98/common/Imakefile,v 3.28.2.7 1998/12/23 13:36:30 hohndel Exp $
 
 
 
 #include <Server.tmpl>
 
 #ifdef i386MachArchitecture
+#ifdef GNUMachArchitecture
+        KBD = xf86Kbd
+#else
         KBD = xf86KbdMach
+#endif /* GNUMachArchitecture */
 #else
 # ifdef i386BsdArchitecture
         KBD = xf86KbdBSD
@@ -92,13 +96,19 @@
 # endif
 #endif
 
+#if !defined(LynxOSArchitecture) && !defined(OS2Architecture)
+ PNP_MOUSE_SRC=xf86_PnPMouse.c
+ PNP_MOUSE_OBJ=xf86_PnPMouse.o
+ PNP_MOUSE_DEFINES=-DPNP_MOUSE
+#endif
+
 #if BuildDynamicLoading
 #  if PexDynamicModule
    PEX_MODULE_DEFINES = -DPEX_MODULE
 #  endif
 #  if XieDynamicModule
    XIE_MODULE_DEFINES = -DXIE_MODULE
-#endif
+#  endif
    XF86DL_SRC = xf86Dl.c
    XF86DL_OBJ = xf86Dl.o
 #if HasDlsymBug
@@ -138,7 +148,28 @@
 	XF86_AGX.c \
 	XF86_W32.c \
 	XF86_I128.c \
-	XF86_TGA.c
+	XF86_TGA.c \
+	XF86_GLINT.c
+
+#if BuildXInputExt
+XINPUT_DEV_SRCS = \
+	$(JOYSTICK_SRC) \
+	$(WACOM_SRC) \
+	$(ELOGRAPHICS_SRC) \
+	$(MICROTOUCH_SRC) \
+	$(SUMMASKETCH_SRC) \
+	$(ACECAD_SRC) \
+	$(DIALBOX_SRC)
+
+XINPUT_DEV_OBJS = \
+	$(JOYSTICK_OBJ) \
+	$(WACOM_OBJ) \
+	$(ELOGRAPHICS_OBJ) \
+	$(MICROTOUCH_OBJ) \
+	$(SUMMASKETCH_OBJ) \
+	$(ACECAD_OBJ) \
+	$(DIALBOX_OBJ)
+#endif
 
 SRCS =	\
 	$(XF86DL_SRC) \
@@ -153,17 +184,11 @@
 	xf86Io.c \
 	xf86Lock.c \
 	xf86_Mouse.c \
-	xf86_PnPMouse.c \
 	xf86_Option.c \
 	$(KBD).c \
+	$(PNP_MOUSE_SRC) \
 	$(XF86_XINPUT_SRC) \
-	$(JOYSTICK_SRC) \
-	$(WACOM_SRC) \
-	$(ELOGRAPHICS_SRC) \
-	$(MICROTOUCH_SRC) \
-	$(SUMMASKETCH_SRC) \
-	$(ACECAD_SRC) \
-	$(DIALBOX_SRC) \
+	$(XINPUT_DEV_SRCS) \
 	$(XKBDDXSRC) \
 	$(BETASRC) \
 	$(SERVERSRCS)
@@ -177,15 +202,9 @@
 	xf86Io.o \
 	xf86Lock.o \
 	xf86_Mouse.o \
-	xf86_PnPMouse.o \
+	$(PNP_MOUSE_OBJ) \
 	$(XF86_XINPUT_OBJ) \
-	$(JOYSTICK_OBJ) \
-	$(WACOM_OBJ) \
-	$(ELOGRAPHICS_OBJ) \
-	$(MICROTOUCH_OBJ) \
-	$(SUMMASKETCH_OBJ) \
-	$(ACECAD_OBJ) \
-	$(DIALBOX_OBJ) \
+	$(XINPUT_DEV_OBJS) \
 	$(XKBDDXOBJ) \
 	$(BETAOBJ) \
 	$(KBD).o
@@ -207,7 +226,7 @@
 CONSDEFINES = XFree86ConsoleDefines
 EXP_DEFINES = -DEXPIRY_TIME=XF86ServerExpiry $(EXP_FORCE_DEFINES)
 
-    DEFINES = $(XCONFIGDEFINES) $(CONSDEFINES) -DPC98
+    DEFINES = $(XCONFIGDEFINES) $(CONSDEFINES) $(PNP_MOUSE_DEFINES) -DPC98
 
 #if XF98EGCServer
 VGA16BUILD = -DBUILD_VGA16
@@ -219,6 +238,7 @@
 
 #if BuildXInputExt
 SpecialObjectRule(xf86Xinput.o,xf86Xinput.c $(ICONFIGFILES),$(XINPUT_DEVICES) $(MODULEDEFINES))
+SpecialObjectRule(xf86Switch.o,xf86Switch.c $(ICONFIGFILES),$(XINPUT_DEVICES) $(MODULEDEFINES))
 # if BuildDynamicLoading
 SpecialObjectRule(xf86Dl.o,xf86Dl.c,$(MODULEDEFINES))
 #  if JoystickSupport
@@ -309,14 +329,15 @@
 LinkFile(xf86MIniExt.c,$(SERVERSRC)/mi/miinitext.c)
 LinkSourceFile(XF86_8514.c,$(XF86SRC)/common)
 LinkSourceFile(XF86_AGX.c,$(XF86SRC)/common)
+LinkSourceFile(XF86_GLINT.c,$(XF86SRC)/common)
+LinkSourceFile(XF86_I128.c,$(XF86SRC)/common)
 LinkSourceFile(XF86_Mono.c,$(XF86SRC)/common)
 LinkSourceFile(XF86_P9000.c,$(XF86SRC)/common)
 LinkSourceFile(XF86_S3.c,$(XF86SRC)/common)
-LinkSourceFile(XF86_TGA.c,$(XF86SRC)/common)
 LinkSourceFile(XF86_SVGA.c,$(XF86SRC)/common)
+LinkSourceFile(XF86_TGA.c,$(XF86SRC)/common)
 LinkSourceFile(XF86_VGA16.c,$(XF86SRC)/common)
 LinkSourceFile(XF86_W32.c,$(XF86SRC)/common)
-LinkSourceFile(XF86_I128.c,$(XF86SRC)/common)
 LinkSourceFile(atKeynames.h,$(XF86SRC)/common)
 LinkSourceFile(cfb16.h,$(XF86SRC)/common)
 LinkSourceFile(cfb24.h,$(XF86SRC)/common)
Index: xc/programs/Xserver/hw/xfree98/doc/Imakefile
diff -u xc/programs/Xserver/hw/xfree98/doc/Imakefile:3.22.2.5 xc/programs/Xserver/hw/xfree98/doc/Imakefile:3.22.2.6
--- xc/programs/Xserver/hw/xfree98/doc/Imakefile:3.22.2.5	Sun Nov 15 13:37:25 1998
+++ xc/programs/Xserver/hw/xfree98/doc/Imakefile	Tue Dec 22 18:50:01 1998
@@ -4,7 +4,7 @@
 
 
 
-XCOMM $XFree86: xc/programs/Xserver/hw/xfree98/doc/Imakefile,v 3.22.2.5 1998/11/15 02:37:25 dawes Exp $
+XCOMM $XFree86: xc/programs/Xserver/hw/xfree98/doc/Imakefile,v 3.22.2.6 1998/12/22 07:50:01 hohndel Exp $
 
 #include <Server.tmpl>
 #include <lnxdoc.rules>
@@ -84,7 +84,7 @@
             README.DECtga  README.apm README.rendition README.epson \
             README.chips README.cirrus README.Video7 README.P9000 README.agx \
             README.S3 README.S3V README.SiS README.W32 README.Oak \
-            README.Mach32 \
+            README.I128 README.Mach32 \
             README.Mach64 README.ark README.MGA README.NVIDIA README.mouse \
             README.neo README.rendition README.3DLabs README.cyrix
 
@@ -124,6 +124,7 @@
 LinkSourceFile(README.Config,$(XF86SRC)/doc)
 LinkSourceFile(README.DECtga,$(XF86SRC)/doc)
 LinkSourceFile(README.DGA,$(XF86SRC)/doc)
+LinkSourceFile(README.I128,$(XF86SRC)/doc)
 LinkSourceFile(README.Linux,$(XF86SRC)/doc)
 LinkSourceFile(README.LynxOS,$(XF86SRC)/doc)
 LinkSourceFile(README.Mach,$(XF86SRC)/doc)
Index: xc/programs/Xserver/hw/xfree98/doc/VideoBoard98
diff -u xc/programs/Xserver/hw/xfree98/doc/VideoBoard98:3.3.4.6 xc/programs/Xserver/hw/xfree98/doc/VideoBoard98:3.3.4.7
--- xc/programs/Xserver/hw/xfree98/doc/VideoBoard98:3.3.4.6	Sat Feb 21 17:07:12 1998
+++ xc/programs/Xserver/hw/xfree98/doc/VideoBoard98	Mon Dec 14 01:12:23 1998
@@ -99,9 +99,6 @@
 |PC9821V233/M7           |MGA1064SG      | B/I   |  B/I   |2|   D   |O|
 |PC9821V233/M7V          |MGA1064SG      | B/I   |  B/I   |4|   D   |O|
 +------------------------+---------------+-------+--------+-+-------+-+
-|PC9821Ce                |CLGD5428       | B/I   |  B/I   |1|  o?   |X|
-|PC9821Ce2               |CLGD5428       | B/I   |  B/I   |1|  o?   |X|
-|PC9821Cs                |CLGD5428       | B/I   |  B/I   |1|  o?   |X|
 |PC9821Cs2               |CLGD5428       | B/I   |  B/I   |1|  o?   |X|
 |PC9821Cf                |CLGD5430       | B/I   |  B/I   |1|  o?   |X|
 |PC9821Cx                |CLGD5430       | B/I   |  B/I   |1|  o?   |X|
@@ -114,9 +111,9 @@
 |PC9821Cu10/D            |CLGD5446       | B/I   |  B/I   |1|  o?   |X|
 |PC9821Cr13              |CLGD5440       | B/I   |  B/I   |1|  o?   |X|
 |PC9821Ct16              |CLGD5446       | B/I   |  B/I   |2|   ?   |X|
-|PC9821Cu13/E,T          |ProVidia9685   | B/I   |  B/I   |2|   ?   |X|
-|PC9821Cu16/H            |ProVidia9685   | B/I   |  B/I   |2|   ?   |X|
-|PC9821Ct20/A            |ProVidia9685   | B/I   |  B/I   |2|   ?   |X|
+|PC9821Cu13/E,T          |ProVidia9685   | B/I   |  B/I   |2|  x?   |X|
+|PC9821Cu16/H            |ProVidia9685   | B/I   |  B/I   |2|  x?   |X|
+|PC9821Ct20/A            |ProVidia9685   | B/I   |  B/I   |2|  x?   |X|
 +------------------------+---------------+-------+--------+-+-------+-+
 |PC9821Ra18/N            |TGUI9682       | B/I   |  B/I   |2|  o?   |O|
 |PC9821Ra20/N            |TGUI9682       | B/I   |  B/I   |2|   o   |O|
@@ -130,12 +127,12 @@
 |PC9821RsII26/B40        |TGUI9682       | B/I   |  B/I   |2|  o?   |O|
 +------------------------+---------------+-------+--------+-+-------+-+
 |PC9821C166/C            |3Dimage975     |       |        |4|   X   | |
-|PC9821C166/D            |ProVidia9685   | B/I   |  B/I   |2|   ?   | |
-|PC9821C200/C,V          |ProVidia9685   | B/I   |  B/I   |2|   ?   | |
+|PC9821C166/D            |ProVidia9685   | B/I   |  B/I   |2|  x?   | |
+|PC9821C200/C,V          |ProVidia9685   | B/I   |  B/I   |2|   X   | |
 |PC9821C233/V            |3Dimage975     |       |        |4|   X   | |
 +------------------------+---------------+-------+--------+-+-------+-+
 |PC9821Es                |CLGD5428       | B/I   |  B/I   |1|  o?   |X|
-|PC9821F200/X20          |ProVidia9685   | B/I   |  B/I   |2|   ?   | |
+|PC9821F200/X20          |ProVidia9685   | B/I   |  B/I   |2|  x?   | |
 +------------------------+---------------+-------+--------+-+-------+-+
 |PC9821Ne2               |CLGD5428       | B/I   |  B/I   |1|   U   | |
 |PC9821Np                |CLGD5428       | B/I   |  B/I   |1|   U   | |
@@ -379,4 +376,4 @@
 |WinFrame928             |S3-928         |       |        |2|   ?   | |
 +------------------------+---------------+-------+--------+-+-------+-+
 
-/* $XFree86: xc/programs/Xserver/hw/xfree98/doc/VideoBoard98,v 3.3.4.6 1998/02/21 06:07:12 robin Exp $ */
+/* $XFree86: xc/programs/Xserver/hw/xfree98/doc/VideoBoard98,v 3.3.4.7 1998/12/13 14:12:23 dawes Exp $ */
Index: xc/programs/Xserver/hw/xfree98/doc/Japanese/README98
diff -u xc/programs/Xserver/hw/xfree98/doc/Japanese/README98:3.6.2.4 xc/programs/Xserver/hw/xfree98/doc/Japanese/README98:3.6.2.6
--- xc/programs/Xserver/hw/xfree98/doc/Japanese/README98:3.6.2.4	Tue Nov 10 22:55:44 1998
+++ xc/programs/Xserver/hw/xfree98/doc/Japanese/README98	Wed Dec 30 20:14:46 1998
@@ -1,6 +1,6 @@
   XFree86 PC98 Dependent Information
   The XFree86 Project Inc. and X98 CORE TEAM 
-  1998  11  10 
+  1998  12  30 
 
   PC98 PC-AT
   
@@ -18,7 +18,7 @@
                                                 
     ------------- ----------------------------------------------- -------------
     MELCO         WAB-S, WAB-1000, WAB-2000, WSR-E, WSR-G         XF98_WABS
-    MELCO         WAP-2000, WAP-4000                              XF98_GANBWAP
+    MELCO         WAP-2000, WAP-4000, WGN-A2, WGN-A4              XF98_GANBWAP
     MELCO         WAB-EP                                          XF98_WABEP
     MELCO         WSN-A2F                                         XF98_WSNA
     IO Data       GA-98NB I/C,GA-98NB II, GA-98NB IV              XF98_GANBWAP
@@ -132,7 +132,8 @@
   3.3.  XF98_GANBWAP
 
   MELCO  WAP2000/4000, IO Data  GA-98NB I/C,II,IV  VGA256
-  ICM GI-5434-2M/4M 
+  ICM GI-5434-2M/4M  MELCO WGN-A2/4 
+  
 
   3.3.1.  XF86Config 
 
@@ -694,8 +695,9 @@
       OFF 
       8bpp 
 
-  o  Linux/98 
-     root  dmesg -n 1 
+  o  Linux/98 beta 14 
+     root  dmesg -n 1 
+     
 
   3.13.3.  
 
@@ -734,4 +736,6 @@
   3.14.4.  
 
   README.cirrusXF86_SVGA man page
+
+  $XFree86: xc/programs/Xserver/hw/xfree98/doc/Japanese/README98,v 3.6.2.6 1998/12/30 09:14:46 hohndel Exp $
 
Index: xc/programs/Xserver/hw/xfree98/doc/Japanese/sgml/read98.sgml
diff -u xc/programs/Xserver/hw/xfree98/doc/Japanese/sgml/read98.sgml:3.6.2.4 xc/programs/Xserver/hw/xfree98/doc/Japanese/sgml/read98.sgml:3.6.2.7
--- xc/programs/Xserver/hw/xfree98/doc/Japanese/sgml/read98.sgml:3.6.2.4	Tue Nov 10 22:55:45 1998
+++ xc/programs/Xserver/hw/xfree98/doc/Japanese/sgml/read98.sgml	Wed Dec 30 20:14:47 1998
@@ -5,7 +5,7 @@
 <!-- Title information -->
 <title> XFree86 PC98 Dependent Information
 <author> The XFree86 Project Inc. and X98 CORE TEAM
-<date> 1998  11  10
+<date> 1998  12 30
 <abstract>
 PC98
 PC-AT
@@ -22,7 +22,7 @@
   						
   ------------- ----------------------------------------------- -------------
   MELCO		WAB-S, WAB-1000, WAB-2000, WSR-E, WSR-G		XF98_WABS
-  MELCO		WAP-2000, WAP-4000				XF98_GANBWAP
+  MELCO		WAP-2000, WAP-4000, WGN-A2, WGN-A4		XF98_GANBWAP
   MELCO		WAB-EP						XF98_WABEP
   MELCO		WSN-A2F						XF98_WSNA
   IO Data	GA-98NB I/C,GA-98NB II, GA-98NB IV		XF98_GANBWAP
@@ -118,7 +118,7 @@
 
 <sect1>XF98_GANBWAP<p>
 	MELCOWAP2000/4000, IO DataGA-98NB I/C,II,IV  VGA256
-	ICM GI-5434-2M/4M
+	ICM GI-5434-2M/4MMELCO WGN-A2/4
 <sect2>XF86Config<p>
 	OptionPC98README.cirrus
 	
@@ -589,8 +589,9 @@
 	<ITEM>Mystique  Windows(3.1/95/NT) 
 	OFF
 	 8bpp 
-	<ITEM>Linux/98 
-	root  dmesg -n 1 
+	<ITEM>Linux/98 beta 14 
+	root  dmesg
+	-n 1 
 </itemize>
 <sect2><p>
 <itemize>
@@ -621,5 +622,8 @@
 	
 </itemize>
 <sect2><p>
-	README.cirrusXF86_SVGA man page</p>
+	README.cirrusXF86_SVGA man page
+<verb>
+$XFree86: xc/programs/Xserver/hw/xfree98/doc/Japanese/sgml/read98.sgml,v 3.6.2.7 1998/12/30 09:14:47 hohndel Exp $
+</verb>
 </article>
Index: xc/programs/Xserver/hw/xfree98/doc/sgml/Imakefile
diff -u xc/programs/Xserver/hw/xfree98/doc/sgml/Imakefile:3.16.2.4 xc/programs/Xserver/hw/xfree98/doc/sgml/Imakefile:3.16.2.5
--- xc/programs/Xserver/hw/xfree98/doc/sgml/Imakefile:3.16.2.4	Sat Nov 14 17:47:21 1998
+++ xc/programs/Xserver/hw/xfree98/doc/sgml/Imakefile	Tue Dec 22 18:50:02 1998
@@ -4,7 +4,7 @@
 
 
 
-XCOMM $XFree86: xc/programs/Xserver/hw/xfree98/doc/sgml/Imakefile,v 3.16.2.4 1998/11/14 06:47:21 dawes Exp $
+XCOMM $XFree86: xc/programs/Xserver/hw/xfree98/doc/sgml/Imakefile,v 3.16.2.5 1998/12/22 07:50:02 hohndel Exp $
 
 #include <Server.tmpl>
 
@@ -67,6 +67,7 @@
 
 /* Hardware docs */
 LinuxDocReadmeTarget(DECtga)
+LinuxDocReadmeTarget(I128)
 LinuxDocReadmeTarget(Mach32)
 LinuxDocReadmeTarget(Mach64)
 LinuxDocReadmeTarget(MGA)
@@ -112,6 +113,7 @@
 LinkSourceFile(DocIndex.sgml,$(XF86SRC)/doc/sgml)
 LinkSourceFile(FreeBSD.sgml,$(XF86SRC)/doc/sgml)
 LinkSourceFile(BUILD.sgml,$(XF86SRC)/doc/sgml)
+LinkSourceFile(I128.sgml,$(XF86SRC)/doc/sgml)
 LinkSourceFile(LinkKit.sgml,$(XF86SRC)/doc/sgml)
 LinkSourceFile(Linux.sgml,$(XF86SRC)/doc/sgml)
 LinkSourceFile(LynxOS.sgml,$(XF86SRC)/doc/sgml)
Index: xc/programs/Xserver/hw/xfree98/os-support/Imakefile
diff -u xc/programs/Xserver/hw/xfree98/os-support/Imakefile:3.7.2.2 xc/programs/Xserver/hw/xfree98/os-support/Imakefile:3.7.2.4
--- xc/programs/Xserver/hw/xfree98/os-support/Imakefile:3.7.2.2	Sat May 17 22:25:24 1997
+++ xc/programs/Xserver/hw/xfree98/os-support/Imakefile	Thu Dec 24 00:36:31 1998
@@ -1,4 +1,4 @@
-XCOMM $XFree86: xc/programs/Xserver/hw/xfree98/os-support/Imakefile,v 3.7.2.2 1997/05/17 12:25:24 dawes Exp $
+XCOMM $XFree86: xc/programs/Xserver/hw/xfree98/os-support/Imakefile,v 3.7.2.4 1998/12/23 13:36:31 hohndel Exp $
 
 
 
@@ -21,6 +21,8 @@
 #if defined(SVR4Architecture) 
 # if defined(SunArchitecture)
 OS_SUBDIR = solx86
+# elif defined(DguxArchitecture)
+OS_SUBDIR = dgux
 # else
 OS_SUBDIR = sysv
 # endif
@@ -43,7 +45,11 @@
 #endif
 
 #if defined(i386MachArchitecture) || defined(OsfArchitecture)
+#if defined(GNUMachArchitecture)
+OS_SUBDIR = hurd
+#else
 OS_SUBDIR = mach
+#endif
 #endif
 
 #if defined(AmoebaArchitecture)
Index: xc/programs/Xserver/hw/xfree98/xf86config/Cards98
diff -u xc/programs/Xserver/hw/xfree98/xf86config/Cards98:1.3.2.3 xc/programs/Xserver/hw/xfree98/xf86config/Cards98:1.3.2.6
--- xc/programs/Xserver/hw/xfree98/xf86config/Cards98:1.3.2.3	Tue Nov 10 22:55:46 1998
+++ xc/programs/Xserver/hw/xfree98/xf86config/Cards98	Thu Dec 24 00:36:31 1998
@@ -1,4 +1,4 @@
-# $XFree86: xc/programs/Xserver/hw/xfree98/xf86config/Cards98,v 1.3.2.3 1998/11/10 11:55:46 dawes Exp $
+# $XFree86: xc/programs/Xserver/hw/xfree98/xf86config/Cards98,v 1.3.2.6 1998/12/23 13:36:31 hohndel Exp $
 #
 #
 #
@@ -6,7 +6,7 @@
 # This is the database of card definitions used by xf86config.
 # Each definition should have a NAME entry, CHIPSET (descriptive) and
 # SERVER (one of EGC, GANBWAP, PEGC, NKVNEC, WABS, WABEP, WSNA, TGUI,
-# MGA, NECS3, PWSKB, PWLB, GA968).
+# MGA, SVGA, NECS3, PWSKB, PWLB, GA968).
 # A reference to another definition is made with SEE (already defined
 # entries are not overridden).
 # Optional entries are RAMDAC (identifier), CLOCKCHIP (identifier),
@@ -47,7 +47,7 @@
 SERVER GANBWAP
 LINE    ClockChip	"cirrus"
 LINE    Option	"ga98nb1"
-LINE    # Option	"mmio"
+LINE    Option	"no_mmio"
 LINE    # Option	"sw_cursor"
 
 NAME GA-98NBII
@@ -55,7 +55,7 @@
 SERVER GANBWAP
 LINE    ClockChip	"cirrus"
 LINE    Option	"ga98nb2"
-LINE    # Option	"mmio"
+LINE    Option	"no_mmio"
 LINE    # Option	"sw_cursor"
 
 NAME GA-98NBIV
@@ -63,15 +63,32 @@
 SERVER GANBWAP
 LINE    ClockChip	"cirrus"
 LINE    Option	"ga98nb4"
-LINE    # Option	"mmio"
+LINE    Option	"no_mmio"
 LINE    # Option	"sw_cursor"
 
 NAME WAP-2000/4000
 CHIPSET CL-GD5434
 SERVER GANBWAP
 LINE    Option	"wap"
+LINE    Option	"no_mmio"
 LINE    # Option	"epsonmemwin"
 
+NAME WGN-A2/4
+CHIPSET CL-GD5434
+SERVER GANBWAP
+LINE    Chipset	"clgd5434"
+LINE    ClockChip	"cirrus"
+LINE    Option	"wap"
+LINE    Option	"med_dram"
+LINE    Option	"no_mmio"
+LINE    Option	"sw_cursor"
+LINE    Option	"fifo_conservative"
+LINE    Option	"fifo_aggressive"
+LINE    Option	"linear"
+LINE    speedup	"all"
+LINE    VideoRam	2048
+LINE    # VideoRam	4096
+
 # NKVNEC
 
 NAME PCNKV/PCNKV2/NEC_CIRRUS
@@ -106,26 +123,17 @@
 
 NAME PC9821BX4/U2
 LINE    Option	"nec_cirrus"
+LINE    Option	"no_mmio"
 SEE PCNKV/PCNKV2/NEC_CIRRUS
 
 NAME PC9821Cb
 LINE    Option	"nec_cirrus"
-SEE PCNKV/PCNKV2/NEC_CIRRUS
-
-NAME PC9821Ce
-LINE    Option	"nec_cirrus"
+LINE    Option	"no_mmio"
 SEE PCNKV/PCNKV2/NEC_CIRRUS
 
 NAME PC9821Cf
 LINE    Option	"nec_cirrus"
-SEE PCNKV/PCNKV2/NEC_CIRRUS
-
-NAME PC9821Ce2
-LINE    Option	"nec_cirrus"
-SEE PCNKV/PCNKV2/NEC_CIRRUS
-
-NAME PC9821Cs
-LINE    Option	"nec_cirrus"
+LINE    Option	"no_mmio"
 SEE PCNKV/PCNKV2/NEC_CIRRUS
 
 NAME PC9821Cs2
@@ -134,10 +142,16 @@
 
 NAME PC9821Cx
 LINE    Option	"nec_cirrus"
+LINE    Option	"no_mmio"
 SEE PCNKV/PCNKV2/NEC_CIRRUS
 
 NAME PC9821Cx2
 LINE    Option	"nec_cirrus"
+LINE    Option	"no_mmio"
+SEE PCNKV/PCNKV2/NEC_CIRRUS
+
+NAME PC9821Es
+LINE    Option	"nec_cirrus"
 SEE PCNKV/PCNKV2/NEC_CIRRUS
 
 NAME PC9821Nd
@@ -160,6 +174,90 @@
 LINE    Option	"nec_cirrus"
 SEE PCNKV/PCNKV2/NEC_CIRRUS
 
+NAME PC9821V7/C
+LINE    Chipset "clgd5430"
+LINE    Option	"nec_cirrus"
+LINE    Option	"no_mmio"
+SEE PCNKV/PCNKV2/NEC_CIRRUS
+
+NAME PC9821V10/C,S
+LINE    Chipset "clgd5430"
+LINE    Option	"nec_cirrus"
+LINE    Option	"no_mmio"
+SEE PCNKV/PCNKV2/NEC_CIRRUS
+
+NAME PC9821V12/S
+LINE    Chipset "clgd5430"
+LINE    Option	"nec_cirrus"
+LINE    Option	"no_mmio"
+SEE PCNKV/PCNKV2/NEC_CIRRUS
+
+NAME PC9821V13/S
+LINE    Chipset "clgd5430"
+LINE    Option	"nec_cirrus"
+LINE    Option	"no_mmio"
+SEE PCNKV/PCNKV2/NEC_CIRRUS
+
+NAME PC9821V16/S
+LINE    Chipset "clgd5430"
+LINE    Option	"nec_cirrus"
+LINE    Option	"no_mmio"
+SEE PCNKV/PCNKV2/NEC_CIRRUS
+
+NAME PC9821V16/S5V,P
+LINE    Chipset "clgd5446"
+LINE    Option	"nec_cirrus"
+LINE    Option	"no_mmio"
+SEE PCNKV/PCNKV2/NEC_CIRRUS
+
+NAME PC9821V20/S7
+LINE    Chipset "clgd5430"
+LINE    Option	"nec_cirrus"
+LINE    Option	"no_mmio"
+SEE PCNKV/PCNKV2/NEC_CIRRUS
+
+NAME PC9821Xb10
+LINE    Chipset "clgd5430"
+LINE    Option	"nec_cirrus"
+LINE    Option	"no_mmio"
+SEE PCNKV/PCNKV2/NEC_CIRRUS
+
+NAME PC9821Xc13/S5
+LINE    Chipset "clgd5446"
+LINE    Option	"nec_cirrus"
+LINE    Option	"no_mmio"
+SEE PCNKV/PCNKV2/NEC_CIRRUS
+
+NAME PC9821Xc16/M,S
+LINE    Chipset "clgd5446"
+LINE    Option	"nec_cirrus"
+LINE    Option	"no_mmio"
+SEE PCNKV/PCNKV2/NEC_CIRRUS
+
+NAME PC9821Xc200/M,S
+LINE    Chipset "clgd5446"
+LINE    Option	"nec_cirrus"
+LINE    Option	"no_mmio"
+SEE PCNKV/PCNKV2/NEC_CIRRUS
+
+NAME PC9821Xa7e
+LINE    Chipset "clgd5430"
+LINE    Option	"nec_cirrus"
+LINE    Option	"no_mmio"
+SEE PCNKV/PCNKV2/NEC_CIRRUS
+
+NAME PC9821Xe
+LINE    Chipset "clgd5430"
+LINE    Option	"nec_cirrus"
+LINE    Option	"no_mmio"
+SEE PCNKV/PCNKV2/NEC_CIRRUS
+
+NAME PC9821Xe10
+LINE    Chipset "clgd5430"
+LINE    Option	"nec_cirrus"
+LINE    Option	"no_mmio"
+SEE PCNKV/PCNKV2/NEC_CIRRUS
+
 NAME PC486MR
 SEE PCNKV/PCNKV2/NEC_CIRRUS
 
@@ -167,6 +265,7 @@
 SEE PCNKV/PCNKV2/NEC_CIRRUS
 
 NAME PC486MU
+LINE    Chipset "clgd5429"
 SEE PCNKV/PCNKV2/NEC_CIRRUS
 
 NAME PC486MV
@@ -176,6 +275,7 @@
 SEE PCNKV/PCNKV2/NEC_CIRRUS
 
 NAME PC586RV
+LINE    Chipset "clgd5429"
 SEE PCNKV/PCNKV2/NEC_CIRRUS
 
 # WABS
@@ -207,6 +307,7 @@
 NAME WSN-A2F
 CHIPSET CL-GD5434
 SERVER WSNA
+LINE    Option	"no_mmio"
 LINE    Option	"med_dram"
 
 # TGUI
@@ -318,14 +419,55 @@
 SERVER MGA
 
 NAME PC9821V166/S
+LINE    VideoRam	2048
 SEE MGA Mystique
 
-NAME PC9821V200/M,S
+NAME PC9821V200/S
+LINE    VideoRam	2048
+SEE MGA Mystique
+
+NAME PC9821V200/M
+LINE    VideoRam	4096
+SEE MGA Mystique
+
+NAME PC9821V233/M7
+LINE    VideoRam	2048
 SEE MGA Mystique
 
-NAME PC9821V233/M7,M7V
+NAME PC9821V233/M7V
+LINE    VideoRam	4096
 SEE MGA Mystique
 
+# SVGA
+
+NAME NEC Cirrus 755x
+CHIPSET CL-GD7555
+LINE    Chipset "clgd7555"
+LINE    # VideoRam	2048
+LINE    # Option	"no_bitblt"
+LINE    # Option	"fast_dram"
+LINE    Option	"linear"
+LINE    Option	"noaccel"
+SERVER SVGA
+
+NAME PC9821Nr12
+SEE NEC Cirrus 755x
+
+NAME PC9821Nr13
+SEE NEC Cirrus 755x
+
+NAME PC9821La13
+SEE NEC Cirrus 755x
+
+NAME PC9821Ls12
+SEE NEC Cirrus 755x
+
+NAME PC9821Ls13
+SEE NEC Cirrus 755x
+
+NAME PC9821Ls150
+SEE NEC Cirrus 755x
+
 # NECS3
 
 NAME NEC WAB-A/B
@@ -509,7 +651,7 @@
 NAME GA-968V4/PCI
 CHIPSET S3 968
 SERVER GA968
-LINE    Chipset	"s3_generic"
+LINE    # Chipset	"s3_generic"
 LINE    # Chipset	"mmio_928"
 LINE    VideoRam	4096
 LINE    # VideoRam	2048
Index: xc/programs/Xserver/include/servermd.h
diff -u xc/programs/Xserver/include/servermd.h:3.19.2.4 xc/programs/Xserver/include/servermd.h:3.19.2.5
--- xc/programs/Xserver/include/servermd.h:3.19.2.4	Mon Oct 19 06:42:48 1998
+++ xc/programs/Xserver/include/servermd.h	Tue Dec 22 22:23:29 1998
@@ -48,7 +48,7 @@
 #ifndef SERVERMD_H
 #define SERVERMD_H 1
 /* $XConsortium: servermd.h /main/58 1996/12/02 10:22:09 lehors $ */
-/* $XFree86: xc/programs/Xserver/include/servermd.h,v 3.19.2.4 1998/10/18 20:42:48 hohndel Exp $ */
+/* $XFree86: xc/programs/Xserver/include/servermd.h,v 3.19.2.5 1998/12/22 11:23:29 hohndel Exp $ */
 
 /*
  * Machine dependent values:
@@ -336,7 +336,7 @@
 
 #endif /* luna */
 
-#if (defined(i386) && (defined(SVR4) || defined(SYSV) || (defined(sun) && defined(SVR4))) || defined(__bsdi__) || (defined(__NetBSD__) && defined(__i386__)) || (defined(__OpenBSD__) && defined(__i386__)) || defined(__FreeBSD__) || defined(MACH386) || (defined(linux) && !defined(__mc68000__) && !defined(__powerpc__)) || (defined(AMOEBA) && defined(i80386)) || defined(MINIX) || defined(__EMX__) || (defined(Lynx) && defined(__i386__)))
+#if (defined(i386) && (defined(SVR4) || defined(SYSV) || (defined(sun) && defined(SVR4))) || defined(__bsdi__) || (defined(__NetBSD__) && defined(__i386__)) || (defined(__OpenBSD__) && defined(__i386__)) || defined(__FreeBSD__) || defined(MACH386) || (defined(linux) && !defined(__mc68000__) && !defined(__powerpc__)) || (defined(AMOEBA) && defined(i80386)) || defined(MINIX) || defined(__EMX__) || (defined(Lynx) && defined(__i386__)) || (defined(__GNU__) && defined(__i386__)))
 
 #ifndef IMAGE_BYTE_ORDER
 #define IMAGE_BYTE_ORDER	LSBFirst
Index: xc/programs/Xserver/os/access.c
diff -u xc/programs/Xserver/os/access.c:3.18.2.4 xc/programs/Xserver/os/access.c:3.18.2.6
--- xc/programs/Xserver/os/access.c:3.18.2.4	Sat Feb 21 17:07:16 1998
+++ xc/programs/Xserver/os/access.c	Tue Dec 22 22:23:30 1998
@@ -1,5 +1,5 @@
 /* $XConsortium: access.c /main/68 1996/12/15 22:57:09 rws $ */
-/* $XFree86: xc/programs/Xserver/os/access.c,v 3.18.2.4 1998/02/21 06:07:16 robin Exp $ */
+/* $XFree86: xc/programs/Xserver/os/access.c,v 3.18.2.6 1998/12/22 11:23:30 hohndel Exp $ */
 /***********************************************************
 
 Copyright (c) 1987  X Consortium
@@ -102,6 +102,23 @@
 #include <netdnet/dnetdb.h>
 #endif
 
+
+#if defined(DGUX)
+#include <sys/ioctl.h>
+#include <sys/socket.h>
+#include <sys/_int_if_ioctl.h>
+#include <net/if.h>
+#include <netinet/in.h>
+#include <ctype.h>
+#include <sys/utsname.h>
+#include <sys/stream.h>
+#include <sys/_int_streams_ioctl.h>
+#include <sys/stropts.h>
+#include <sys/param.h>
+#include <sys/sockio.h>
+#endif
+
+
 #if !defined(AMOEBA)
 #ifdef hpux
 # include <sys/utsname.h>
@@ -109,7 +126,7 @@
 #  include <net/if.h>
 # endif
 #else
-#if defined(SVR4) ||  (defined(SYSV) && defined(i386)) || defined(MINIX)
+#if defined(SVR4) ||  (defined(SYSV) && defined(i386)) || defined(MINIX) || defined(__GNU__)
 # include <sys/utsname.h>
 #endif
 #if defined(SYSV) &&  defined(i386)
@@ -122,9 +139,14 @@
 #ifdef ESIX
 # include <lan/if.h>
 #else
+#ifdef __GNU__
+#undef SIOCGIFCONF
+#include <netdb.h>
+#else /*!__GNU__*/
 #ifndef MINIX
 # include <net/if.h>
 #endif
+#endif /*__GNU__ */
 #endif
 #endif /* hpux */
 #endif /* !AMOEBA */
@@ -280,7 +302,7 @@
 }
 
 
-#if ((defined(SVR4) && !defined(SCO325) && !defined(sun) && !defined(NCR)) || defined(ISC)) && defined(SIOCGIFCONF)
+#if ((defined(SVR4) && !defined(DGUX) && !defined(SCO325) && !defined(sun) && !defined(NCR)) || defined(ISC)) && defined(SIOCGIFCONF)
 
 /* Deal with different SIOCGIFCONF ioctl semantics on these OSs */
 
@@ -332,9 +354,9 @@
 #endif
     return(ret);
 }
-#else /* ((SVR4 && !sun) || ISC) && SIOCGIFCONF */
+#else /* Case DGUX, sun, SCO325 NCR and others  */
 #define ifioctl ioctl
-#endif /* ((SVR4 && !sun) || ISC) && SIOCGIFCONF */
+#endif /* ((SVR4 && !DGUX !sun !SCO325 !NCR) || ISC) && SIOCGIFCONF */
 
 /*
  * DefineSelf (fd):
@@ -350,7 +372,17 @@
 #include <tiuser.h>
 
 #include <sys/stream.h>
+
+#if defined(DGUX)
+#include <sys/_int_streams_ioctl.h>
+#endif
+
 #include <net/if.h>
+
+#if defined(DGUX)
+#include <sys/_int_if_ioctl.h>
+#endif
+
 #include <netinet/ip.h>
 #include <netinet/ip_var.h>
 #include <netinet/in.h>
Index: xc/programs/Xserver/os/auth.c
diff -u xc/programs/Xserver/os/auth.c:1.1.1.2 xc/programs/Xserver/os/auth.c:1.1.1.2.2.3
--- xc/programs/Xserver/os/auth.c:1.1.1.2	Sun Dec 22 14:33:21 1996
+++ xc/programs/Xserver/os/auth.c	Sun Dec 27 13:01:20 1998
@@ -28,6 +28,7 @@
 from the X Consortium.
 
 */
+/* $XFree86: xc/programs/Xserver/os/auth.c,v 1.1.1.2.2.3 1998/12/27 02:01:20 dawes Exp $ */
 
 /*
  * authorization hooks for the server
@@ -169,11 +170,23 @@
     Xauth   *auth;
     int	    i;
     int	    count = 0;
+#if !defined(WIN32) && !defined(__EMX__)
+    char    *buf;
+#endif
 
     ShouldLoadAuth = FALSE;
     if (!authorization_file)
 	return 0;
+#if !defined(WIN32) && !defined(__EMX__)
+    buf = (char *)xalloc (strlen(authorization_file) + 5);
+    if (!buf)
+	return 0;
+    sprintf (buf, "cat %s", authorization_file);
+    f = Popen (buf, "r");
+    xfree (buf);
+#else
     f = fopen (authorization_file, "r");
+#endif
     if (!f)
 	return 0;
     while (auth = XauReadAuth (f)) {
@@ -189,7 +202,11 @@
 	}
 	XauDisposeAuth (auth);
     }
+#if !defined(WIN32) && !defined(__EMX__)
+    Pclose (f);
+#else
     fclose (f);
+#endif
     return count;
 }
 
Index: xc/programs/Xserver/os/connection.c
diff -u xc/programs/Xserver/os/connection.c:3.25.2.5 xc/programs/Xserver/os/connection.c:3.25.2.6
--- xc/programs/Xserver/os/connection.c:3.25.2.5	Fri Nov  6 01:03:10 1998
+++ xc/programs/Xserver/os/connection.c	Fri Dec 18 22:56:32 1998
@@ -46,7 +46,7 @@
 SOFTWARE.
 
 ******************************************************************/
-/* $XFree86: xc/programs/Xserver/os/connection.c,v 3.25.2.5 1998/11/05 14:03:10 dawes Exp $ */
+/* $XFree86: xc/programs/Xserver/os/connection.c,v 3.25.2.6 1998/12/18 11:56:32 dawes Exp $ */
 /*****************************************************************
  *  Stuff to create connections --- OS dependent
  *
@@ -91,6 +91,18 @@
 #include <sys/utsname.h>
 #include <sys/ioctl.h>
 #endif
+
+#if defined(DGUX)
+#include <sys/ioctl.h>
+#include <sys/utsname.h>
+#include <sys/socket.h>
+#include <sys/uio.h>
+#include <netinet/in.h>
+#include <netinet/tcp.h>
+#include <sys/param.h>
+#include <unistd.h>
+#endif
+
 
 #ifdef AIXV3
 #include <sys/ioctl.h>
Index: xc/programs/Xserver/os/rpcauth.c
diff -u xc/programs/Xserver/os/rpcauth.c:3.0 xc/programs/Xserver/os/rpcauth.c:3.0.6.1
--- xc/programs/Xserver/os/rpcauth.c:3.0	Sat Jul  8 01:46:07 1995
+++ xc/programs/Xserver/os/rpcauth.c	Fri Dec 18 22:56:33 1998
@@ -1,5 +1,5 @@
 /* $XConsortium: rpcauth.c,v 1.9 94/04/17 20:27:06 gildea Exp $ */
-/* $XFree86: xc/programs/Xserver/os/rpcauth.c,v 3.0 1995/07/07 15:46:07 dawes Exp $ */
+/* $XFree86: xc/programs/Xserver/os/rpcauth.c,v 3.0.6.1 1998/12/18 11:56:33 dawes Exp $ */
 /*
 
 Copyright (c) 1991  X Consortium
@@ -45,6 +45,11 @@
 #include "dixstruct.h"
 
 #include <rpc/rpc.h>
+
+#if defined(DGUX)
+#include <time.h>
+#include <rpc/auth_des.h>
+#endif /* DGUX */
 
 #ifdef ultrix
 #include <time.h>
Index: xc/programs/Xserver/os/utils.c
diff -u xc/programs/Xserver/os/utils.c:3.27.2.9 xc/programs/Xserver/os/utils.c:3.27.2.11
--- xc/programs/Xserver/os/utils.c:3.27.2.9	Tue Nov 10 22:55:46 1998
+++ xc/programs/Xserver/os/utils.c	Sun Dec 27 13:01:20 1998
@@ -51,7 +51,7 @@
 OR PERFORMANCE OF THIS SOFTWARE.
 
 */
-/* $XFree86: xc/programs/Xserver/os/utils.c,v 3.27.2.9 1998/11/10 11:55:46 dawes Exp $ */
+/* $XFree86: xc/programs/Xserver/os/utils.c,v 3.27.2.11 1998/12/27 02:01:20 dawes Exp $ */
 
 #ifdef WIN32
 #include <X11/Xwinsock.h>
@@ -85,6 +85,12 @@
 #include <stdarg.h>
 #endif
 
+#if defined(DGUX)
+#include <sys/resource.h>
+#include <netdb.h>
+#include <unistd.h>
+#endif
+
 #ifdef AMOEBA
 #include "osdep.h"
 #include <amoeba.h>
@@ -214,6 +220,11 @@
 #define LOCK_SUFFIX ".lck"
 #endif
 
+#if defined(DGUX)
+#include <limits.h>
+#include <sys/param.h>
+#endif
+
 #ifdef _MINIX
 #include <limits.h>	/* For PATH_MAX */
 #endif
@@ -1403,6 +1414,7 @@
     char *f;
     va_list args;
 {
+#if !defined(DGUX)
 #ifdef AIXV3
     vfprintf(aixfd, f, args);
     fflush (aixfd);
@@ -1411,6 +1423,19 @@
 #else
     vfprintf(stderr, f, args);
 #endif /* AIXV3 */
+#else /* DGUX */
+    /* writing to the console while the server is running is bad with DG/ux */
+    static Bool firstTime = TRUE;
+    static Bool suppress = FALSE;
+
+    if (firstTime) {
+	firstTime = FALSE;
+	if (isatty(fileno(stderr)))
+	    suppress = TRUE;
+    }
+    if (!suppress)
+	vfprintf(stderr, f, args);
+#endif /* DGUX */
 }
 #endif
 
@@ -1431,6 +1456,7 @@
     VErrorF(f, args);
     va_end(args);
 #else
+#if !defined(DGUX)
 #ifdef AIXV3
     fprintf(aixfd, f, s0, s1, s2, s3, s4, s5, s6, s7, s8, s9);
     fflush (aixfd);
@@ -1445,6 +1471,19 @@
     mu_unlock(&print_lock);
 #endif
 #endif /* AIXV3 */
+#else /* DGUX */
+    /* writing to the console while the server is running is bad with DG/ux */
+    static Bool firstTime = TRUE;
+    static Bool suppress = FALSE;
+
+    if (firstTime) {
+	firstTime = FALSE;
+	if (isatty(fileno(stderr)))
+	    suppress = TRUE;
+    }
+    if (!suppress)
+	fprintf(stderr, f, s0, s1, s2, s3, s4, s5, s6, s7, s8, s9);
+#endif /* DGUX */
 #endif
 }
 
Index: xc/programs/Xserver/os/xalloc.c
diff -u xc/programs/Xserver/os/xalloc.c:3.12.2.2 xc/programs/Xserver/os/xalloc.c:3.12.2.3
--- xc/programs/Xserver/os/xalloc.c:3.12.2.2	Tue Apr  7 21:32:12 1998
+++ xc/programs/Xserver/os/xalloc.c	Fri Dec 18 22:56:34 1998
@@ -25,7 +25,7 @@
 Pascal Haible.
 */
 
-/* $XFree86: xc/programs/Xserver/os/xalloc.c,v 3.12.2.2 1998/04/07 11:32:12 dawes Exp $ */
+/* $XFree86: xc/programs/Xserver/os/xalloc.c,v 3.12.2.3 1998/12/18 11:56:34 dawes Exp $ */
 
 /* Only used if INTERNAL_MALLOC is defined
  * - otherwise xalloc() in utils.c is used
@@ -251,12 +251,21 @@
 #include <sys/mman.h>
 #endif /* CSRG_BASED */
 
-#if defined(SVR4)
+#if defined(DGUX)
+#define HAS_GETPAGESIZE
+#define MMAP_DEV_ZERO
+#include <sys/types.h>
+#include <sys/mman.h>
+#include <unistd.h>
+#include <sys/_int_unistd.h>
+#endif /* DGUX */
+
+#if defined(SVR4) && !defined(DGUX)
 #define MMAP_DEV_ZERO
 #include <sys/types.h>
 #include <sys/mman.h>
 #include <unistd.h>
-#endif /* SVR4 */
+#endif /* SVR4 && !DGUX */
 
 #if defined(sun) && !defined(SVR4) /* SunOS */
 #define MMAP_DEV_ZERO	/* doesn't SunOS have MAP_ANON ?? */
Index: xc/programs/Xserver/os/xdmcp.c
diff -u xc/programs/Xserver/os/xdmcp.c:3.9 xc/programs/Xserver/os/xdmcp.c:3.9.2.1
--- xc/programs/Xserver/os/xdmcp.c:3.9	Sat Jan 18 17:58:04 1997
+++ xc/programs/Xserver/os/xdmcp.c	Fri Dec 18 22:56:34 1998
@@ -1,5 +1,5 @@
 /* $XConsortium: xdmcp.c /main/34 1996/12/02 10:23:29 lehors $ */
-/* $XFree86: xc/programs/Xserver/os/xdmcp.c,v 3.9 1997/01/18 06:58:04 dawes Exp $ */
+/* $XFree86: xc/programs/Xserver/os/xdmcp.c,v 3.9.2.1 1998/12/18 11:56:34 dawes Exp $ */
 /*
  * Copyright 1989 Network Computing Devices, Inc., Mountain View, California.
  *
@@ -58,6 +58,11 @@
 #include "input.h"
 #include "dixstruct.h"
 #include "opaque.h"
+
+#if defined(DGUX)
+#include <net/net_ioctl.h>
+#include <sys/ioctl.h>
+#endif
 
 #ifdef STREAMSCONN
 #include <tiuser.h>
Index: xc/programs/xauth/process.c
diff -u xc/programs/xauth/process.c:3.2 xc/programs/xauth/process.c:3.2.2.1
--- xc/programs/xauth/process.c:3.2	Mon Dec 23 18:10:52 1996
+++ xc/programs/xauth/process.c	Sun Dec  6 16:40:43 1998
@@ -1,5 +1,5 @@
 /* $XConsortium: process.c /main/51 1996/10/07 15:37:05 dpw $ */
-/* $XFree86: xc/programs/xauth/process.c,v 3.2 1996/12/23 07:10:52 dawes Exp $ */
+/* $XFree86: xc/programs/xauth/process.c,v 3.2.2.1 1998/12/06 05:40:43 dawes Exp $ */
 /*
 
 Copyright (c) 1989  X Consortium
@@ -606,6 +606,7 @@
 static Bool xauth_existed = False;	/* if was present at initialize */
 static Bool xauth_modified = False;	/* if added, removed, or merged */
 static Bool xauth_allowed = True;	/* if allowed to write auth file */
+static Bool xauth_locked = False;     /* if has been locked */
 static char *xauth_filename = NULL;
 static Bool dieing = False;
 
@@ -615,6 +616,9 @@
 #define _signal_t void
 #endif
 
+/* poor man's puts(), for under signal handlers */
+#define WRITES(fd, S) (void)write((fd), (S), strlen((S)))
+
 /* ARGSUSED */
 static _signal_t die (sig)
     int sig;
@@ -633,7 +637,7 @@
 #ifdef SYSV
     if (sig > 0) signal (sig, die);	/* re-establish signal handler */
 #endif
-    if (verbose && xauth_modified) printf ("\r\n");
+    if (verbose && xauth_modified) WRITES(fileno(stdout), "\r\n");
     die (sig);
     /* NOTREACHED */
 #ifdef SIGNALRETURNSINT
@@ -664,6 +668,8 @@
     FILE *authfp;
     Bool exists;
 
+    xauth_filename = authfilename;    /* used in cleanup, prevent race with 
+                                         signals */
     register_signals ();
 
     bzero ((char *) hexvalues, sizeof hexvalues);
@@ -708,7 +714,8 @@
 	    fprintf (stderr, "%s:  %s in locking authority file %s\n",
 		     ProgramName, reason, authfilename);
 	    return -1;
-	}
+	} else
+	    xauth_locked = True;
     }
 
     /* these checks can only be done reliably after the file is locked */
@@ -808,8 +815,10 @@
     if (xauth_modified) {
 	if (dieing) {
 	    if (verbose) {
-		printf ("Aborting changes to authority file %s\n",
-			xauth_filename);
+		/* called from a signal handler -- printf is *not* reentrant */
+		WRITES(fileno(stdout), "\nAborting changes to authority file ");
+		WRITES(fileno(stdout), xauth_filename);
+		WRITES(fileno(stdout), "\n");
 	    }
 	} else if (!xauth_allowed) {
 	    fprintf (stderr, 
@@ -844,7 +853,7 @@
 	}
     }
 
-    if (!ignore_locks) {
+    if (xauth_locked) {
 	XauUnlockAuth (xauth_filename);
     }
     (void) umask (original_umask);
@@ -1572,7 +1581,7 @@
     printf ("Authority file:       %s\n",
 	    xauth_filename ? xauth_filename : "(none)");
     printf ("File new:             %s\n", xauth_existed ? No : Yes);
-    printf ("File locked:          %s\n", ignore_locks ? No : Yes);
+    printf ("File locked:          %s\n", xauth_locked ? No : Yes);
     printf ("Number of entries:    %d\n", n);
     printf ("Changes honored:      %s\n", xauth_allowed ? Yes : No);
     printf ("Changes made:         %s\n", xauth_modified ? Yes : No);
Index: xc/programs/xconsole/xconsole.c
diff -u xc/programs/xconsole/xconsole.c:3.16.2.2 xc/programs/xconsole/xconsole.c:3.16.2.3
--- xc/programs/xconsole/xconsole.c:3.16.2.2	Tue May 27 00:36:27 1997
+++ xc/programs/xconsole/xconsole.c	Fri Dec 18 22:56:36 1998
@@ -1,6 +1,6 @@
 /*
  * $XConsortium: xconsole.c /main/22 1995/12/07 13:52:50 kaleb $
- * $XFree86: xc/programs/xconsole/xconsole.c,v 3.16.2.2 1997/05/26 14:36:27 dawes Exp $
+ * $XFree86: xc/programs/xconsole/xconsole.c,v 3.16.2.3 1998/12/18 11:56:36 dawes Exp $
  *
 Copyright (c) 1990  X Consortium
 
@@ -157,6 +157,13 @@
 #endif
 #endif
 
+#if defined(DGUX)
+#include <sys/stropts.h>             /* for I_PUSH */
+#include <sys/_int_pty_ioctl.h>
+#include <sys/stream.h>
+#include <sys/ptem.h>
+#endif /* DGUX */
+
 #if defined(TIOCCONS) || defined(SRIOCSREDIR) || defined(Lynx)
 #define USE_PTY
 static int  tty_fd, pty_fd;
@@ -164,12 +171,14 @@
 #endif
 #endif
 
+#if !defined(DGUX) /* No /dev/osm in DG/ux */
 #if (defined(SVR4) && !defined(sun)) || (defined(SYSV) && defined(i386))
 #define USE_OSM
 #include <signal.h>
 FILE *osm_pipe();
 static int child_pid;
 #endif
+#endif /* !DGUX */
 
 static void inputReady ();
 
@@ -754,6 +763,67 @@
 
 #include    "../xterm/ptyx.h"
 
+#if defined(DGUX)
+
+get_pty (pty, tty, ttydev, ptydev)
+    int     *pty, *tty;
+    char    *ttydev, *ptydev;
+{
+        int ptyffd;
+
+        if ((*pty = open ("/dev/ptmx", O_RDWR)) < 0)
+        {
+            printf("Couldnt open /dev/ptmx in get_pty(..)\n");
+            return 1;
+        }
+        strcpy(ttydev, (char *)ptsname(*pty));
+        setpgrp();
+        grantpt (*pty);
+        unlockpt (*pty);
+        if ((ptyffd = open (ttydev, O_RDWR)) < 0)
+        {
+            printf("Trying to obtain fildes for ttydev failed!\n");
+            if (*pty >= 0)
+            {
+               close (*pty);
+            }
+            return 1;
+        }
+        if (ioctl (ptyffd, I_PUSH, "ptem") < 0)
+        {
+            printf("Couldnt I_PUSH module ptem\n");
+            if (*pty >= 0)
+            {
+               close (*pty);
+            }
+            return 1;
+        }
+        if (ioctl (ptyffd, I_PUSH, "ldterm") < 0)
+        {
+            printf("Couldnt I_PUSH ldterm \n");
+            if (*pty >= 0)
+            {
+               close (*pty);
+            }
+            return 1;
+        }
+        if (ioctl (ptyffd, I_PUSH, "ttcompat") < 0)
+        {
+            printf("Couldnt I_PUSH ttcompat\n");
+        }
+
+        *tty = ptyffd;
+        return 0;
+
+
+}
+
+
+#else /* Other than DGUX */
+
+
+
+
 get_pty (pty, tty, ttydev, ptydev)
     int	    *pty, *tty;
     char    *ttydev, *ptydev;
@@ -858,6 +928,7 @@
 	return(1);
 }
 #endif
+#endif /* DGUX */
 
 #ifdef USE_OSM
 /*
Index: xc/programs/xdm/auth.c
diff -u xc/programs/xdm/auth.c:3.16 xc/programs/xdm/auth.c:3.16.2.1
--- xc/programs/xdm/auth.c:3.16	Sat Jan 18 18:02:18 1997
+++ xc/programs/xdm/auth.c	Tue Dec 22 22:23:31 1998
@@ -1,4 +1,4 @@
-/* $XFree86: xc/programs/xdm/auth.c,v 3.16 1997/01/18 07:02:18 dawes Exp $ */
+/* $XFree86: xc/programs/xdm/auth.c,v 3.16.2.1 1998/12/22 11:23:31 hohndel Exp $ */
 /* $XConsortium: auth.c /main/62 1995/12/19 16:44:07 mor $ */
 /*
 
@@ -97,12 +97,17 @@
 # include <sync/queue.h>
 # include <sync/sema.h>
 #endif
+#ifdef __GNU__
+#include <netdb.h>
+#undef SIOCGIFCONF
+#else __GNU__
 #ifndef MINIX
 #include <net/if.h>
 #else
 #include <net/netlib.h>
 #include <net/gen/netdb.h>
 #endif /* !MINIX */
+#endif __GNU__
 
 #if ((defined(SVR4) && !defined(sun)) || defined(ISC)) && defined(SIOCGIFCONF)
 #define SYSV_SIOCGIFCONF
Index: xc/programs/xdm/chooser.c
diff -u xc/programs/xdm/chooser.c:3.13.2.1 xc/programs/xdm/chooser.c:3.13.2.2
--- xc/programs/xdm/chooser.c:3.13.2.1	Sat Sep  5 13:32:08 1998
+++ xc/programs/xdm/chooser.c	Tue Dec 22 22:23:31 1998
@@ -1,6 +1,6 @@
 /*
  * $XConsortium: chooser.c /main/27 1996/01/25 18:45:41 kaleb $
- * $XFree86: xc/programs/xdm/chooser.c,v 3.13.2.1 1998/09/05 03:32:08 dawes Exp $
+ * $XFree86: xc/programs/xdm/chooser.c,v 3.13.2.2 1998/12/22 11:23:31 hohndel Exp $
  *
 Copyright (c) 1990  X Consortium
 
@@ -138,7 +138,9 @@
 # include <sync/sema.h>
 #endif
 #ifndef MINIX
+#ifndef __GNU__
 # include <net/if.h>
+#endif /* __GNU__ */
 #endif
 #endif /* hpux */
 
@@ -606,7 +608,7 @@
  *  addresses on the local host.
  */
 
-#ifndef MINIX
+#if !defined(MINIX) && !defined(__GNU__)
 
 /* Handle variable length ifreq in BNR2 and later */
 #ifdef VARIABLE_IFREQ
Index: xc/programs/xdm/daemon.c
diff -u xc/programs/xdm/daemon.c:3.6 xc/programs/xdm/daemon.c:3.6.4.1
--- xc/programs/xdm/daemon.c:3.6	Sat Jun 29 19:10:31 1996
+++ xc/programs/xdm/daemon.c	Tue Dec 22 22:23:32 1998
@@ -1,5 +1,5 @@
 /* $XConsortium: daemon.c,v 1.16 94/12/01 17:10:49 kaleb Exp $ */
-/* $XFree86: xc/programs/xdm/daemon.c,v 3.6 1996/06/29 09:10:31 dawes Exp $ */
+/* $XFree86: xc/programs/xdm/daemon.c,v 3.6.4.1 1998/12/22 11:23:32 hohndel Exp $ */
 /*
 
 Copyright (c) 1988  X Consortium
@@ -93,7 +93,7 @@
 	stat = setpgid(child_id, child_id);
 	/* This gets error EPERM.  Why? */
 #else
-#if defined(SYSV)
+#if defined(SYSV)||defined(__GNU__)
 	stat = 0;	/* don't know how to set child's process group */
 #else
 	stat = setpgrp(child_id, child_id);
@@ -120,7 +120,7 @@
 #ifdef CSRG_BASED
     daemon (0, 0);
 #else
-#if defined(SYSV) || defined(SVR4)
+#if defined(SYSV) || defined(SVR4) || defined(__GNU__)
     setpgrp ();
 #else
     setpgrp (0, getpid());
Index: xc/programs/xdm/util.c
diff -u xc/programs/xdm/util.c:3.7.4.1 xc/programs/xdm/util.c:3.7.4.2
--- xc/programs/xdm/util.c:3.7.4.1	Sun Oct  4 23:37:23 1998
+++ xc/programs/xdm/util.c	Tue Dec 22 22:23:32 1998
@@ -1,5 +1,5 @@
 /* $XConsortium: util.c,v 1.18 94/11/21 18:33:11 kaleb Exp $ */
-/* $XFree86: xc/programs/xdm/util.c,v 3.7.4.1 1998/10/04 13:37:23 hohndel Exp $ */
+/* $XFree86: xc/programs/xdm/util.c,v 3.7.4.2 1998/12/22 11:23:32 hohndel Exp $ */
 /*
 
 Copyright (c) 1989  X Consortium
@@ -224,8 +224,8 @@
 #ifdef CSRG_BASED
 	setsid();
 #else
-#if defined(SYSV) || defined(SVR4)
-#if !(defined(SVR4) && defined(i386)) || defined(SCO325)
+#if defined(SYSV) || defined(SVR4) || defined(__GNU__)
+#if !(defined(SVR4) && defined(i386)) || defined(SCO325) || defined(__GNU__)
 	setpgrp ();
 #endif
 #else
Index: xc/programs/xieperf/modify.c
diff -u xc/programs/xieperf/modify.c:3.1 xc/programs/xieperf/modify.c:3.1.4.1
--- xc/programs/xieperf/modify.c:3.1	Wed Oct 23 23:13:37 1996
+++ xc/programs/xieperf/modify.c	Tue Dec 22 22:23:33 1998
@@ -1,5 +1,5 @@
 /* $XConsortium: modify.c,v 1.12 94/04/17 20:39:26 rws Exp $ */
-/* $XFree86: xc/programs/xieperf/modify.c,v 3.1 1996/10/23 13:13:37 dawes Exp $ */
+/* $XFree86: xc/programs/xieperf/modify.c,v 3.1.4.1 1998/12/22 11:23:33 hohndel Exp $ */
 
 /**** module modify.c ****/
 /******************************************************************************
@@ -827,7 +827,7 @@
 #if defined(SYSV) || defined(SVR4) || defined(__osf__)
 #define random lrand48
 #endif
-#if !defined(sgi) && !defined(linux) && !defined(__alpha__)
+#if !defined(sgi) && !defined(linux) && !defined(__alpha__) && !defined(__GNU__)
 extern long random();
 #endif
 #define RAND( x, y ) ( ( random() / 2147483648.0 ) * ( y - x ) + x )
Index: xc/programs/xinit/startx.cpp
diff -u xc/programs/xinit/startx.cpp:3.0.8.3 xc/programs/xinit/startx.cpp:3.0.8.4
--- xc/programs/xinit/startx.cpp:3.0.8.3	Sun Nov  8 13:16:43 1998
+++ xc/programs/xinit/startx.cpp	Mon Dec 28 00:10:18 1998
@@ -1,7 +1,7 @@
 XCOMM!/bin/sh
 
 XCOMM $XConsortium: startx.cpp,v 1.4 91/08/22 11:41:29 rws Exp $
-XCOMM $XFree86: xc/programs/xinit/startx.cpp,v 3.0.8.3 1998/11/08 02:16:43 dawes Exp $
+XCOMM $XFree86: xc/programs/xinit/startx.cpp,v 3.0.8.4 1998/12/27 13:10:18 dawes Exp $
 XCOMM 
 XCOMM This is just a sample implementation of a slightly less primitive 
 XCOMM interface than xinit.  It looks for user .xinitrc and .xserverrc
@@ -82,9 +82,17 @@
 while [ "x$1" != "x" ]; do
     case "$1" in
 	/''*|\.*)	if [ "$whoseargs" = "client" ]; then
-		    clientargs="$1"
+		    if [ "x$clientargs" = x ]; then
+			clientargs="$1"
+		    else
+			clientargs="$clientargs $1"
+		    fi
 		else
-		    serverargs="$1"
+		    if [ "x$serverargs" = x ]; then
+			serverargs="$1"
+		    else
+			serverargs="$serverargs $1"
+		    fi
 		fi ;;
 	--)	whoseargs="server" ;;
 	*)	if [ "$whoseargs" = "client" ]; then
Index: xc/programs/xkbcomp/keycodes/xfree98
diff -u xc/programs/xkbcomp/keycodes/xfree98:3.2 xc/programs/xkbcomp/keycodes/xfree98:3.2.2.2
--- xc/programs/xkbcomp/keycodes/xfree98:3.2	Mon Dec 23 18:12:24 1996
+++ xc/programs/xkbcomp/keycodes/xfree98	Sun Dec 20 23:08:44 1998
@@ -26,6 +26,8 @@
 //other dealings in this Software without prior written authorization
 //from the X Consortium.
 //
+// $XFree86: xc/programs/xkbcomp/keycodes/xfree98,v 3.2.2.2 1998/12/20 12:08:44 hohndel Exp $
+//
 default xkb_keycodes "pc98" {
 
     minimum= 8;
@@ -117,8 +119,8 @@
 
     <INS>  =  64;
     <DELE> =  65;
-    <PGUP> =  62;
-    <PGDN> =  63;
+    <PGUP> =  63;
+    <PGDN> =  62;
     <UP>   =  66;
     <LEFT> =  67;
     <RGHT> =  68;
Index: xc/programs/xkbcomp/keymap/xfree86
diff -u xc/programs/xkbcomp/keymap/xfree86:3.8 xc/programs/xkbcomp/keymap/xfree86:3.8.2.1
--- xc/programs/xkbcomp/keymap/xfree86:3.8	Mon Dec 23 18:12:36 1996
+++ xc/programs/xkbcomp/keymap/xfree86	Fri Dec 18 22:56:36 1998
@@ -1,4 +1,5 @@
 // $XConsortium: xfree86 /main/12 1996/08/31 12:17:30 kaleb $
+// $XFree86: xc/programs/xkbcomp/keymap/xfree86,v 3.8.2.1 1998/12/18 11:56:36 dawes Exp $
 default xkb_keymap "us" {
     xkb_keycodes	{ include "xfree86"		};
     xkb_types		{ include "default"		};
@@ -168,3 +169,21 @@
     xkb_geometry	{ include "pc(jp106)"			};
 };
 
+// Additions by Eric Moreau, 1998-09-27
+// I am reachable at eric_moreau@compuserve.com
+
+xkb_keymap "fr_CA_sundeadkeys"	{
+    xkb_keycodes	{ include "xfree86"		};
+    xkb_types		{ include "default"		};
+    xkb_compatibility	{ include "default"		};
+    xkb_symbols		{ include "en_US(pc102)+ca_enhanced(sundeadkeys)+us_group3(basic)+group(ctrl_shift_toggle)+ralt(mode_switch)" };
+    xkb_geometry 	{ include "pc(pc102)"		};
+};
+
+xkb_keymap "fr_CA"	{
+    xkb_keycodes	{ include "xfree86"		};
+    xkb_types		{ include "default"		};
+    xkb_compatibility	{ include "default"		};
+    xkb_symbols		{ include "en_US(pc102)+ca_enhanced(basic)+us_group3(basic)+group(ctrl_shift_toggle)+ralt(mode_switch)" };
+    xkb_geometry 	{ include "pc(pc102)"		};
+};
Index: xc/programs/xkbcomp/symbols/Imakefile
diff -u xc/programs/xkbcomp/symbols/Imakefile:3.9.2.3 xc/programs/xkbcomp/symbols/Imakefile:3.9.2.4
--- xc/programs/xkbcomp/symbols/Imakefile:3.9.2.3	Sun Jul  6 01:55:54 1997
+++ xc/programs/xkbcomp/symbols/Imakefile	Fri Dec 18 22:56:37 1998
@@ -1,12 +1,12 @@
 XCOMM $TOG: Imakefile /main/13 1997/06/10 06:56:01 kaleb $
-XCOMM $XFree86: xc/programs/xkbcomp/symbols/Imakefile,v 3.9.2.3 1997/07/05 15:55:54 dawes Exp $
+XCOMM $XFree86: xc/programs/xkbcomp/symbols/Imakefile,v 3.9.2.4 1998/12/18 11:56:37 dawes Exp $
 #define IHaveSubdirs
 
       TESTDATA = 
-     DATAFILES = amiga ataritt be bg ca cs ctrl de de_CH dk dvorak en_US \
-		 es fi fr fr_CH \
-		 gb group hu iso9995-3 it jp keypad lock no pc104 pl pt ru se \
-		 th us
+     DATAFILES = amiga ataritt be bg ca ca_enhanced cs ctrl de de_CH dk \
+		 dvorak en_US es fi fr fr_CH \
+		 gb group hu iso9995-3 it jp keypad lock no pc104 pl pt \
+		 ralt ru se th us
        SUBDIRS = digital fujitsu nec sgi sony sun
 
 MakeXkbDir($(LIBDIR)/xkb,symbols)
Index: xc/programs/xkbcomp/symbols/ca_enhanced
diff -u /dev/null xc/programs/xkbcomp/symbols/ca_enhanced:1.1.2.1
--- /dev/null	Wed Jan  6 00:34:00 1999
+++ xc/programs/xkbcomp/symbols/ca_enhanced	Fri Dec 18 22:56:38 1998
@@ -0,0 +1,185 @@
+// This file was inspired by XFree86 version 3.3.2
+// as distributed with RedHat Linux 5.1
+// This file was created by Eric Moreau, 1998-09-27
+// I am reachable at eric_moreau@compuserve.com
+//
+// $XFree86: xc/programs/xkbcomp/symbols/ca_enhanced,v 1.1.2.1 1998/12/18 11:56:38 dawes Exp $
+//
+// Those are intened to be modifications to the symbols
+// defined by /usr/X11R6/lib/X11/xkb/symbols/ca
+//
+// Most of the french canadian keyboards availables on PCs
+// are mapped like this.
+// Note that I remaped the ISO9995-3 keyboard but took
+// care of not loosing symbols.
+
+partial alphanumeric_keys
+xkb_symbols "basic" {
+    include "ca(basic)"
+    key <TLDE> {
+		type[Group1]="THREE_LEVEL",
+		symbols[Group1]= [ numbersign, bar, backslash ],
+		symbols[Group2]= [ backslash, exclamdown ]
+		};
+    key <AE01> {
+		type[Group1]="THREE_LEVEL",
+		symbols[Group1]= [ 1, exclam, plusminus ],
+		symbols[Group2]= [ plusminus, onesuperior ]
+		};
+    key <AE02> {
+		type[Group1]="THREE_LEVEL",
+		symbols[Group1]= [ 2, quotedbl, at ],
+		symbols[Group2]= [ at, oneeighth ]
+		};
+    key <AE03> {
+		type[Group1]="THREE_LEVEL",
+		symbols[Group1]= [ 3, slash, sterling ],
+		symbols[Group2]= [ sterling ]
+		};
+    key <AE04> {
+		type[Group1]="THREE_LEVEL",
+		symbols[Group1]= [ 4, dollar, cent ],
+		symbols[Group2]= [ cent ]
+		};
+    key <AE05> {
+		type[Group1]="THREE_LEVEL",
+		symbols[Group1]= [ 5, percent, currency ],
+		symbols[Group2]= [ currency, threeeighths ]
+		};
+    key <AE06> {
+		type[Group1]="THREE_LEVEL",
+		symbols[Group1]= [ 6, question, notsign ],
+		symbols[Group2]= [ notsign, fiveeighths ]
+		};
+    key <AE07> {
+		type[Group1]="THREE_LEVEL",
+		symbols[Group1]= [ 7, ampersand, brokenbar ],
+		symbols[Group2]= [ brokenbar, seveneighths ]
+		};
+    key <AE08> {
+		type[Group1]="THREE_LEVEL",
+		symbols[Group1]= [ 8, asterisk, twosuperior ],
+		symbols[Group2]= [ twosuperior, trademark ]
+		};
+    key <AE09> {
+		type[Group1]="THREE_LEVEL",
+		symbols[Group1]= [ 9, parenleft, threesuperior ],
+		symbols[Group2]= [ threesuperior ]
+		};
+    key <AE10> {
+		type[Group1]="THREE_LEVEL",
+		symbols[Group1]= [ 0, parenright, onequarter ],
+		symbols[Group2]= [ onequarter ]
+		};
+    key <AE11> {
+		type[Group1]="THREE_LEVEL",
+		symbols[Group1]= [ minus, underscore, onehalf ],
+		symbols[Group2]= [ onehalf, questiondown ]
+		};
+    key <AE12> {
+		type[Group1]="THREE_LEVEL",
+		symbols[Group1]= [ equal, plus, threequarters ],
+		symbols[Group2]= [ threequarters, dead_ogonek ]
+		};
+
+    key <AD01> {
+		symbols[Group1]= [ q, Q ],
+		symbols[Group2]= [ oslash, Ooblique ]
+		};
+    key <AD04> {
+		symbols[Group1]= [ r, R ],
+		symbols[Group2]= [ thorn, Thorn ]
+		};
+    key <AD09> {
+		type[Group1]="THREE_LEVEL",
+		symbols[Group1]= [ o, O, section ],
+		symbols[Group2]= [ section, Greek_OMEGA ]
+		};
+    key <AD10> {
+		type[Group1]="THREE_LEVEL",
+		symbols[Group1]= [ p, P, paragraph ],
+		symbols[Group2]= [ paragraph, registered ]
+		};
+    key <AD11> {
+		type[Group1]="THREE_LEVEL",
+		symbols[Group1]= [ dead_circumflex, dead_circumflex, bracketleft ],
+		symbols[Group2]= [ bracketleft, dead_abovering ]
+		};
+    key <AD12> {
+		type[Group1]="THREE_LEVEL",
+		symbols[Group1]= [ dead_cedilla, dead_diaeresis, bracketright ],
+		symbols[Group2]= [ bracketright, horizconnector ]
+		};
+
+    key <AC10> {
+		type[Group1]="THREE_LEVEL",
+		symbols[Group1]= [ semicolon, colon, asciitilde ],
+		symbols[Group2]= [ asciitilde, dead_doubleacute ]
+		};
+    key <AC11> {
+		type[Group1]="THREE_LEVEL",
+		symbols[Group1]= [ dead_grave, dead_grave, braceleft ],
+		symbols[Group2]= [ braceleft, dead_caron ]
+		};
+
+    key <AB01> {
+		symbols[Group1]= [ z, Z ],
+		symbols[Group2]= [ dead_belowdot, dead_abovedot ]
+		};
+    key <AB07> {
+		type[Group1]="THREE_LEVEL",
+		symbols[Group1]= [ m, M, mu ],
+		symbols[Group2]= [ mu, masculine ]
+		};
+    key <AB08> {
+		type[Group1]="THREE_LEVEL",
+		symbols[Group1]= [ comma, quoteright, horizconnector ],
+		symbols[Group2]= [ dead_macron, multiply ]
+		};
+    key <AB09> {
+		type[Group1]="THREE_LEVEL",
+		symbols[Group1]= [ period, period, periodcentered ],
+		symbols[Group2]= [ periodcentered, division ]
+		};
+    key <AB10> {
+		type[Group1]="THREE_LEVEL",
+		symbols[Group1]= [ eacute, Eacute, dead_acute ],
+		symbols[Group2]= [ dead_acute ]
+		};
+    key <BKSL> {
+		type[Group1]="THREE_LEVEL",
+		symbols[Group1]= [ less, greater, braceright ],
+		symbols[Group2]= [ braceright, dead_breve ]
+		};
+
+    key <LSGT> {
+		type[Group1]="THREE_LEVEL",
+		symbols[Group1]= [ guillemotleft, guillemotright, degree ],
+		symbols[Group2]= [ degree ]
+		};
+};
+
+partial alphanumeric_keys
+xkb_symbols "Sundeadkeys" {
+    include "ca_enhanced(basic)"    
+    key <AD11> {
+		type[Group1]="THREE_LEVEL",
+		symbols[Group1]= [ SunFA_Circum, SunFA_Circum, bracketleft ],
+		symbols[Group2]= [ bracketleft, dead_abovering ]
+		};
+    key <AD12> {
+		type[Group1]="THREE_LEVEL",
+		symbols[Group1]= [ SunFA_Cedilla, SunFA_Diaeresis, bracketright ],
+		symbols[Group2]= [ bracketright, horizconnector ]
+		};
+    key <AC11> {
+		type[Group1]="THREE_LEVEL",
+		symbols[Group1]= [ SunFA_Grave, SunFA_Grave, braceleft ],
+		symbols[Group2]= [ braceleft, dead_caron ]
+		};
+};
+
+partial alphanumeric_keys
+xkb_symbols "sundeadkeys" {
+    include "ca_enhanced(Sundeadkeys)"
+};
Index: xc/programs/xkbcomp/symbols/ralt
diff -u /dev/null xc/programs/xkbcomp/symbols/ralt:1.1.2.1
--- /dev/null	Wed Jan  6 00:34:01 1999
+++ xc/programs/xkbcomp/symbols/ralt	Fri Dec 18 22:56:38 1998
@@ -0,0 +1,18 @@
+// This file was inspired by XFree86 version 3.3.2
+// as distributed with RedHat Linux 5.1
+// This file was created by Eric Moreau, 1998-09-27
+// I am reachable at eric_moreau@compuserve.com
+//
+// $XFree86: xc/programs/xkbcomp/symbols/ralt,v 1.1.2.1 1998/12/18 11:56:38 dawes Exp $
+//
+// This gives the Right Alt key (sometimes labeled
+// as AltGr or Alt Car) the capability of displaying
+// the third symbol labeled on your keys.
+
+partial alphanumeric_keys
+xkb_symbols "mode_switch" {
+    key <RALT> { 
+	symbols[Group1]= [ Mode_switch, Multi_key ],
+	virtualMods= AltGr
+	};
+};
Index: xc/programs/xkbcomp/symbols/us_group3
diff -u /dev/null xc/programs/xkbcomp/symbols/us_group3:1.1.2.1
--- /dev/null	Wed Jan  6 00:34:01 1999
+++ xc/programs/xkbcomp/symbols/us_group3	Fri Dec 18 22:56:38 1998
@@ -0,0 +1,272 @@
+// This file was taken from XFree86 version 3.3.2
+// as distributed with RedHat Linux 5.1
+// This file was modified by Eric Moreau, 1998-09-27
+// so that the US keyboard would show as Group 3 on the keymap.
+// I am reachable at eric_moreau@compuserve.com
+//
+// $XFree86: xc/programs/xkbcomp/symbols/us_group3,v 1.1.2.1 1998/12/18 11:56:38 dawes Exp $
+//
+// Original Header follows:
+//
+// $TOG: us /main/12 1997/06/14 06:37:07 kaleb $
+
+// symbols definition for a very simple US/ASCII layout.
+// It has basically the alphanumeric keys, punctuation, 
+// one shift key, one control key and caps lock. It 
+// uses the punctuation keys configurations common on PC 
+// keyboards (e.g. key <ABO9> is { [], [], [ period greater ] })
+
+partial hidden alphanumeric_keys modifier_keys 
+xkb_symbols "basic" {
+
+    name[Group3]= "US/ASCII";
+    key <ESC>  {	[], [], [ Escape			]	};
+
+    // Alphanumeric section
+    key <TLDE> {	[], [], [ quoteleft,	asciitilde	]	};
+    key <AE01> {	[], [], [	  1,	exclam 		]	};
+    key <AE02> {	[], [], [	  2,	at		]	};
+    key <AE03> {	[], [], [	  3,	numbersign	]	};
+    key <AE04> {	[], [], [	  4,	dollar		]	};
+    key <AE05> {	[], [], [	  5,	percent		]	};
+    key <AE06> {	[], [], [	  6,	asciicircum	]	};
+    key <AE07> {	[], [], [	  7,	ampersand	]	};
+    key <AE08> {	[], [], [	  8,	asterisk	]	};
+    key <AE09> {	[], [], [	  9,	parenleft	]	};
+    key <AE10> {	[], [], [	  0,	parenright	]	};
+    key <AE11> {	[], [], [     minus,	underscore	]	};
+    key <AE12> {	[], [], [     equal,	plus		]	};
+    key <BKSP> {	[], [], [ 	BackSpace		]	};
+
+    key  <TAB> {	[], [], [ 	Tab,	ISO_Left_Tab	]	};
+    key <AD01> {	[], [], [	  q,	Q 		]	};
+    key <AD02> {	[], [], [	  w,	W		]	};
+    key <AD03> {	[], [], [	  e,	E		]	};
+    key <AD04> {	[], [], [	  r,	R		]	};
+    key <AD05> {	[], [], [	  t,	T		]	};
+    key <AD06> {	[], [], [	  y,	Y		]	};
+    key <AD07> {	[], [], [	  u,	U		]	};
+    key <AD08> {	[], [], [	  i,	I		]	};
+    key <AD09> {	[], [], [	  o,	O		]	};
+    key <AD10> {	[], [], [	  p,	P		]	};
+    key <AD11> {	[], [], [ bracketleft,	braceleft	]	};
+    key <AD12> {	[], [], [ bracketright,	braceright	]	};
+    key <RTRN> {	[], [], [ Return			]	};
+
+    key <CAPS> {	[], [], [	Caps_Lock		]	};
+    key <AC01> {	[], [], [	  a,	A 		]	};
+    key <AC02> {	[], [], [	  s,	S		]	};
+    key <AC03> {	[], [], [	  d,	D		]	};
+    key <AC04> {	[], [], [	  f,	F		]	};
+    key <AC05> {	[], [], [	  g,	G		]	};
+    key <AC06> {	[], [], [	  h,	H		]	};
+    key <AC07> {	[], [], [	  j,	J		]	};
+    key <AC08> {	[], [], [	  k,	K		]	};
+    key <AC09> {	[], [], [	  l,	L		]	};
+    key <AC10> {	[], [], [ semicolon,	colon		]	};
+    key <AC11> {	[], [], [ quoteright,	quotedbl	]	};
+
+    key <LFSH> {	[], [], [ 	 Shift_L		]	};
+    key <AB01> {	[], [], [	  z,	Z 		]	};
+    key <AB02> {	[], [], [	  x,	X		]	};
+    key <AB03> {	[], [], [	  c,	C		]	};
+    key <AB04> {	[], [], [	  v,	V		]	};
+    key <AB05> {	[], [], [	  b,	B		]	};
+    key <AB06> {	[], [], [	  n,	N		]	};
+    key <AB07> {	[], [], [	  m,	M		]	};
+    key <AB08> {	[], [], [     comma,	less		]	};
+    key <AB09> {	[], [], [    period,	greater		]	};
+    key <AB10> {	[], [], [     slash,	question	]	};
+    key <BKSL> {	[], [], [ backslash,	bar		]	};
+
+    key <LCTL> {	[], [], [ 	 Control_L		]	};
+    key <SPCE> {	[], [], [ 	 space			]	};
+    // End alphanumeric section
+
+    // begin modifier mappings
+    modifier_map Shift  { Shift_L };
+    modifier_map Lock   { Caps_Lock };
+    modifier_map Control{ Control_L };
+};
+
+// definition of a US/ASCII layout for a typical 101-key keyboard. 
+// Includes the basic alphanumeric and punctuation keys and then 
+// defines the "extra" (right) modifier keys, function keys, cursor,
+// edit, and keypad keys.
+xkb_symbols "generic101" {
+    include "us_group3(basic)"
+    key <RTSH> {	[], [], [ 	Shift_R		]	};
+    key <LALT> {	[], [], [ 	Alt_L	 	]	};
+    key <RCTL> {	[], [], [ 	Control_R	]	};
+    key <RALT> {	[], [], [	Alt_R		]	};
+
+    // Begin "Function" section
+    key <FK01> {	[], [], [ 	 F1		]	};
+    key <FK02> {	[], [], [	 F2		]	};
+    key <FK03> {	[], [], [	 F3		]	};
+    key <FK04> {	[], [], [	 F4		]	};
+    key <FK05> {	[], [], [	 F5		]	};
+    key <FK06> {	[], [], [	 F6		]	};
+    key <FK07> {	[], [], [	 F7		]	};
+    key <FK08> {	[], [], [	 F8		]	};
+    key <FK09> {	[], [], [        F9		]	};
+    key <FK10> {	[], [], [        F10		]	};
+    key <FK11> {	[], [], [        F11		]	};
+    key <FK12> {	[], [], [ 	 F12		]	};
+    // End "Function" section
+
+    // Begin "Editing" section
+    key <PRSC> {
+	type= "PC_SYSRQ",
+	symbols[Group3]= [], [], [ Print, Execute ]
+    };
+    key <SCLK> {  [], [], [  Scroll_Lock	]	};
+    key <PAUS> {
+	type= "PC_BREAK",
+	symbols[Group3]= [], [], [ Pause, Break ]
+    };
+    key  <INS> {  	[], [], [  Insert		]	};
+    key <HOME> {	[], [], [  Home			]	};
+    key <PGUP> {	[], [], [  Prior		]	};
+    key <DELE> { 	[], [], [ Delete		]			};
+    key  <END> {	[], [], [  End			]	};
+    key <PGDN> {	[], [], [  Next			]	};
+
+    key   <UP> {	[], [], [  Up			]	};
+    key <LEFT> {	[], [], [  Left			]	};
+    key <DOWN> {	[], [], [  Down			]	};
+    key <RGHT> {	[], [], [  Right		]	};
+
+    // End "Editing" section, begin "Keypad"
+    key <NMLK> {	[], [], [  Num_Lock, Pointer_EnableKeys		]	};
+    key <KPDV> {	[], [], [  KP_Divide		]	};
+    key <KPMU> {	[], [], [  KP_Multiply		]	};
+    key <KPSU> {	[], [], [  KP_Subtract		]	};
+
+    key  <KP7> {	[], [], [  KP_Home,	KP_7	]	};
+    key  <KP8> {	[], [], [  KP_Up,	KP_8	]	};
+    key  <KP9> {	[], [], [  KP_Prior,	KP_9	]	};
+    key <KPAD> {	[], [], [  	KP_Add		]	};
+
+    key  <KP4> {	[], [], [  KP_Left,	KP_4	]	};
+    key  <KP5> {	[], [], [  KP_Begin,	KP_5	]	};
+    key  <KP6> {	[], [], [  KP_Right,	KP_6	]	};
+
+    key  <KP1> {	[], [], [  KP_End,	KP_1	]	};
+    key  <KP2> {	[], [], [  KP_Down,	KP_2	]	};
+    key  <KP3> {	[], [], [  KP_Next,	KP_3	]	};
+    key <KPEN> {	[], [], [  	KP_Enter	]	};
+
+    key  <KP0> {	[], [], [  KP_Insert,	KP_0	]	};
+    key <KPDL> {  [], [], [  KP_Delete,	KP_Decimal ]	};
+    // End "Keypad" section
+
+
+    // begin modifier mappings
+    modifier_map Shift  { Shift_R };
+    modifier_map Control{ Control_R };
+    modifier_map Mod1   { Alt_L, Alt_R };
+    modifier_map Mod2   { Num_Lock };
+    modifier_map Mod5   { Scroll_Lock };
+};
+
+// definition for the PC-AT type 101 key keyboard
+default 
+xkb_symbols "pc101" {
+    include "us_group3(generic101)"
+    key <LALT> {	[], [], [ 	Alt_L,	Meta_L 		]	};
+    key <RALT> {	[], [], [	Alt_R,	Meta_R		]	};
+
+    // begin modifier mappings
+    modifier_map Mod1   { Alt_L, Alt_R, Meta_L, Meta_R };
+};
+
+// definition for the extra key on 102-key keyboards
+xkb_symbols "pc102" {
+    include "us_group3(pc101)"
+    key <LSGT> {	[], [], [      less,    greater		]	};
+};
+
+// definition of Euro-style, Alt_R == [], [], [Mode_switch, Multi_key]
+xkb_symbols "pc101euro" {
+    include "us_group3(generic101)"
+    key <LALT> {	[], [], [ 	Alt_L,	Meta_L 		]	};
+    key <RALT> {	[], [], [ Mode_switch,	Multi_key	]	};
+
+    // begin modifier mappings
+    modifier_map Mod1   { Alt_L, Meta_L };
+};
+
+// definition of Alternate Euro-style, Alt_R == [], [], [Multi_key]
+xkb_symbols "pc101compose" {
+    include "us_group3(generic101)"
+    key <LALT> {	[], [], [ 	Alt_L,	Meta_L 		]	};
+    key <RALT> {	[], [], [ 	Multi_key		]	};
+
+    // begin modifier mappings
+    modifier_map Mod1   { Alt_L, Meta_L };
+};
+
+xkb_symbols "pc102euro" {
+    include "us_group3(pc101euro)"
+    key <LSGT> {	[], [], [      less,    greater		]	};
+};
+
+xkb_symbols "pc102compose" {
+    include "us_group3(pc101compose)"
+    key <LSGT> {	[], [], [      less,    greater		]	};
+};
+
+// definition for the extra keys on 104-key "Windows95" keyboards
+xkb_symbols "pc104" {
+    include "us_group3(generic101)"
+    key <LALT> {	[], [], [ 	Alt_L		]	};
+    key <RALT> {	[], [], [	Alt_R		]	};
+    key <LWIN> {	[], [], [	Meta_L		]	};
+    key <RWIN> {	[], [], [	Meta_R		]	};
+    key <MENU> {	[], [], [	Menu		]	};
+
+    // modifier mappings
+    modifier_map Mod1   { Alt_L, Alt_R };
+    modifier_map Mod4   { Meta_L, Meta_R };
+};
+
+// definition of Euro-style, Right "logo" key == [], [], [Mode_switch, Multi_key]
+xkb_symbols "pc104euro" {
+    include "us_group3(pc104)"
+    key <RWIN> {	[], [], [	Mode_switch, Multi_key	]	};
+};
+
+// put the compose key on the right "logo" key
+xkb_symbols "pc104compose" {
+    include "us_group3(pc104)"
+    key <RWIN> {	[], [], [	Multi_key	]	};
+};
+
+// defintion which includes both the Windows95 keyboards _and_
+// the extra key on most European keyboards.
+xkb_symbols "pc105" {
+    include "us_group3(pc104)"
+    key <LSGT> {	[], [], [      less,    greater		]	};
+};
+xkb_symbols "pc105euro" {
+    include "us_group3(pc104euro)"
+    key <LSGT> {	[], [], [      less,    greater		]	};
+};
+xkb_symbols "pc105compose" {
+    include "us_group3(pc104compose)"
+    key <LSGT> {	[], [], [      less,    greater		]	};
+};
+// universam maps are identical to pc105; wish we had aliases for map names.
+xkb_symbols "pc_universal" {
+    include "us_group3(pc104)"
+    key <LSGT> {	[], [], [      less,    greater		]	};
+};
+xkb_symbols "pc105euro" {
+    include "us_group3(pc104euro)"
+    key <LSGT> {	[], [], [      less,    greater		]	};
+};
+xkb_symbols "pc105compose" {
+    include "us_group3(pc104compose)"
+    key <LSGT> {	[], [], [      less,    greater		]	};
+};
Index: xc/programs/xkbcomp/symbols/nec/jp
diff -u xc/programs/xkbcomp/symbols/nec/jp:3.3.2.2 xc/programs/xkbcomp/symbols/nec/jp:3.3.2.3
--- xc/programs/xkbcomp/symbols/nec/jp:3.3.2.2	Mon Feb  2 09:08:24 1998
+++ xc/programs/xkbcomp/symbols/nec/jp	Mon Dec 14 01:12:28 1998
@@ -26,7 +26,7 @@
 //other dealings in this Software without prior written authorization
 //from the X Consortium.
 //
-// $XFree86: xc/programs/xkbcomp/symbols/nec/jp,v 3.3.2.2 1998/02/01 22:08:24 robin Exp $
+// $XFree86: xc/programs/xkbcomp/symbols/nec/jp,v 3.3.2.3 1998/12/13 14:12:28 dawes Exp $
 //
 // symbols for a NEC PC98 keyboard
 default xkb_symbols "pc98" {
@@ -163,7 +163,7 @@
     modifier_map Shift  { Shift_L };
     modifier_map Lock   { Caps_Lock };
     modifier_map Control{ Control_L };
+    modifier_map Mod1   { Alt_L };
     modifier_map Mod2   { Mode_switch };
-    modifier_map Mod3   { Alt_L };
 };
 
Index: xc/programs/xmh/command.c
diff -u xc/programs/xmh/command.c:3.4 xc/programs/xmh/command.c:3.4.4.1
--- xc/programs/xmh/command.c:3.4	Thu Oct  3 18:50:27 1996
+++ xc/programs/xmh/command.c	Fri Dec 18 22:56:39 1998
@@ -1,5 +1,5 @@
 /* $XConsortium: command.c,v 2.49 95/04/05 19:59:06 kaleb Exp $ */
-/* $XFree86: xc/programs/xmh/command.c,v 3.4 1996/10/03 08:50:27 dawes Exp $ */
+/* $XFree86: xc/programs/xmh/command.c,v 3.4.4.1 1998/12/18 11:56:39 dawes Exp $ */
 
 /*
  *			  COPYRIGHT 1987, 1989
@@ -35,7 +35,7 @@
 #ifndef SYSV
 #include <sys/wait.h>
 #endif	/* SYSV */
-#if defined(SVR4) && !defined(SCO325)
+#if !defined(DGUX) && !defined(SCO325) && defined(SVR4)
 #include <sys/filio.h>
 #endif
 
Index: xc/programs/xmodmap/handle.c
diff -u xc/programs/xmodmap/handle.c:3.0 xc/programs/xmodmap/handle.c:3.0.4.1
--- xc/programs/xmodmap/handle.c:3.0	Mon Aug 26 00:15:27 1996
+++ xc/programs/xmodmap/handle.c	Mon Dec 14 01:12:29 1998
@@ -1,5 +1,5 @@
 /* $XConsortium: handle.c,v 1.28 94/04/17 20:24:20 converse Exp $ */
-/* $XFree86: xc/programs/xmodmap/handle.c,v 3.0 1996/08/25 14:15:27 dawes Exp $ */
+/* $XFree86: xc/programs/xmodmap/handle.c,v 3.0.4.1 1998/12/13 14:12:29 dawes Exp $ */
 /*
 
 Copyright (c) 1988  X Consortium
@@ -76,7 +76,8 @@
 		if (!kcs)
 		    kcs = (KeyCode *)malloc(sizeof(KeyCode));
 		else
-		    kcs = (KeyCode *)realloc((char *)kcs, *pnum_kcs + 1);
+		    kcs = (KeyCode *)realloc((char *)kcs,
+					 sizeof(KeyCode) * (*pnum_kcs + 1));
 		kcs[*pnum_kcs] = i;
 		*pnum_kcs += 1;
 		break;
Index: xc/programs/xset/xset.c
diff -u xc/programs/xset/xset.c:3.8.2.3 xc/programs/xset/xset.c:3.8.2.4
--- xc/programs/xset/xset.c:3.8.2.3	Sun Jun 29 18:43:39 1997
+++ xc/programs/xset/xset.c	Fri Dec 18 22:56:40 1998
@@ -1,6 +1,6 @@
 /* 
  * $XConsortium: xset.c /main/71 1996/11/24 17:24:48 rws $ 
- * $XFree86: xc/programs/xset/xset.c,v 3.8.2.3 1997/06/29 08:43:39 dawes Exp $ 
+ * $XFree86: xc/programs/xset/xset.c,v 3.8.2.4 1998/12/18 11:56:40 dawes Exp $ 
  */
 
 /*
@@ -392,7 +392,7 @@
 	      DPMSEnable(dpy);
 	      DPMSSetTimeouts(dpy, standby_timeout, suspend_timeout, off_timeout);
 	  }
-	  else if (strcmp(arg, "force") == 0) {
+	  else if (i+1 < argc && strcmp(arg, "force") == 0) {
 	      i++;
 	      arg = argv[i];
 	      /*
Index: xc/programs/xterm/screen.c
diff -u xc/programs/xterm/screen.c:3.12.2.3 xc/programs/xterm/screen.c:3.12.2.4
--- xc/programs/xterm/screen.c:3.12.2.3	Wed Oct 21 06:51:52 1998
+++ xc/programs/xterm/screen.c	Fri Dec 18 22:56:41 1998
@@ -25,7 +25,7 @@
  * SOFTWARE.
  */
 
-/* $XFree86: xc/programs/xterm/screen.c,v 3.12.2.3 1998/10/20 20:51:52 hohndel Exp $ */
+/* $XFree86: xc/programs/xterm/screen.c,v 3.12.2.4 1998/12/18 11:56:41 dawes Exp $ */
 
 /* screen.c */
 
@@ -54,7 +54,9 @@
 #endif
 
 #ifdef SYSV
+#if !defined(DGUX)    /* Intel DG/ux uses termios.h */
 #include <sys/termio.h>
+#endif /* DGUX */
 #ifdef USE_USG_PTYS
 #include <sys/stream.h>			/* get typedef used in ptem.h */
 #include <sys/ptem.h>
Index: xc/programs/xterm/xterm.man
diff -u xc/programs/xterm/xterm.man:3.13.2.2 xc/programs/xterm/xterm.man:3.13.2.3
--- xc/programs/xterm/xterm.man:3.13.2.2	Wed Oct 21 06:51:58 1998
+++ xc/programs/xterm/xterm.man	Tue Dec 22 18:50:03 1998
@@ -25,7 +25,7 @@
 .\" other dealings in this Software without prior written authorization
 .\" from the X Consortium.
 .\"
-.\" $XFree86: xc/programs/xterm/xterm.man,v 3.13.2.2 1998/10/20 20:51:58 hohndel Exp $
+.\" $XFree86: xc/programs/xterm/xterm.man,v 3.13.2.3 1998/12/22 07:50:03 hohndel Exp $
 .\"
 .\" updated by Thomas Dickey <dickey@clark.net> for XFree86, July 1996.
 .TH XTERM 1 "Release 6.3" "X Version 11"
@@ -1664,7 +1664,6 @@
 .B "allow-send-events(\fIon/off/toggle\fP)"
 This action set or toggles the \fBallowSendEvents\fP resource and is also
 invoked by the \fBallowsends\fP entry in \fImainMenu\fP.
-.TP
 .TP 8
 .B "bell([\fIpercent\fP])"
 This action rings the keyboard bell at the specified percentage
Index: xc/include/Xos.h
diff -u xc/include/Xos.h:3.21.2.1 xc/include/Xos.h:3.21.2.2
--- xc/include/Xos.h:3.21.2.1	Fri Jan 23 23:35:11 1998
+++ xc/include/Xos.h	Tue Dec 22 22:23:05 1998
@@ -1,6 +1,6 @@
 /*
  * $XConsortium: Xos.h /main/70 1996/11/15 16:00:41 kaleb $
- * $XFree86: xc/include/Xos.h,v 3.21.2.1 1998/01/23 12:35:11 dawes Exp $
+ * $XFree86: xc/include/Xos.h,v 3.21.2.2 1998/12/22 11:23:05 hohndel Exp $
  * 
  * 
 Copyright (c) 1987  X Consortium
@@ -288,6 +288,13 @@
 
 #ifdef __EMX__
 typedef unsigned long fd_mask;
+#endif
+
+#ifdef __GNU__
+/* We define a reasonable limits.  */
+#define PATH_MAX 4096
+#define MAXPATHLEN 4096
+#define OPEN_MAX 256 
 #endif
 
 /* use POSIX name for signal */
Index: xc/include/Xpoll.h
diff -u xc/include/Xpoll.h:3.1 xc/include/Xpoll.h:3.1.2.2
--- xc/include/Xpoll.h:3.1	Mon Dec 23 16:58:10 1996
+++ xc/include/Xpoll.h	Sun Dec 20 23:08:42 1998
@@ -29,6 +29,7 @@
 from the X Consortium.
 
 */
+/* $XFree86: xc/include/Xpoll.h,v 3.1.2.2 1998/12/20 12:08:42 hohndel Exp $ */
 
 #ifndef _XPOLL_H_
 #define _XPOLL_H_
@@ -38,12 +39,19 @@
 #ifndef USE_POLL
 
 #include <X11/Xos.h>
+#if !defined(DGUX)
 #if (defined(SVR4) || defined(CRAY) || defined(AIXV3)) && !defined(FD_SETSIZE)
 #include <sys/select.h>
 #ifdef luna
 #include <sysent.h>
 #endif
 #endif
+#else /* DGUX  -- No sys/select in Intel DG/ux */
+#include <sys/time.h> 
+#include <sys/types.h>
+#include <sys/_int_unistd.h>
+#endif
+
 /* AIX 4.2 fubar-ed <sys/select.h>, so go to heroic measures to get it */
 #if defined(AIXV4) && !defined(NFDBITS)
 #include <sys/select.h>
Index: xc/lib/FS/FSlibos.h
diff -u xc/lib/FS/FSlibos.h:3.2 xc/lib/FS/FSlibos.h:3.2.2.1
--- xc/lib/FS/FSlibos.h:3.2	Mon Dec 23 16:58:50 1996
+++ xc/lib/FS/FSlibos.h	Tue Dec 22 22:23:06 1998
@@ -1,5 +1,5 @@
 /* $XConsortium: FSlibos.h /main/23 1996/11/13 14:43:51 lehors $ */
-/* $XFree86: xc/lib/FS/FSlibos.h,v 3.2 1996/12/23 05:58:50 dawes Exp $ */
+/* $XFree86: xc/lib/FS/FSlibos.h,v 3.2.2.1 1998/12/22 11:23:06 hohndel Exp $ */
 
 /* @(#)FSlibos.h	4.1	91/05/02
  * Copyright 1990 Network Computing Devices;
@@ -90,7 +90,11 @@
 #define OPEN_MAX NOFILE
 #else
 #ifndef __EMX__
+#ifdef __GNU__
+#define OPEN_MAX 256
+#else
 #define OPEN_MAX NOFILES_MAX
+#endif
 #else
 #define OPEN_MAX 256
 #endif
Index: xc/lib/X11/imConv.c
diff -u xc/lib/X11/imConv.c:1.5.2.5 xc/lib/X11/imConv.c:1.5.2.6
--- xc/lib/X11/imConv.c:1.5.2.5	Wed Oct 21 16:40:38 1998
+++ xc/lib/X11/imConv.c	Sun Dec  6 16:40:33 1998
@@ -31,7 +31,7 @@
                                 fujiwara@a80.tech.yk.fujitsu.co.jp
 
 ******************************************************************/
-/* $XFree86: xc/lib/X11/imConv.c,v 1.5.2.5 1998/10/21 06:40:38 dawes Exp $ */
+/* $XFree86: xc/lib/X11/imConv.c,v 1.5.2.6 1998/12/06 05:40:33 dawes Exp $ */
 
 #define NEED_EVENTS
 #include <stdio.h>
@@ -429,7 +429,7 @@
 #endif
     {sUTF8,	"utf8",		"\033%B"},
     /* Non-standard */
-    {sCyrillic,	"KOI8-R", "\033%/1\200\210koi8-r\002"},
+    {sKoi8,	"KOI8-R", "\033%/1\200\210koi8-r\002"},
     {sLatin9,	"ISO8859-15",	"\033%/1\200\213iso8859-15\002"},/* a.k.a. Latin-0 */
 };
 
Index: xc/lib/xtrans/Xtrans.c
diff -u xc/lib/xtrans/Xtrans.c:3.15.2.2 xc/lib/xtrans/Xtrans.c:3.15.2.3
--- xc/lib/xtrans/Xtrans.c:3.15.2.2	Sat Jul 19 14:59:16 1997
+++ xc/lib/xtrans/Xtrans.c	Mon Dec 14 01:12:01 1998
@@ -1,5 +1,5 @@
 /* $XConsortium: Xtrans.c,v 1.31 95/03/28 19:49:02 mor Exp $ */
-/* $XFree86: xc/lib/xtrans/Xtrans.c,v 3.15.2.2 1997/07/19 04:59:16 dawes Exp $ */
+/* $XFree86: xc/lib/xtrans/Xtrans.c,v 3.15.2.3 1998/12/13 14:12:01 dawes Exp $ */
 /*
 
 Copyright (c) 1993, 1994  X Consortium
@@ -723,7 +723,7 @@
 	    break;
 	case 1: /* Set to non-blocking mode */
 
-#if defined(O_NONBLOCK) && (!defined(ultrix) && !defined(hpux) && !defined(AIXV3) && !defined(uniosu) && !defined(__EMX__) && !defined(SCO))
+#if defined(O_NONBLOCK) && (!defined(ultrix) && !defined(hpux) && !defined(AIXV3) && !defined(uniosu) && !defined(__EMX__))
 	    ret = fcntl (fd, F_SETFL, O_NONBLOCK);
 #else
 #ifdef FIOSNBIO
Index: xc/lib/xtrans/Xtranslcl.c
diff -u xc/lib/xtrans/Xtranslcl.c:3.21.2.6 xc/lib/xtrans/Xtranslcl.c:3.21.2.8
--- xc/lib/xtrans/Xtranslcl.c:3.21.2.6	Fri Nov  6 01:03:07 1998
+++ xc/lib/xtrans/Xtranslcl.c	Fri Dec 18 22:56:11 1998
@@ -1,5 +1,5 @@
 /* $XConsortium: Xtranslcl.c /main/27 1996/09/28 16:50:14 rws $ */
-/* $XFree86: xc/lib/xtrans/Xtranslcl.c,v 3.21.2.6 1998/11/05 14:03:07 dawes Exp $ */
+/* $XFree86: xc/lib/xtrans/Xtranslcl.c,v 3.21.2.8 1998/12/18 11:56:11 dawes Exp $ */
 /*
 
 Copyright (c) 1993, 1994  X Consortium
@@ -81,8 +81,13 @@
 #include <sys/signal.h>
 #include <sys/ioctl.h>
 #include <sys/stat.h>
-#ifdef SVR4
+#if defined(SVR4)
+#if !defined(DGUX)
 #include <sys/filio.h>
+#else /* DGUX */
+#include <sys/stream.h>
+#include <sys/ptms.h>
+#endif
 #endif
 #include <sys/stropts.h>
 #include <sys/wait.h>
@@ -1239,7 +1244,7 @@
      * we recieved, we're doing another I_FDINSERT ...
      */
     (void) putmsg(fd, &ctlbuf, 0, 0);
-    (void) fcntl(fd,F_SETFL,fcntl(fd,F_GETFL,0)|O_NDELAY);
+    (void) fcntl(fd,F_SETFL,fcntl(fd,F_GETFL,0)|O_NONBLOCK);
     
     (void) close(server);
     
Index: xc/lib/xtrans/Xtranssock.c
diff -u xc/lib/xtrans/Xtranssock.c:3.25.2.6 xc/lib/xtrans/Xtranssock.c:3.25.2.7
--- xc/lib/xtrans/Xtranssock.c:3.25.2.6	Fri Nov  6 01:03:08 1998
+++ xc/lib/xtrans/Xtranssock.c	Fri Dec 18 22:56:11 1998
@@ -1,5 +1,5 @@
 /* $XConsortium: Xtranssock.c /main/58 1996/12/04 10:22:50 lehors $ */
-/* $XFree86: xc/lib/xtrans/Xtranssock.c,v 3.25.2.6 1998/11/05 14:03:08 dawes Exp $ */
+/* $XFree86: xc/lib/xtrans/Xtranssock.c,v 3.25.2.7 1998/12/18 11:56:11 dawes Exp $ */
 /*
 
 Copyright (c) 1993, 1994  X Consortium
@@ -101,7 +101,7 @@
 #include <netinet/tcp.h>
 #endif /* !NO_TCP_H */
 #include <sys/ioctl.h>
-#if defined(SVR4) && !defined(SCO325)
+#if defined(SVR4) && !defined(SCO325) && !defined(DGUX)
 #include <sys/filio.h>
 #endif
 #if (defined(i386) && defined(SYSV)) || defined(_SEQUENT_)
Index: xc/fonts/PEX/to_wfont.y
diff -u xc/fonts/PEX/to_wfont.y:3.6 xc/fonts/PEX/to_wfont.y:3.6.2.1
--- xc/fonts/PEX/to_wfont.y:3.6	Mon Dec 23 16:56:32 1996
+++ xc/fonts/PEX/to_wfont.y	Tue Dec 22 22:23:04 1998
@@ -1,6 +1,6 @@
 %{
 /* $XConsortium: to_wfont.y /main/9 1996/06/11 07:38:48 kaleb $ */
-/* $XFree86: xc/fonts/PEX/to_wfont.y,v 3.6 1996/12/23 05:56:32 dawes Exp $ */
+/* $XFree86: xc/fonts/PEX/to_wfont.y,v 3.6.2.1 1998/12/22 11:23:04 hohndel Exp $ */
 
 /*****************************************************************
 
@@ -351,7 +351,7 @@
 
 yyerror()
 {
-#if !defined(CSRG_BASED) && !defined(linux) && !defined(Lynx)
+#if !defined(CSRG_BASED) && !defined(linux) && !defined(Lynx) && !defined(__GNU__)
 	extern int      yylineno;
 #endif
 #	define ERR_SIZE (sizeof(err_string) / sizeof(char *))
@@ -374,7 +374,7 @@
 		str = err_string[yyerrno-1];
 	else
 		str = "Syntax error";
-#if !defined(CSRG_BASED) && !defined(linux) && !defined(Lynx)
+#if !defined(CSRG_BASED) && !defined(linux) && !defined(Lynx) && !defined(__GNU__)
 		fprintf(stderr, "line %d: %s.\n", yylineno, str);
 #else
 		fprintf(stderr, "%s.\n", str);
